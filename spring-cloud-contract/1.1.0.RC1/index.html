<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<title>Spring Cloud Contract</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>
</head>

<body class="article toc2 toc-left">
<div id="header">
<h1>Spring Cloud Contract</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_spring_cloud_contract">Spring Cloud Contract</a></li>
<li><a href="#_spring_cloud_contract_wiremock">Spring Cloud Contract WireMock</a>
<ul class="sectlevel2">
<li><a href="#_registering_stubs_automatically">Registering Stubs Automatically</a></li>
<li><a href="#_using_files_to_specify_the_stub_bodies">Using Files to Specify the Stub Bodies</a></li>
<li><a href="#_alternative_using_junit_rules">Alternative: Using JUnit Rules</a></li>
</ul>
</li>
<li><a href="#_wiremock_and_spring_mvc_mocks">WireMock and Spring MVC Mocks</a></li>
<li><a href="#_generating_stubs_using_restdocs">Generating Stubs using RestDocs</a></li>
<li><a href="#_generating_contracts_using_restdocs">Generating Contracts using RestDocs</a></li>
<li><a href="#_spring_cloud_contract_verifier">Spring Cloud Contract Verifier</a>
<ul class="sectlevel2">
<li><a href="#_introduction">Introduction</a>
<ul class="sectlevel3">
<li><a href="#_spring_cloud_contract_video">Spring Cloud Contract video</a></li>
<li><a href="#_why">Why?</a>
<ul class="sectlevel4">
<li><a href="#_testing_issues">Testing issues</a></li>
</ul>
</li>
<li><a href="#_purposes">Purposes</a></li>
<li><a href="#_client_side">Client Side</a></li>
<li><a href="#_server_side">Server Side</a></li>
<li><a href="#_step_by_step_guide_to_cdc">Step by step guide to CDC</a>
<ul class="sectlevel4">
<li><a href="#_technical_note">Technical note</a></li>
<li><a href="#_consumer_side_loan_issuance">Consumer side (Loan Issuance)</a></li>
<li><a href="#_producer_side_fraud_detection_server">Producer side (Fraud Detection server)</a></li>
<li><a href="#_consumer_side_loan_issuance_final_step">Consumer side (Loan Issuance) final step</a></li>
</ul>
</li>
<li><a href="#_dependencies">Dependencies</a></li>
<li><a href="#_additional_links">Additional links</a>
<ul class="sectlevel4">
<li><a href="#_readings">Readings</a></li>
</ul>
</li>
<li><a href="#_samples">Samples</a></li>
</ul>
</li>
<li><a href="#_faq">FAQ</a>
<ul class="sectlevel3">
<li><a href="#_why_use_spring_cloud_contract_verifier_and_not_x">Why use Spring Cloud Contract Verifier and not X ?</a></li>
<li><a href="#_what_is_this_value_consumer_producer">What is this value(consumer(), producer()) ?</a></li>
<li><a href="#_how_to_do_stubs_versioning">How to do Stubs versioning?</a>
<ul class="sectlevel4">
<li><a href="#_api_versioning">API Versioning</a></li>
<li><a href="#_jar_versioning">JAR versioning</a></li>
<li><a href="#_dev_or_prod_stubs">Dev or prod stubs</a></li>
</ul>
</li>
<li><a href="#_common_repo_with_contracts">Common repo with contracts</a>
<ul class="sectlevel4">
<li><a href="#_repo_structure">Repo structure</a></li>
<li><a href="#_workflow">Workflow</a>
<ul class="sectlevel5">
<li><a href="#_consumer">Consumer</a></li>
<li><a href="#_producer">Producer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_can_i_have_multiple_base_classes_for_tests">Can I have multiple base classes for tests?</a></li>
<li><a href="#_can_i_reference_the_request_from_the_response">Can I reference the request from the response?</a></li>
</ul>
</li>
<li><a href="#_spring_cloud_contract_verifier_http">Spring Cloud Contract Verifier HTTP</a>
<ul class="sectlevel3">
<li><a href="#_gradle_project">Gradle Project</a>
<ul class="sectlevel4">
<li><a href="#_prerequisites">Prerequisites</a>
<ul class="sectlevel5">
<li><a href="#_add_gradle_plugin_with_dependencies">Add gradle plugin with dependencies</a></li>
<li><a href="#_snapshot_versions_for_gradle">Snapshot versions for Gradle</a></li>
<li><a href="#_add_stubs">Add stubs</a></li>
</ul>
</li>
<li><a href="#_run_plugin">Run plugin</a></li>
<li><a href="#_default_setup">Default setup</a></li>
<li><a href="#_configure_plugin">Configure plugin</a>
<ul class="sectlevel5">
<li><a href="#_configuration_options">Configuration options</a></li>
<li><a href="#_single_base_class_for_all_tests">Single base class for all tests</a></li>
<li><a href="#_different_base_classes_for_contracts">Different base classes for contracts</a></li>
</ul>
</li>
<li><a href="#_invoking_generated_tests">Invoking generated tests</a></li>
<li><a href="#_spring_cloud_contract_verifier_on_consumer_side">Spring Cloud Contract Verifier on consumer side</a></li>
</ul>
</li>
<li><a href="#_using_in_your_maven_project">Using in your Maven project</a>
<ul class="sectlevel4">
<li><a href="#_add_maven_plugin">Add maven plugin</a>
<ul class="sectlevel5">
<li><a href="#_snapshot_versions_for_maven">Snapshot versions for Maven</a></li>
</ul>
</li>
<li><a href="#_add_stubs_2">Add stubs</a></li>
<li><a href="#_run_plugin_2">Run plugin</a></li>
<li><a href="#_configure_plugin_2">Configure plugin</a>
<ul class="sectlevel5">
<li><a href="#_important_configuration_options">Important configuration options</a></li>
<li><a href="#_single_base_class_for_all_tests_2">Single base class for all tests</a></li>
<li><a href="#_different_base_classes_for_contracts_2">Different base classes for contracts</a></li>
</ul>
</li>
<li><a href="#_invoking_generated_tests_2">Invoking generated tests</a></li>
<li><a href="#_faq_with_maven_plugin">FAQ with Maven Plugin</a>
<ul class="sectlevel5">
<li><a href="#_maven_plugin_and_sts">Maven Plugin and STS</a></li>
</ul>
</li>
<li><a href="#_spring_cloud_contract_verifier_on_consumer_side_2">Spring Cloud Contract Verifier on consumer side</a></li>
</ul>
</li>
<li><a href="#_scenarios">Scenarios</a></li>
<li><a href="#_stubs_and_transitive_dependencies">Stubs and transitive dependencies</a></li>
</ul>
</li>
<li><a href="#_spring_cloud_contract_verifier_messaging">Spring Cloud Contract Verifier Messaging</a>
<ul class="sectlevel3">
<li><a href="#_integrations">Integrations</a></li>
<li><a href="#_manual_integration_testing">Manual Integration Testing</a></li>
<li><a href="#_publisher_side_test_generation">Publisher side test generation</a>
<ul class="sectlevel4">
<li><a href="#_scenario_1_no_input_message">Scenario 1 (no input message)</a></li>
<li><a href="#_scenario_2_output_triggered_by_input">Scenario 2 (output triggered by input)</a></li>
<li><a href="#_scenario_3_no_output_message">Scenario 3 (no output message)</a></li>
</ul>
</li>
<li><a href="#_consumer_stub_side_generation">Consumer Stub Side generation</a></li>
</ul>
</li>
<li><a href="#_spring_cloud_contract_stub_runner">Spring Cloud Contract Stub Runner</a>
<ul class="sectlevel3">
<li><a href="#_snapshot_versions">Snapshot versions</a></li>
<li><a href="#_publishing_stubs_as_jars">Publishing stubs as JARs</a></li>
<li><a href="#_modules">Modules</a></li>
</ul>
</li>
<li><a href="#_stub_runner_core">Stub Runner Core</a>
<ul class="sectlevel3">
<li><a href="#_running_stubs">Running stubs</a>
<ul class="sectlevel4">
<li><a href="#_limitations">Limitations</a></li>
<li><a href="#_running_using_main_app">Running using main app</a></li>
<li><a href="#_http_stubs">HTTP Stubs</a></li>
<li><a href="#_viewing_registered_mappings">Viewing registered mappings</a></li>
<li><a href="#_messaging_stubs">Messaging Stubs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_stub_runner_junit_rule">Stub Runner JUnit Rule</a>
<ul class="sectlevel3">
<li><a href="#_maven_settings">Maven settings</a></li>
<li><a href="#_providing_fixed_ports">Providing fixed ports</a></li>
<li><a href="#_fluent_api">Fluent API</a></li>
<li><a href="#_stub_runner_with_spring">Stub Runner with Spring</a></li>
</ul>
</li>
<li><a href="#_stub_runner_spring_cloud">Stub Runner Spring Cloud</a>
<ul class="sectlevel3">
<li><a href="#_stubbing_service_discovery">Stubbing Service Discovery</a>
<ul class="sectlevel4">
<li><a href="#_test_profiles_and_service_discovery">Test profiles and service discovery</a></li>
</ul>
</li>
<li><a href="#_additional_configuration">Additional Configuration</a></li>
</ul>
</li>
<li><a href="#_stub_runner_boot_application">Stub Runner Boot Application</a>
<ul class="sectlevel3">
<li><a href="#_how_to_use_it">How to use it?</a></li>
<li><a href="#_endpoints">Endpoints</a>
<ul class="sectlevel4">
<li><a href="#_http">HTTP</a></li>
<li><a href="#_messaging">Messaging</a></li>
</ul>
</li>
<li><a href="#_example">Example</a></li>
<li><a href="#_stub_runner_boot_with_service_discovery">Stub Runner Boot with Service Discovery</a></li>
<li><a href="#_common_properties_for_junit_and_spring">Common properties for JUnit and Spring</a>
<ul class="sectlevel4">
<li><a href="#_stub_runner_stubs_ids">Stub runner stubs ids</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_stub_runner_for_messaging">Stub Runner for Messaging</a>
<ul class="sectlevel3">
<li><a href="#_stub_triggering">Stub triggering</a>
<ul class="sectlevel4">
<li><a href="#_trigger_by_label">Trigger by label</a>
<ul class="sectlevel5">
<li><a href="#_trigger_by_group_and_artifact_ids">Trigger by group and artifact ids</a></li>
<li><a href="#_trigger_by_artifact_ids">Trigger by artifact ids</a></li>
</ul>
</li>
<li><a href="#_trigger_all_messages">Trigger all messages</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_stub_runner_camel">Stub Runner Camel</a>
<ul class="sectlevel3">
<li><a href="#_adding_it_to_the_project">Adding it to the project</a></li>
<li><a href="#_examples">Examples</a>
<ul class="sectlevel4">
<li><a href="#_stubs_structure">Stubs structure</a></li>
<li><a href="#_scenario_1_no_input_message_2">Scenario 1 (no input message)</a></li>
<li><a href="#_scenario_2_output_triggered_by_input_2">Scenario 2 (output triggered by input)</a></li>
<li><a href="#_scenario_3_input_with_no_output">Scenario 3 (input with no output)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_stub_runner_integration">Stub Runner Integration</a>
<ul class="sectlevel3">
<li><a href="#_adding_it_to_the_project_2">Adding it to the project</a></li>
<li><a href="#_examples_2">Examples</a>
<ul class="sectlevel4">
<li><a href="#_stubs_structure_2">Stubs structure</a></li>
<li><a href="#_scenario_1_no_input_message_3">Scenario 1 (no input message)</a></li>
<li><a href="#_scenario_2_output_triggered_by_input_3">Scenario 2 (output triggered by input)</a></li>
<li><a href="#_scenario_3_input_with_no_output_2">Scenario 3 (input with no output)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_stub_runner_stream">Stub Runner Stream</a>
<ul class="sectlevel3">
<li><a href="#_adding_it_to_the_project_3">Adding it to the project</a></li>
<li><a href="#_examples_3">Examples</a>
<ul class="sectlevel4">
<li><a href="#_stubs_structure_3">Stubs structure</a></li>
<li><a href="#_scenario_1_no_input_message_4">Scenario 1 (no input message)</a></li>
<li><a href="#_scenario_2_output_triggered_by_input_4">Scenario 2 (output triggered by input)</a></li>
<li><a href="#_scenario_3_input_with_no_output_3">Scenario 3 (input with no output)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_stub_runner_spring_amqp">Stub Runner Spring AMQP</a>
<ul class="sectlevel3">
<li><a href="#_adding_it_to_the_project_4">Adding it to the project</a></li>
<li><a href="#_examples_4">Examples</a>
<ul class="sectlevel4">
<li><a href="#_stubs_structure_4">Stubs structure</a></li>
<li><a href="#_triggering_the_message">Triggering the message</a></li>
<li><a href="#_spring_amqp_test_configuration">Spring AMQP Test Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_contract_dsl">Contract DSL</a>
<ul class="sectlevel3">
<li><a href="#_limitations_2">Limitations</a></li>
<li><a href="#_common_top_level_elements">Common Top-Level elements</a>
<ul class="sectlevel4">
<li><a href="#_description">Description</a></li>
<li><a href="#_name">Name</a></li>
<li><a href="#_ignoring_contracts">Ignoring contracts</a></li>
</ul>
</li>
<li><a href="#_http_top_level_elements">HTTP Top-Level Elements</a></li>
<li><a href="#_request">Request</a></li>
<li><a href="#_response">Response</a></li>
<li><a href="#_dynamic_properties">Dynamic properties</a>
<ul class="sectlevel4">
<li><a href="#_dynamic_properties_inside_the_body">Dynamic properties inside the body</a>
<ul class="sectlevel5">
<li><a href="#_regular_expressions">Regular expressions</a></li>
<li><a href="#_passing_optional_parameters">Passing optional parameters</a></li>
<li><a href="#_executing_custom_methods_on_server_side">Executing custom methods on server side</a></li>
</ul>
</li>
<li><a href="#_referencing_request_from_response">Referencing request from response</a></li>
<li><a href="#_dynamic_properties_in_matchers_sections">Dynamic properties in matchers sections</a></li>
</ul>
</li>
<li><a href="#_jax_rs_support">JAX-RS support</a></li>
<li><a href="#_async_support">Async support</a></li>
<li><a href="#_working_with_context_paths">Working with Context Paths</a></li>
<li><a href="#_messaging_top_level_elements">Messaging Top-Level Elements</a>
<ul class="sectlevel4">
<li><a href="#_output_triggered_by_a_method">Output triggered by a method</a></li>
<li><a href="#_output_triggered_by_a_message">Output triggered by a message</a></li>
<li><a href="#_consumer_producer">Consumer / Producer</a></li>
</ul>
</li>
<li><a href="#_multiple_contracts_in_one_file">Multiple contracts in one file</a></li>
</ul>
</li>
<li><a href="#_customization">Customization</a>
<ul class="sectlevel3">
<li><a href="#_extending_the_dsl">Extending the DSL</a>
<ul class="sectlevel4">
<li><a href="#_common_jar">Common JAR</a></li>
<li><a href="#_adding_the_dependency_to_project">Adding the dependency to project</a>
<ul class="sectlevel5">
<li><a href="#_test_dependency_in_project_s_dependencies">Test dependency in project&#8217;s dependencies</a></li>
<li><a href="#_test_dependency_in_plugin_s_dependencies">Test dependency in plugin&#8217;s dependencies</a></li>
<li><a href="#_referencing_classes_in_dsls">Referencing classes in DSLs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_pluggable_architecture">Pluggable architecture</a>
<ul class="sectlevel3">
<li><a href="#_custom_contract_converter">Custom contract converter</a>
<ul class="sectlevel4">
<li><a href="#_pact_converter">Pact converter</a>
<ul class="sectlevel5">
<li><a href="#_pact_contract">Pact contract</a></li>
<li><a href="#_pact_for_producers">Pact for producers</a></li>
<li><a href="#_pact_for_consumers">Pact for consumers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_custom_test_generator">Custom test generator</a></li>
<li><a href="#_custom_stub_generator">Custom stub generator</a></li>
<li><a href="#_custom_stub_runner">Custom Stub Runner</a></li>
<li><a href="#_custom_stub_downloader">Custom Stub Downloader</a></li>
</ul>
</li>
<li><a href="#_links">Links</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Documentation Authors: Adam Dudczak, Mathias Düsterhöft, Marcin Grzejszczak, Dennis Kieselhorst, Jakub Kubryński, Karol Lassak,
Olga Maciaszek-Sharma, Mariusz Smykuła, Dave Syer</em></p>
</div>
<div class="paragraph">
<p>1.1.0.RC1</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_cloud_contract">Spring Cloud Contract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What you always need is confidence in pushing new features into a new application or service in a distributed system.
This project provides support for Consumer Driven Contracts and service schemas in Spring applications, covering a
range of options for writing tests, publishing them as assets, asserting that a contract is kept by producers
and consumers, for HTTP and message-based interactions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_cloud_contract_wiremock">Spring Cloud Contract WireMock</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Modules giving you the possibility to use
<a href="http://wiremock.org">WireMock</a> with different servers by using the
"ambient" server embedded in a Spring Boot application. Check out the
<a href="https://github.com/spring-cloud/spring-cloud-contract/tree/1.0.x/samples">samples</a>
for more details.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
The Spring Cloud Release Train BOM imports <code>spring-cloud-contract-dependencies</code>
 which in turn has exclusions for the dependencies needed by WireMock. This might lead to a situation that
 even if you&#8217;re not using Spring Cloud Contract then your dependencies will be influenced
 anyways.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you have a Spring Boot application that uses Tomcat as an embedded
server, for example (the default with <code>spring-boot-starter-web</code>), then
you can simply add <code>spring-cloud-contract-wiremock</code> to your classpath
and add <code>@AutoConfigureWireMock</code> in order to be able to use Wiremock
in your tests. Wiremock runs as a stub server and you can register
stub behaviour using a Java API or via static JSON declarations as
part of your test. Here&#8217;s a simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureWireMock(port = 0)
public class WiremockForDocsTests {
	// A service that calls out over HTTP
	@Autowired private Service service;

	// Using the WireMock APIs in the normal way:
	@Test
	public void contextLoads() throws Exception {
		// Stubbing WireMock
		stubFor(get(urlEqualTo("/resource"))
				.willReturn(aResponse().withHeader("Content-Type", "text/plain").withBody("Hello World!")));
		// We're asserting if WireMock responded properly
		assertThat(this.service.go()).isEqualTo("Hello World!");
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To start the stub server on a different port use <code>@AutoConfigureWireMock(port=9999)</code> (for example), and for a random port use the value 0. The stub server port will be bindable in the test application context as "wiremock.server.port". Using <code>@AutoConfigureWireMock</code> adds a bean of type <code>WiremockConfiguration</code> to your test application context, where it will be cached in between methods and classes having the same context, just like for normal Spring integration tests.</p>
</div>
<div class="sect2">
<h3 id="_registering_stubs_automatically">Registering Stubs Automatically</h3>
<div class="paragraph">
<p>If you use <code>@AutoConfigureWireMock</code> then it will register WireMock
JSON stubs from the file system or classpath, by default from
<code>file:src/test/resources/mappings</code>. You can customize the locations
using the <code>stubs</code> attribute in the annotation, which can be a resource
pattern (ant-style) or a directory, in which case <code><strong>*/</strong>.json</code> is
appended. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureWireMock(stubs="classpath:/stubs")
public class WiremockImportApplicationTests {

	@Autowired
	private Service service;

	@Test
	public void contextLoads() throws Exception {
		assertThat(this.service.go()).isEqualTo("Hello World!");
	}

}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Actually WireMock always loads mappings from
<code>src/test/resources/mappings</code> <strong>as well as</strong> the custom locations in the
stubs attribute. To change this behaviour you have to also specify a
files root as described next.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_using_files_to_specify_the_stub_bodies">Using Files to Specify the Stub Bodies</h3>
<div class="paragraph">
<p>WireMock can read response bodies from files on the classpath or file
system. In that case you will see in the JSON DSL that the response
has a "bodyFileName" instead of a (literal) "body". The files are
resolved relative to a root directory <code>src/test/resources/__files</code> by
default. To customize this location you can set the <code>files</code> attribute
in the <code>@AutoConfigureWireMock</code> annotation to the location of the
parent directory (i.e. the place <code>__files</code> is a
subdirectory). You can use Spring resource notation to refer to
<code>file:&#8230;&#8203;</code> or <code>classpath:&#8230;&#8203;</code> locations (but generic URLs are not
supported). A list of values can be given and WireMock will resolve
the first file that exists when it needs to find a response body.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
when you configure the <code>files</code> root, then it affects the
automatic loading of stubs as well (they come from the root location
in a subdirectory called "mappings"). The value of <code>files</code> has no
effect on the stubs loaded explicitly from the <code>stubs</code> attribute.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_alternative_using_junit_rules">Alternative: Using JUnit Rules</h3>
<div class="paragraph">
<p>For a more conventional WireMock experience, using JUnit <code>@Rules</code> to
start and stop the server, just use the <code>WireMockSpring</code> convenience
class to obtain an <code>Options</code> instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class WiremockForDocsClassRuleTests {

	// Start WireMock on some dynamic port
	// for some reason `dynamicPort()` is not working properly
	@ClassRule
	public static WireMockClassRule wiremock = new WireMockClassRule(
			WireMockSpring.options().dynamicPort());
	// A service that calls out over HTTP to localhost:${wiremock.port}
	@Autowired
	private Service service;

	// Using the WireMock APIs in the normal way:
	@Test
	public void contextLoads() throws Exception {
		// Stubbing WireMock
		wiremock.stubFor(get(urlEqualTo("/resource"))
				.willReturn(aResponse().withHeader("Content-Type", "text/plain").withBody("Hello World!")));
		// We're asserting if WireMock responded properly
		assertThat(this.service.go()).isEqualTo("Hello World!");
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The use <code>@ClassRule</code> means that the server will shut down after all the methods in this class.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wiremock_and_spring_mvc_mocks">WireMock and Spring MVC Mocks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Contract provides a convenience class that can load JSON WireMock stubs into a
Spring <code>MockRestServiceServer</code>. Here&#8217;s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
public class WiremockForDocsMockServerApplicationTests {

	@Autowired
	private RestTemplate restTemplate;

	@Autowired
	private Service service;

	@Test
	public void contextLoads() throws Exception {
		// will read stubs classpath
		MockRestServiceServer server = WireMockRestServiceServer.with(this.restTemplate)
				.baseUrl("https://example.org").stubs("classpath:/stubs/resource.json")
				.build();
		// We're asserting if WireMock responded properly
		assertThat(this.service.go()).isEqualTo("Hello World");
		server.verify();
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>baseUrl</code> is prepended to all mock calls, and the <code>stubs()</code>
method takes a stub path resource pattern as an argument. So in this
example the stub defined at <code>/stubs/resource.json</code> is loaded into the
mock server, so if the <code>RestTemplate</code> is asked to visit
<code><a href="https://example.org/" class="bare">https://example.org/</a></code> it will get the responses as declared
there. More than one stub pattern can be specified, and each one can
be a directory (for a recursive list of all ".json"), or a fixed
filename (like in the example above) or an ant-style pattern. The JSON
format is the normal WireMock format which you can read about in the
WireMock website.</p>
</div>
<div class="paragraph">
<p>Currently we support Tomcat, Jetty and Undertow as Spring Boot
embedded servers, and Wiremock itself has "native" support for a
particular version of Jetty (currently 9.2). To use the native Jetty
you need to add the native wiremock dependencies and exclude the
Spring Boot container if there is one.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generating_stubs_using_restdocs">Generating Stubs using RestDocs</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://projects.spring.io/spring-restdocs">Spring RestDocs</a> can be
used to generate documentation (e.g. in asciidoctor format) for an
HTTP API with Spring MockMvc or RestEasy. At the same time as you
generate documentation for your API, you can also generate WireMock
stubs, by using Spring Cloud Contract WireMock. Just write your normal
RestDocs test cases and use <code>@AutoConfigureRestDocs</code> to have stubs
automatically in the restdocs output directory. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureRestDocs(outputDir = "target/snippets")
@AutoConfigureMockMvc
public class ApplicationTests {

	@Autowired
	private MockMvc mockMvc;

	@Test
	public void contextLoads() throws Exception {
		mockMvc.perform(get("/resource"))
				.andExpect(content().string("Hello World"))
				.andDo(document("resource"));
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>From this test will be generated a WireMock stub at
"target/snippets/stubs/resource.json". It matches all GET requests to
the "/resource" path.</p>
</div>
<div class="paragraph">
<p>Without any additional configuration this will create a stub with a
request matcher for the HTTP method and all headers except "host" and
"content-length". To match the request more precisely, for example to
match the body of a POST or PUT, we need to explicitly create a
request matcher. This will do two things: 1) create a stub that only
matches the way you specify, 2) assert that the request in the test
case also matches the same conditions.</p>
</div>
<div class="paragraph">
<p>The main entry point for this is <code>WireMockRestDocs.verify()</code> which can
be used as a substitute for the <code>document()</code> convenience method. For
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureRestDocs(outputDir = "target/snippets")
@AutoConfigureMockMvc
public class ApplicationTests {

	@Autowired
	private MockMvc mockMvc;

	@Test
	public void contextLoads() throws Exception {
		mockMvc.perform(post("/resource")
                .content("{\"id\":\"123456\",\"message\":\"Hello World\"}"))
				.andExpect(status().isOk())
				.andDo(verify().jsonPath("$.id")
                        .stub("resource"));
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So this contract is saying: any valid POST with an "id" field will get
back an the same response as in this test. You can chain together
calls to <code>.jsonPath()</code> to add additional matchers. The
<a href="https://github.com/jayway/JsonPath">JayWay documentation</a> can help you
to get up to speed with JSON Path if it is unfamiliar to you.</p>
</div>
<div class="paragraph">
<p>Instead of the <code>jsonPath</code> and <code>contentType</code> convenience methods, you
can also use the WireMock APIs to verify the request matches the
created stub. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void contextLoads() throws Exception {
	mockMvc.perform(post("/resource")
               .content("{\"id\":\"123456\",\"message\":\"Hello World\"}"))
			.andExpect(status().isOk())
			.andDo(verify()
					.wiremock(WireMock.post(
						urlPathEquals("/resource"))
						.withRequestBody(matchingJsonPath("$.id"))
                       .stub("post-resource"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The WireMock API is rich - you can match headers, query parameters,
and request body by regex as well as by json path - so this can useful
to create stubs with a wider range of parameters. The above example
will generate a stub something like this:</p>
</div>
<div class="listingblock">
<div class="title">post-resource.json</div>
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "request" : {
    "url" : "/resource",
    "method" : "POST",
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$.id"
    }]
  },
  "response" : {
    "status" : 200,
    "body" : "Hello World",
    "headers" : {
      "X-Application-Context" : "application:-1",
      "Content-Type" : "text/plain"
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You can use either the <code>wiremock()</code> method or the <code>jsonPath()</code>
and <code>contentType()</code> methods to create request matchers, but not both.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the consumer side, assuming the <code>resource.json</code> generated above is
available on the classpath, you can create a stub using WireMock in a
number of different ways, including as described above using
<code>@AutoConfigureWireMock(stubs="classpath:resource.json")</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generating_contracts_using_restdocs">Generating Contracts using RestDocs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another thing that can be generated with Spring RestDocs is the Spring Cloud
Contract DSL file and documentation. If you combine that with Spring Cloud
WireMock then you&#8217;re getting both the contracts and stubs.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
You might wonder why this functionality is in the WireMock module.
Come to think of it, it does make sense since it makes little sense to generate
only contracts and not generate the stubs. That&#8217;s why we suggest to do both.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s imagine the following test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">		this.mockMvc.perform(post("/foo")
					.accept(MediaType.APPLICATION_PDF)
					.accept(MediaType.APPLICATION_JSON)
					.contentType(MediaType.APPLICATION_JSON)
					.content("{\"foo\": 23 }"))
				.andExpect(status().isOk())
				.andExpect(content().string("bar"))
				// first WireMock
				.andDo(WireMockRestDocs.verify()
						.jsonPath("$[?(@.foo &gt;= 20)]")
						.contentType(MediaType.valueOf("application/json"))
						.stub("shouldGrantABeerIfOldEnough"))
				// then Contract DSL documentation
				.andDo(document("index", SpringCloudContractRestDocs.dslContract()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will lead in the creation of the stub as presented in the previous
section, contract will get generated and a documentation file too.</p>
</div>
<div class="paragraph">
<p>The contract will be called <code>index.groovy</code> and look more like this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import org.springframework.cloud.contract.spec.Contract

Contract.make {
    request {
        method 'POST'
        url 'http://localhost:8080/foo'
        body('''
            {"foo": 23 }
        ''')
        headers {
            header('''Accept''', '''application/json''')
            header('''Content-Type''', '''application/json''')
            header('''Host''', '''localhost:8080''')
            header('''Content-Length''', '''12''')
        }
    }
    response {
        status 200
        body('''
        bar
        ''')
        headers {
            header('''Content-Type''', '''application/json;charset=UTF-8''')
            header('''Content-Length''', '''3''')
        }
        testMatchers {
            jsonPath('$[?(@.foo &gt;= 20)]', byType())
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>the generated document (example for Asciidoc) will contain a formatted contract
(the location of this file would be <code>index/dsl-contract.adoc</code>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_cloud_contract_verifier">Spring Cloud Contract Verifier</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction">Introduction</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<a href="https://codearte.github.io/accurest">The documentation to the deprecated Accurest project in version 1.1.0 is available here.</a>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
The Accurest project was initially started by Marcin Grzejszczak and Jakub Kubrynski (<a href="http://codearte.io">codearte.io</a>)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Just to make long story short - Spring Cloud Contract Verifier is a tool that enables Consumer Driven Contract (CDC) development of JVM-based applications. It is shipped
with <em>Contract Definition Language</em> (DSL). Contract definitions are used to produce following resources:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JSON stub definitions to be used by WireMock when doing integration testing on the client code (<em>client tests</em>).
Test code must still be written by hand, test data is produced by Spring Cloud Contract Verifier.</p>
</li>
<li>
<p>Messaging routes if you&#8217;re using one. We&#8217;re integrating with Spring Integration, Spring Cloud Stream, Spring AMQP and Apache Camel. You can however set your own integrations if you want to</p>
</li>
<li>
<p>Acceptance tests (in JUnit or Spock) used to verify if server-side implementation of the API is compliant with the contract (<em>server tests</em>).
Full test is generated by Spring Cloud Contract Verifier.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Cloud Contract Verifier moves TDD to the level of software architecture.</p>
</div>
<div class="sect3">
<h4 id="_spring_cloud_contract_video">Spring Cloud Contract video</h4>
<div class="paragraph">
<p>You can check out the video from the Warsaw JUG about Spring Cloud Contract:</p>
</div>
<div class="videoblock">
<div class="content">
<iframe width="640" height="480" src="https://www.youtube.com/embed/sAAklvxmPmk?rel=0&amp;start=538" frameborder="0" allowfullscreen></iframe>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_why">Why?</h4>
<div class="paragraph">
<p>Let us assume that we have a system comprising of multiple microservices:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-contract/1.0.x/docs/src/main/asciidoc/images/Deps.png" alt="Microservices Architecture">
</div>
</div>
<div class="sect4">
<h5 id="_testing_issues">Testing issues</h5>
<div class="paragraph">
<p>If we wanted to test the application in top left corner if it can communicate with other services then we could do one of two things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>deploy all microservices and perform end to end tests</p>
</li>
<li>
<p>mock other microservices in unit / integration tests</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both have their advantages but also a lot of disadvantages. Let&#8217;s focus on the latter.</p>
</div>
<div class="paragraph">
<p><strong>Deploy all microservices and perform end to end tests</strong></p>
</div>
<div class="paragraph">
<p>Advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>simulates production</p>
</li>
<li>
<p>tests real communication between services</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Disadvantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>to test one microservice we would have to deploy 6 microservices, a couple of databases etc.</p>
</li>
<li>
<p>the environment where the tests would be conducted would be locked for a single suite of tests (i.e. nobody else would be able to run the tests in the meantime).</p>
</li>
<li>
<p>long to run</p>
</li>
<li>
<p>very late feedback</p>
</li>
<li>
<p>extremely hard to debug</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Mock other microservices in unit / integration tests</strong></p>
</div>
<div class="paragraph">
<p>Advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>very fast feedback</p>
</li>
<li>
<p>no infrastructure requirements</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Disadvantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the implementor of the service creates stubs thus they might have nothing to do with the reality</p>
</li>
<li>
<p>you can go to production with passing tests and failing production</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To solve the aforementioned issues Spring Cloud Contract Verifier with Stub Runner were created. Their main idea is to give you very fast feedback, without the need
to set up the whole world of microservices.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-contract/1.0.x/docs/src/main/asciidoc/images/Stubs1.png" alt="Stubbed Services">
</div>
</div>
<div class="paragraph">
<p>If you work on stubs then the only applications you need are those that your application is using directly.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-contract/1.0.x/docs/src/main/asciidoc/images/Stubs2.png" alt="Stubbed Services">
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Contract Verifier gives you the certainty that the stubs that you&#8217;re using were created by the service that you&#8217;re calling. Also if you can use them it means that they were
tested against the producer&#8217;s side. In other words - you can trust those stubs.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_purposes">Purposes</h4>
<div class="paragraph">
<p>The main purposes of Spring Cloud Contract Verifier with Stub Runner are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>to ensure that WireMock / Messaging stubs (used when developing the client) are doing exactly what actual server-side implementation will do,</p>
</li>
<li>
<p>to promote ATDD method and Microservices architectural style,</p>
</li>
<li>
<p>to provide a way to publish changes in contracts that are immediately visible on both sides,</p>
</li>
<li>
<p>to generate boilerplate test code used on the server side.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Spring Cloud Contract Verifier&#8217;s purpose is NOT to start writing business features in the contracts.
Let&#8217;s assume that we have a business use case of fraud check. If a user can be a fraud for 100 different reasons,
we would assume that you would create 2 contracts. One for the positive and one for the negative fraud case.
Contract tests are used to test contracts between applications and not to simulate full behaviour.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_client_side">Client Side</h4>
<div class="paragraph">
<p>During the tests you want to have a WireMock instance / Messaging route up and running that simulates the service Y.
You would like to feed that instance with a proper stub definition. That stub definition would need
to be valid and should also be reusable on the server side.</p>
</div>
<div class="paragraph">
<p><em>Summing it up:</em> On this side, in the stub definition, you can use patterns for request stubbing and you need exact
values for responses.</p>
</div>
</div>
<div class="sect3">
<h4 id="_server_side">Server Side</h4>
<div class="paragraph">
<p>Being a service Y since you are developing your stub, you need to be sure that it&#8217;s actually resembling your
concrete implementation. You can&#8217;t have a situation where your stub acts in one way and your application on
production behaves in a different way.</p>
</div>
<div class="paragraph">
<p>That&#8217;s why from the provided stub acceptance tests will be generated that will ensure
that your application behaves in the same way as you define in your stub.</p>
</div>
<div class="paragraph">
<p><em>Summing it up:</em> On this side, in the stub definition, you need exact values as request and can use patterns/methods
for response verification.</p>
</div>
</div>
<div class="sect3">
<h4 id="_step_by_step_guide_to_cdc">Step by step guide to CDC</h4>
<div class="paragraph">
<p>Let&#8217;s take an example of Fraud Detection and Loan Issuance process. The business scenario is such that we want to issue loans to people but don&#8217;t want them to steal the money from us. The current implementation of our system grants loans to everybody.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that the <code>Loan Issuance</code> is a client to the
<code>Fraud Detection</code> server. In the current sprint we are required to develop a new feature - if a client wants to borrow too much money then we mark him as fraud.</p>
</div>
<div class="paragraph">
<p>Technical remark - Fraud Detection will have artifact id <code>http-server</code>, Loan Issuance <code>http-client</code> and both have group id <code>com.example</code>.</p>
</div>
<div class="paragraph">
<p>Social remark - both client and server development teams need to communicate directly and discuss changes while
going through the process. CDC is all about communication.</p>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/spring-cloud/spring-cloud-contract/tree/1.0.x/samples/standalone/dsl/http-server">server side code is available here</a> and <a href="https://github.com/spring-cloud/spring-cloud-contract/tree/1.0.x/samples/standalone/dsl/http-client">the client side code here</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
In this case the ownership of the contracts lays on the producer side. It means that physically
all the contract are present in the producer&#8217;s repository
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_technical_note">Technical note</h5>
<div class="paragraph">
<p>If using the <strong>SNAPSHOT</strong> / <strong>Milestone</strong> / <strong>Release Candidate</strong> versions please add the following section to your</p>
</div>
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
	mavenCentral()
	mavenLocal()
	maven { url "https://repo.spring.io/snapshot" }
	maven { url "https://repo.spring.io/milestone" }
	maven { url "https://repo.spring.io/release" }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_consumer_side_loan_issuance">Consumer side (Loan Issuance)</h5>
<div class="paragraph">
<p>As a developer of the Loan Issuance service (a consumer of the Fraud Detection server):</p>
</div>
<div class="paragraph">
<p><strong>start doing TDD by writing a test to your feature</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@Test
public void shouldBeRejectedDueToAbnormalLoanAmount() {
	// given:
	LoanApplication application = new LoanApplication(new Client("1234567890"),
			99999);
	// when:
	LoanApplicationResult loanApplication = service.loanApplication(application);
	// then:
	assertThat(loanApplication.getLoanApplicationStatus())
			.isEqualTo(LoanApplicationStatus.LOAN_APPLICATION_REJECTED);
	assertThat(loanApplication.getRejectionReason()).isEqualTo("Amount too high");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve just written a test of our new feature. If a loan application for a big amount is received we should reject that loan application with some description.</p>
</div>
<div class="paragraph">
<p><strong>write the missing implementation</strong></p>
</div>
<div class="paragraph">
<p>At some point in time you need to send a request to the Fraud Detection service. Let&#8217;s assume that we&#8217;d like to send the request containing the id of the client and the amount he wants to borrow from us. We&#8217;d like to send it to the <code>/fraudcheck</code> url via the <code>PUT</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">ResponseEntity&lt;FraudServiceResponse&gt; response =
		restTemplate.exchange("http://localhost:" + port + "/fraudcheck", HttpMethod.PUT,
				new HttpEntity&lt;&gt;(request, httpHeaders),
				FraudServiceResponse.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>For simplicity we&#8217;ve hardcoded the port of the Fraud Detection service at <code>8080</code> and our application is running on <code>8090</code>.</p>
</div>
<div class="paragraph">
<p>If we&#8217;d start the written test it would obviously break since we have no service running on port <code>8080</code>.</p>
</div>
<div class="paragraph">
<p><strong>clone the Fraud Detection service repository locally</strong></p>
</div>
<div class="paragraph">
<p>We&#8217;ll start playing around with the server side contract. That&#8217;s why we need to first clone it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">git clone https://your-git-server.com/server-side.git local-http-server-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>define the contract locally in the repo of Fraud Detection service</strong></p>
</div>
<div class="paragraph">
<p>As consumers we need to define what exactly we want to achieve. We need to formulate our expectations. That&#8217;s why we write the following contract.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
We&#8217;re placing the contract under <code>src/test/resources/contract/fraud</code> folder. The <code>fraud</code> folder
is important cause we&#8217;ll reference that folder in the producer&#8217;s test base class name.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package contracts

org.springframework.cloud.contract.spec.Contract.make {
	request { // (1)
		method 'PUT' // (2)
		url '/fraudcheck' // (3)
		body([ // (4)
			   clientId: $(regex('[0-9]{10}')),
			   loanAmount: 99999
		])
		headers { // (5)
			contentType('application/vnd.fraud.v1+json')
		}
	}
	response { // (6)
		status 200 // (7)
		body([ // (8)
			   fraudCheckStatus: "FRAUD",
			   rejectionReason: "Amount too high"
		])
		headers { // (9)
			contentType('application/vnd.fraud.v1+json')
		}
	}
}

/*
Since we don't want to force on the user to hardcode values of fields that are dynamic
(timestamps, database ids etc.), one can parametrize those entries. If you wrap your field's
 value in a `$(...)` or `value(...)` and provide a dynamic value of a field then
 the concrete value will be generated for you. If you want to be really explicit about
 which side gets which value you can do that by using the `value(consumer(...), producer(...))` notation.
 That way what's present in the `consumer` section will end up in the produced stub. What's
 there in the `producer` will end up in the autogenerated test. If you provide only the
 regular expression side without the concrete value then Spring Cloud Contract will generate one for you.

From the Consumer perspective, when shooting a request in the integration test:

(1) - If the consumer sends a request
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `clientId` that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/vnd.fraud.v1+json`
(6) - then the response will be sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` equal to `application/vnd.fraud.v1+json`

From the Producer perspective, in the autogenerated producer-side test:

(1) - A request will be sent to the producer
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `clientId` that will have a generated value that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/vnd.fraud.v1+json`
(6) - then the test will assert if the response has been sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` matching `application/vnd.fraud.v1+json.*`
 */</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Contract is written using a statically typed Groovy DSL. You might be wondering what are those
<code>value(client(&#8230;&#8203;), server(&#8230;&#8203;))</code> parts. By using this notation Spring Cloud Contract allows you to
define parts of a JSON / URL / etc. which are dynamic. In case of an identifier or a timestamp you
don&#8217;t want to hardcode a value. You want to allow some different ranges of values. That&#8217;s why for
the consumer side you can set regular expressions matching those values. You can provide the body
either by means of a map notation or String with interpolations.
<a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_contract_dsl">Consult the docs
for more information.</a> We highly recommend using the map notation!</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
It&#8217;s really important that you understand the map notation to set up contracts. Please read the
<a href="http://groovy-lang.org/json.html">Groovy docs regarding JSON</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The aforementioned contract is an agreement between two sides that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if an HTTP request is sent with</p>
<div class="ulist">
<ul>
<li>
<p>a method <code>PUT</code> on an endpoint <code>/fraudcheck</code></p>
</li>
<li>
<p>JSON body with <code>clientPesel</code> matching the regular expression <code>[0-9]{10}</code> and <code>loanAmount</code> equal to <code>99999</code></p>
</li>
<li>
<p>and with a header <code>Content-Type</code> equal to <code>application/vnd.fraud.v1+json</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>then an HTTP response would be sent to the consumer that</p>
<div class="ulist">
<ul>
<li>
<p>has status <code>200</code></p>
</li>
<li>
<p>contains JSON body with the <code>fraudCheckStatus</code> field containing a value <code>FRAUD</code> and the <code>rejectionReason</code> field having value <code>Amount too high</code></p>
</li>
<li>
<p>and a <code>Content-Type</code> header with a value of <code>application/vnd.fraud.v1+json</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once we&#8217;re ready to check the API in practice in the integration tests we need to just install the stubs locally</p>
</div>
<div class="paragraph">
<p><strong>add the Spring Cloud Contract Verifier plugin</strong></p>
</div>
<div class="paragraph">
<p>We can add either Maven or Gradle plugin - in this example we&#8217;ll show how to add Maven. First we need to add the <code>Spring Cloud Contract</code> BOM.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, the <code>Spring Cloud Contract Verifier</code> Maven plugin</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the plugin was added we get the <code>Spring Cloud Contract Verifier</code> features which from the provided contracts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>generate and run tests</p>
</li>
<li>
<p>produce and install stubs</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We don&#8217;t want to generate tests since we, as consumers, want only to play with the stubs. That&#8217;s why we need to skip the tests generation and execution. When we execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">cd local-http-server-repo
./mvnw clean install -DskipTests</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the logs we&#8217;ll see something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">[INFO] --- spring-cloud-contract-maven-plugin:1.0.0.BUILD-SNAPSHOT:generateStubs (default-generateStubs) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar
[INFO]
[INFO] --- maven-jar-plugin:2.6:jar (default-jar) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-0.0.1-SNAPSHOT.jar
[INFO]
[INFO] --- spring-boot-maven-plugin:1.5.0.BUILD-SNAPSHOT:repackage (default) @ http-server ---
[INFO]
[INFO] --- maven-install-plugin:2.5.2:install (default-install) @ http-server ---
[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT.jar
[INFO] Installing /some/path/http-server/pom.xml to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT.pom
[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>This line is extremely important</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s confirming that the stubs of the <code>http-server</code> have been installed in the local repository.</p>
</div>
<div class="paragraph">
<p><strong>run the integration tests</strong></p>
</div>
<div class="paragraph">
<p>In order to profit from the Spring Cloud Contract Stub Runner functionality of automatic stub downloading you have to do the following in our consumer side project (<code>Loan Application service</code>).</p>
</div>
<div class="paragraph">
<p>Add the <code>Spring Cloud Contract</code> BOM</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Add the dependency to <code>Spring Cloud Contract Stub Runner</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-starter-contract-stub-runner&lt;/artifactId&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Annotate your test class with <code>@AutoConfigureStubRunner</code>. In the annotation provide the group id and artifact id for the Stub Runner to download stubs of your collaborators. Also provide the offline work switch since you&#8217;re playing with the collaborators offline (optional step).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment=WebEnvironment.NONE)
@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:6565"}, workOffline = true)
@DirtiesContext
public class LoanApplicationServiceTests {</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if you run your tests you&#8217;ll see sth like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">2016-07-19 14:22:25.403  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Desired version is + - will try to resolve the latest version
2016-07-19 14:22:25.438  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved version is 0.0.1-SNAPSHOT
2016-07-19 14:22:25.439  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolving artifact com.example:http-server:jar:stubs:0.0.1-SNAPSHOT using remote repositories []
2016-07-19 14:22:25.451  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved artifact com.example:http-server:jar:stubs:0.0.1-SNAPSHOT to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar
2016-07-19 14:22:25.465  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacking stub from JAR [URI: file:/path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar]
2016-07-19 14:22:25.475  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacked file to [/var/folders/0p/xwq47sq106x1_g3dtv6qfm940000gq/T/contracts100276532569594265]
2016-07-19 14:22:27.737  INFO 41050 --- [           main] o.s.c.c.stubrunner.StubRunnerExecutor    : All stubs are now running RunningStubs [namesAndPorts={com.example:http-server:0.0.1-SNAPSHOT:stubs=8080}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which means that Stub Runner has found your stubs and started a server for app with group id <code>com.example</code>, artifact id <code>http-server</code> with version <code>0.0.1-SNAPSHOT</code> of the stubs and with <code>stubs</code> classifier on port <code>8080</code>.</p>
</div>
<div class="paragraph">
<p><strong>file a PR</strong></p>
</div>
<div class="paragraph">
<p>What we did until now is an iterative process. We can play around with the contract, install it locally and work on the consumer side until we&#8217;re happy with the contract.</p>
</div>
<div class="paragraph">
<p>Once we&#8217;re satisfied with the results and the test passes publish a PR to the server side. Currently the consumer side work is done.</p>
</div>
</div>
<div class="sect4">
<h5 id="_producer_side_fraud_detection_server">Producer side (Fraud Detection server)</h5>
<div class="paragraph">
<p>As a developer of the Fraud Detection server (a server to the Loan Issuance service):</p>
</div>
<div class="paragraph">
<p><strong>initial implementation</strong></p>
</div>
<div class="paragraph">
<p>As a reminder here you can see the initial implementation</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RequestMapping(
		value = "/fraudcheck",
		method = PUT,
		consumes = FRAUD_SERVICE_JSON_VERSION_1,
		produces = FRAUD_SERVICE_JSON_VERSION_1)
public FraudCheckResult fraudCheck(@RequestBody FraudCheck fraudCheck) {
return new FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>take over the PR</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">git checkout -b contract-change-pr master
git pull https://your-git-server.com/server-side-fork.git contract-change-pr</code></pre>
</div>
</div>
<div class="paragraph">
<p>You have to add the dependencies needed by the autogenerated tests</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">	&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-starter-contract-verifier&lt;/artifactId&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the configuration of the Maven plugin we passed the <code>packageWithBaseClasses</code> property</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
We&#8217;ve decided to use the "convention based" naming by setting the <code>packageWithBaseClasses</code> property.
That means that 2 last packages will be combined into a name of the base test class. In our case the contracts
were placed under <code>src/test/resources/contract/fraud</code>. Since we don&#8217;t have 2 packages starting from the <code>contracts</code>
folder we&#8217;re picking only one which is <code>fraud</code>. We&#8217;re adding the <code>Base</code> suffix and we&#8217;re capitalizing <code>fraud</code>.
That gives us the <code>FraudBase</code> test class name.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That&#8217;s because all the generated tests will extend that class. Over there you can set up your Spring Context or
whatever is necessary. In our case we&#8217;re using <a href="http://rest-assured.io/">Rest Assured MVC</a> to start the server side <code>FraudDetectionController</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.example.fraud;

import org.junit.Before;

import com.jayway.restassured.module.mockmvc.RestAssuredMockMvc;

public class FraudBase {
	@Before
	public void setup() {
		RestAssuredMockMvc.standaloneSetup(new FraudDetectionController(),
				new FraudStatsController(stubbedStatsProvider()));
	}

	private StatsProvider stubbedStatsProvider() {
		return fraudType -&gt; {
			switch (fraudType) {
			case DRUNKS:
				return 100;
			case ALL:
				return 200;
			}
			return 0;
		};
	}

	public void assertThatRejectionReasonIsNull(Object rejectionReason) {
		assert rejectionReason == null;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, if you run the <code>./mvnw clean install</code> you would get sth like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">Results :

Tests in error:
  ContractVerifierTest.validate_shouldMarkClientAsFraud:32 » IllegalState Parsed...</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s because you have a new contract from which a test was generated and it failed since you haven&#8217;t implemented the feature. The autogenerated test would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void validate_shouldMarkClientAsFraud() throws Exception {
    // given:
        MockMvcRequestSpecification request = given()
                .header("Content-Type", "application/vnd.fraud.v1+json")
                .body("{\"clientPesel\":\"1234567890\",\"loanAmount\":99999}");

    // when:
        ResponseOptions response = given().spec(request)
                .put("/fraudcheck");

    // then:
        assertThat(response.statusCode()).isEqualTo(200);
        assertThat(response.header("Content-Type")).matches("application/vnd.fraud.v1.json.*");
    // and:
        DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
        assertThatJson(parsedJson).field("fraudCheckStatus").matches("[A-Z]{5}");
        assertThatJson(parsedJson).field("rejectionReason").isEqualTo("Amount too high");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see all the <code>producer()</code> parts of the Contract that were present in the <code>value(consumer(&#8230;&#8203;), producer(&#8230;&#8203;))</code> blocks got injected into the test.</p>
</div>
<div class="paragraph">
<p>What&#8217;s important here to note is that on the producer side we also are doing TDD. We have expectations in form of a test. This test is shooting a request to our own application to an URL, headers and body defined in the contract. It also is expecting very precisely defined values in the response. In other words you have is your <code>red</code> part of <code>red</code>, <code>green</code> and <code>refactor</code>. Time to convert the <code>red</code> into the <code>green</code>.</p>
</div>
<div class="paragraph">
<p><strong>write the missing implementation</strong></p>
</div>
<div class="paragraph">
<p>Now since we now what is the expected input and expected output let&#8217;s write the missing implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RequestMapping(
		value = "/fraudcheck",
		method = PUT,
		consumes = FRAUD_SERVICE_JSON_VERSION_1,
		produces = FRAUD_SERVICE_JSON_VERSION_1)
public FraudCheckResult fraudCheck(@RequestBody FraudCheck fraudCheck) {
if (amountGreaterThanThreshold(fraudCheck)) {
	return new FraudCheckResult(FraudCheckStatus.FRAUD, AMOUNT_TOO_HIGH);
}
return new FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we execute <code>./mvnw clean install</code> again the tests will pass. Since the <code>Spring Cloud Contract Verifier</code> plugin adds the tests to the <code>generated-test-sources</code> you can actually run those tests from your IDE.</p>
</div>
<div class="paragraph">
<p><strong>deploy your app</strong></p>
</div>
<div class="paragraph">
<p>Once you&#8217;ve finished your work it&#8217;s time to deploy your change. First merge the branch</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">git checkout master
git merge --no-ff contract-change-pr
git push origin master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we assume that your CI would run sth like <code>./mvnw clean deploy</code> which would publish both the application and the stub artifcats.</p>
</div>
</div>
<div class="sect4">
<h5 id="_consumer_side_loan_issuance_final_step">Consumer side (Loan Issuance) final step</h5>
<div class="paragraph">
<p>As a developer of the Loan Issuance service (a consumer of the Fraud Detection server):</p>
</div>
<div class="paragraph">
<p><strong>merge branch to master</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">git checkout master
git merge --no-ff contract-change-pr</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>work online</strong></p>
</div>
<div class="paragraph">
<p>Now you can disable the offline work for Spring Cloud Contract Stub Runner ad provide where the repository with your stubs is placed. At this moment the stubs of the server side will be automatically downloaded from Nexus / Artifactory.
You can switch off the value of the <code>workOffline</code> parameter in your annotation. Below you can see an
example of achieving the same by changing the properties.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">stubrunner:
  ids: 'com.example:http-server-dsl:+:stubs:8080'
  repositoryRoot: https://repo.spring.io/libs-snapshot</code></pre>
</div>
</div>
<div class="paragraph">
<p>And that&#8217;s it!</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dependencies">Dependencies</h4>
<div class="paragraph">
<p>The best way to add the dependencies is to just use the proper <code>starter</code> dependency.</p>
</div>
<div class="paragraph">
<p>For <code>stub-runner</code> use <code>spring-cloud-starter-stub-runner</code> and when you&#8217;re using a plugin just add
<code>spring-cloud-starter-contract-verifier</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_additional_links">Additional links</h4>
<div class="paragraph">
<p>Below you can find some resources related to Spring Cloud Contract Verifier and Stub Runner. Note that some can be outdated since the Spring Cloud Contract Verifier project
is under constant development.</p>
</div>
<div class="sect4">
<h5 id="_readings">Readings</h5>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.slideshare.net/MarcinGrzejszczak/stick-to-the-rules-consumer-driven-contracts-201507-confitura">Slides from Marcin Grzejszczak&#8217;s talk about Accurest</a></p>
</li>
<li>
<p><a href="http://toomuchcoding.com/blog/categories/accurest/">Accurest related articles from Marcin Grzejszczak&#8217;s blog</a></p>
</li>
<li>
<p><a href="http://toomuchcoding.com/blog/categories/spring-cloud-contract/">Spring Cloud Contract related articles from Marcin Grzejszczak&#8217;s blog</a></p>
</li>
<li>
<p><a href="http://groovy-lang.org/json.html">Groovy docs regarding JSON</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_samples">Samples</h4>
<div class="paragraph">
<p>Here you can find some <a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples">samples</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_faq">FAQ</h3>
<div class="sect3">
<h4 id="_why_use_spring_cloud_contract_verifier_and_not_x">Why use Spring Cloud Contract Verifier and not X ?</h4>
<div class="paragraph">
<p>For the time being Spring Cloud Contract Verifier is a JVM based tool. So it could be your first pick when you&#8217;re already creating
software for the JVM. This project has a lot of really interesting features but especially quite a few of them definitely make
Spring Cloud Contract Verifier stand out on the "market" of Consumer Driven Contract (CDC) tooling. Out of many the most interesting are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Possibility to do CDC with messaging</p>
</li>
<li>
<p>Clear and easy to use, statically typed DSL</p>
</li>
<li>
<p>Possibility to copy paste your current JSON file to the contract and only edit its elements</p>
</li>
<li>
<p>Automatic generation of tests from the defined Contract</p>
</li>
<li>
<p>Stub Runner functionality - the stubs are automatically downloaded at runtime from Nexus / Artifactory</p>
</li>
<li>
<p>Spring Cloud integration - no discovery service is needed for integration tests</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_what_is_this_value_consumer_producer">What is this value(consumer(), producer()) ?</h4>
<div class="paragraph">
<p>One of the biggest challenges related to stubs is their reusability. Only if they can be vastly used, will they serve their purpose.
What typically makes that difficult are the hard-coded values of request / response elements. For example dates or ids.
Imagine the following JSON request</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "time" : "2016-10-10 20:10:15",
    "id" : "9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a",
    "body" : "foo"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and JSON response</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "time" : "2016-10-10 21:10:15",
    "id" : "c4231e1f-3ca9-48d3-b7e7-567d55f0d051",
    "body" : "bar"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Imagine the pain required to set proper value of the <code>time</code> field (let&#8217;s assume that this content is generated by the
database) by changing the clock in the system or providing stub implementations of data providers. The same is related
to the field called <code>id</code>. Will you create a stubbed implementation of UUID generator? Makes little sense&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>So as a consumer you would like to send a request that matches any form of a time or any UUID. That way your system
will work as usual - will generate data and you won&#8217;t have to stub anything out. Let&#8217;s assume that in case of the aforementioned
JSON the most important part is the <code>body</code> field. You can focus on that and provide matching for other fields. In other words
you would like the stub to work like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "time" : "SOMETHING THAT MATCHES TIME",
    "id" : "SOMETHING THAT MATCHES UUID",
    "body" : "foo"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As far as the response goes as a consumer you need a concrete value that you can operate on. So such a JSON is valid</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "time" : "2016-10-10 21:10:15",
    "id" : "c4231e1f-3ca9-48d3-b7e7-567d55f0d051",
    "body" : "bar"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you could see in the previous sections we generate tests from contracts. So from the producer&#8217;s side the situation looks
much different. We&#8217;re parsing the provided contract and in the test we want to send a real request to your endpoints.
So for the case of a producer for the request we can&#8217;t have any sort of matching. We need concrete values that the
producer&#8217;s backend can work on. Such a JSON would be a valid one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "time" : "2016-10-10 20:10:15",
    "id" : "9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a",
    "body" : "foo"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the other hand from the point of view of the validity of the contract the response doesn&#8217;t necessarily have to
contain concrete values of <code>time</code> or <code>id</code>. Let&#8217;s say that you generate those on the producer side - again, you&#8217;d
have to do a lot of stubbing to ensure that you always return the same values. That&#8217;s why from the producer&#8217;s side
what you might want is the following response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "time" : "SOMETHING THAT MATCHES TIME",
    "id" : "SOMETHING THAT MATCHES UUID",
    "body" : "bar"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>How can you then provide one time a matcher for the consumer and a concrete value for the producer and vice versa?
In Spring Cloud Contract we&#8217;re allowing you to provide a <strong>dynamic value</strong>. That means that it can differ for both
sides of the communication. You can pass the values:</p>
</div>
<div class="paragraph">
<p>Either via the <code>value</code> method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">value(consumer(...), producer(...))
value(stub(...), test(...))
value(client(...), server(...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>or using the <code>$()</code> method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">$(consumer(...), producer(...))
$(stub(...), test(...))
$(client(...), server(...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can read more about this in the <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_contract_dsl">Contract DSL section</a>.</p>
</div>
<div class="paragraph">
<p>Calling <code>value()</code> or <code>$()</code> tells Spring Cloud Contract that you will be passing a dynamic value.
Inside the <code>consumer()</code> method you pass the value that should be used on the consumer side (in the generated stub).
Inside the <code>producer()</code> method you pass the value that should be used on the producer side (in the generated test).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
If on one side you have passed the regular expression and you haven&#8217;t passed the other, then the
other side will get auto-generated.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Most often you will use that method together with the <code>regex</code> helper method. E.g. <code>consumer(regex('[0-9]{10}'))</code>.</p>
</div>
<div class="paragraph">
<p>To sum it up the contract for the aforementioned scenario would look more or less like this (the regular expression
for time and UUID are simplified and most likely invalid but we want to keep things very simple in this example):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
				request {
					method 'GET'
					url '/someUrl'
					body([
					    time : value(consumer(regex('[0-9]{4}-[0-9]{2}-[0-9]{2} [0-2][0-9]-[0-5][0-9]-[0-5][0-9]')),
					    id: value(consumer(regex('[0-9a-zA-z]{8}-[0-9a-zA-z]{4}-[0-9a-zA-z]{4}-[0-9a-zA-z]{12}'))
					    body: "foo"
					])
				}
			response {
				status 200
				body([
					    time : value(producer(regex('[0-9]{4}-[0-9]{2}-[0-9]{2} [0-2][0-9]-[0-5][0-9]-[0-5][0-9]')),
					    id: value([producer(regex('[0-9a-zA-z]{8}-[0-9a-zA-z]{4}-[0-9a-zA-z]{4}-[0-9a-zA-z]{12}'))
					    body: "bar"
					])
			}
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Please read the <a href="http://groovy-lang.org/json.html">Groovy docs related to JSON</a> to understand how to
properly structure the request / response bodies.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_how_to_do_stubs_versioning">How to do Stubs versioning?</h4>
<div class="sect4">
<h5 id="_api_versioning">API Versioning</h5>
<div class="paragraph">
<p>Let&#8217;s try to answer a question what versioning really means. If you&#8217;re referring to the API version then there are
different approaches.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>use Hypermedia, links and do not version your API by any means</p>
</li>
<li>
<p>pass versions through headers / urls</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I will not try to answer a question which approach is better. Whatever suit your needs and allows you to generate
business value should be picked.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that you do version your API. In that case you should provide as many contracts as many versions you support.
You can create a subfolder for every version or append it to th contract name - whatever suits you more.</p>
</div>
</div>
<div class="sect4">
<h5 id="_jar_versioning">JAR versioning</h5>
<div class="paragraph">
<p>If by versioning you mean the version of the JAR that contains the stubs then there are essentially two main approaches.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that you&#8217;re doing Continuous Delivery / Deployment which means that you&#8217;re generating a new version of
the jar each time you go through the pipeline and that jar can go to production at any time. For example your jar version
looks like this (it got built on the 20.10.2016 at 20:15:21) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">1.0.0.20161020-201521-RELEASE</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case your generated stub jar will look like this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">1.0.0.20161020-201521-RELEASE-stubs.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case you should inside your <code>application.yml</code> or <code>@AutoConfigureStubRunner</code> when referencing stubs provide the
 latest version of the stubs. You can do that by passing the <code>+</code> sign. Example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:8080"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the versioning however is fixed (e.g. <code>1.0.4.RELEASE</code> or <code>2.1.1</code>) then you have to set the concrete value of the jar
version. Example for 2.1.1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:2.1.1:stubs:8080"})</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_dev_or_prod_stubs">Dev or prod stubs</h5>
<div class="paragraph">
<p>You can manipulate the classifier to run the tests against current development version of the stubs of other services
 or the ones that were deployed to production. If you alter your build to deploy the stubs with the <code>prod-stubs</code> classifier
 once you reach production deployment then you can run tests in one case with dev stubs and one with prod stubs.</p>
</div>
<div class="paragraph">
<p>Example of tests using development version of stubs</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:8080"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example of tests using production version of stubs</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:prod-stubs:8080"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can pass those values also via properties from your deployment pipeline.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_common_repo_with_contracts">Common repo with contracts</h4>
<div class="paragraph">
<p>Another way of storing contracts other than having them with the producer is keeping them in a common place.
It can be related to security issues where the consumers can&#8217;t clone the producer&#8217;s code. Also if you keep
contracts in a single place then you, as a producer, will know how many consumers you have and which
consumer will you break with your local changes.</p>
</div>
<div class="sect4">
<h5 id="_repo_structure">Repo structure</h5>
<div class="paragraph">
<p>Let&#8217;s assume that we have a producer with coordinates <code>com.example:server</code> and 3 consumers: <code>client1</code>,
<code>client2</code>, <code>client3</code>. Then in the repository with common contracts you would have the following setup
(which you can checkout <a href="https://github.com/spring-cloud/spring-cloud-contract/tree/1.0.x/samples/standalone/contracts">here</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">├── com
│   └── example
│       └── server
│           ├── client1
│           │   └── expectation.groovy
│           ├── client2
│           │   └── expectation.groovy
│           ├── client3
│           │   └── expectation.groovy
│           └── pom.xml
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    └── assembly
        └── contracts.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see the under the slash-delimited groupid <code>/</code> artifact id folder (<code>com/example/server</code>) you have
expectations of the 3 consumers (<code>client1</code>, <code>client2</code> and <code>client3</code>). Expectations are the standard Groovy DSL
contract files as described throughout this documentation. This repository has to produce a JAR file that maps
one to one to the contents of the repo.</p>
</div>
<div class="paragraph">
<p>Example of a <code>pom.xml</code> inside the <code>server</code> folder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

	&lt;groupId&gt;com.example&lt;/groupId&gt;
	&lt;artifactId&gt;server&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

	&lt;name&gt;Server Stubs&lt;/name&gt;
	&lt;description&gt;POM used to install locally stubs for consumer side&lt;/description&gt;

	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;1.5.0.BUILD-SNAPSHOT&lt;/version&gt;
		&lt;relativePath /&gt;
	&lt;/parent&gt;

	&lt;properties&gt;
		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
		&lt;spring-cloud-contract.version&gt;1.1.0.BUILD-SNAPSHOT&lt;/spring-cloud-contract.version&gt;
		&lt;spring-cloud-dependencies.version&gt;Dalston.BUILD-SNAPSHOT&lt;/spring-cloud-dependencies.version&gt;
		&lt;excludeBuildFolders&gt;true&lt;/excludeBuildFolders&gt;
	&lt;/properties&gt;

	&lt;dependencyManagement&gt;
		&lt;dependencies&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
				&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
				&lt;type&gt;pom&lt;/type&gt;
				&lt;scope&gt;import&lt;/scope&gt;
			&lt;/dependency&gt;
		&lt;/dependencies&gt;
	&lt;/dependencyManagement&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
				&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
				&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
				&lt;extensions&gt;true&lt;/extensions&gt;
				&lt;configuration&gt;
					&lt;!-- By default it would search under src/test/resources/ --&gt;
					&lt;contractsDirectory&gt;${project.basedir}&lt;/contractsDirectory&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

	&lt;repositories&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-releases&lt;/id&gt;
			&lt;name&gt;Spring Releases&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
	&lt;/repositories&gt;
	&lt;pluginRepositories&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-releases&lt;/id&gt;
			&lt;name&gt;Spring Releases&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
	&lt;/pluginRepositories&gt;

&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see there are no dependencies other than the Spring Cloud Contract Maven Plugin.
Those poms are necessary for the consumer side to run <code>mvn clean install -DskipTests</code> to locally install
 stubs of the producer project.</p>
</div>
<div class="paragraph">
<p>The <code>pom.xml</code> in the root folder can look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

	&lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
	&lt;artifactId&gt;contracts&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

	&lt;name&gt;Contracts&lt;/name&gt;
	&lt;description&gt;Contains all the Spring Cloud Contracts, well, contracts. JAR used by the producers to generate tests and stubs&lt;/description&gt;

	&lt;properties&gt;
		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
	&lt;/properties&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
				&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
				&lt;executions&gt;
					&lt;execution&gt;
						&lt;id&gt;contracts&lt;/id&gt;
						&lt;phase&gt;prepare-package&lt;/phase&gt;
						&lt;goals&gt;
							&lt;goal&gt;single&lt;/goal&gt;
						&lt;/goals&gt;
						&lt;configuration&gt;
							&lt;attach&gt;true&lt;/attach&gt;
							&lt;descriptor&gt;${basedir}/src/assembly/contracts.xml&lt;/descriptor&gt;
							&lt;!-- If you want an explicit classifier remove the following line --&gt;
							&lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;
						&lt;/configuration&gt;
					&lt;/execution&gt;
				&lt;/executions&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s using the assembly plugin in order to build the JAR with all the contracts. Example of such setup is here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
		  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		  xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd"&gt;
	&lt;id&gt;project&lt;/id&gt;
	&lt;formats&gt;
		&lt;format&gt;jar&lt;/format&gt;
	&lt;/formats&gt;
	&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
	&lt;fileSets&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${project.basedir}&lt;/directory&gt;
			&lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
			&lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
			&lt;excludes&gt;
				&lt;exclude&gt;**/${project.build.directory}/**&lt;/exclude&gt;
				&lt;exclude&gt;mvnw&lt;/exclude&gt;
				&lt;exclude&gt;mvnw.cmd&lt;/exclude&gt;
				&lt;exclude&gt;.mvn/**&lt;/exclude&gt;
				&lt;exclude&gt;src/**&lt;/exclude&gt;
			&lt;/excludes&gt;
		&lt;/fileSet&gt;
	&lt;/fileSets&gt;
&lt;/assembly&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_workflow">Workflow</h5>
<div class="paragraph">
<p>The workflow would look similar to the one presented in the <code>Step by step guide to CDC</code>. The only difference
 is that the producer doesn&#8217;t own the contracts anymore. So the consumer and the producer have to work on
 common contracts in a common repository.</p>
</div>
<div class="sect5">
<h6 id="_consumer">Consumer</h6>
<div class="paragraph">
<p>When the <strong>consumer</strong> wants to work on the contracts offline, instead of cloning the producer code, the
consumer team clones the common repository, goes to the required producer&#8217;s folder (e.g. <code>com/example/server</code>)
and runs <code>mvn clean install -DskipTests</code> to install locally the stubs converted from the contracts.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
You need to have <a href="https://maven.apache.org/download.cgi">Maven installed locally</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_producer">Producer</h6>
<div class="paragraph">
<p>As a <strong>producer</strong> it&#8217;s enough to alter the Spring Cloud Contract Verifier to provide the URL and the dependency
of the JAR containing the contracts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;configuration&gt;
		&lt;contractsRepositoryUrl&gt;http://link/to/your/nexus/or/artifactory/or/sth&lt;/contractsRepositoryUrl&gt;
		&lt;contractDependency&gt;
			&lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
			&lt;artifactId&gt;contracts&lt;/artifactId&gt;
		&lt;/contractDependency&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this setup the JAR with groupid <code>com.example.standalone</code> and artifactid <code>contracts</code> will be downloaded
from <code><a href="http://link/to/your/nexus/or/artifactory/or/sth" class="bare">http://link/to/your/nexus/or/artifactory/or/sth</a></code>. It will be then unpacked in a local temporary folder
and contracts present under the <code>com/example/server</code> will be picked as the ones used to generate the
tests and the stubs. Due to this convention the producer team will know which consumer teams will be broken
when some incompatible changes are done.</p>
</div>
<div class="paragraph">
<p>The rest of the flow looks the same.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_can_i_have_multiple_base_classes_for_tests">Can I have multiple base classes for tests?</h4>
<div class="paragraph">
<p>Yes! Check out the <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_different_base_classes_for_contracts">Different base classes for contracts</a> sections
of either Gradle or Maven plugins.</p>
</div>
</div>
<div class="sect3">
<h4 id="_can_i_reference_the_request_from_the_response">Can I reference the request from the response?</h4>
<div class="paragraph">
<p>Yes! With version 1.1.0 we&#8217;ve added such a possibility. On the HTTP stub server side we&#8217;re providing support
for this for WireMock. In case of other HTTP server stubs you&#8217;ll have to implement the approach yourself.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring_cloud_contract_verifier_http">Spring Cloud Contract Verifier HTTP</h3>
<div class="sect3">
<h4 id="_gradle_project">Gradle Project</h4>
<div class="sect4">
<h5 id="_prerequisites">Prerequisites</h5>
<div class="paragraph">
<p>In order to use Spring Cloud Contract Verifier with WireMock you have to use Gradle or Maven plugin.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
If you want to use Spock in your projects you have to add separately
the <code>spock-core</code> and <code>spock-spring</code> modules. Check <a href="https://spockframework.github.io/">Spock docs for more information</a>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_add_gradle_plugin_with_dependencies">Add gradle plugin with dependencies</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
	    classpath "org.springframework.boot:spring-boot-gradle-plugin:${springboot_version}"
		classpath "org.springframework.cloud:spring-cloud-contract-gradle-plugin:${verifier_version}"
	}
}

apply plugin: 'groovy'
apply plugin: 'spring-cloud-contract'

dependencyManagement {
	imports {
		mavenBom "org.springframework.cloud:spring-cloud-contract-dependencies:${verifier_version}"
	}
}

dependencies {
	testCompile 'org.codehaus.groovy:groovy-all:2.4.6'
	// example with adding Spock core and Spock Spring
	testCompile 'org.spockframework:spock-core:1.0-groovy-2.4'
	testCompile 'org.spockframework:spock-spring:1.0-groovy-2.4'
	testCompile 'org.springframework.cloud:spring-cloud-starter-contract-verifier'
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_snapshot_versions_for_gradle">Snapshot versions for Gradle</h6>
<div class="paragraph">
<p>Add the additional snapshot repository to your build.gradle to use snapshot versions which are automatically uploaded after every successful build:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">buildscript {
	repositories {
		mavenCentral()
		mavenLocal()
		maven { url "https://repo.spring.io/snapshot" }
		maven { url "https://repo.spring.io/milestone" }
		maven { url "https://repo.spring.io/release" }
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_add_stubs">Add stubs</h6>
<div class="paragraph">
<p>By default Spring Cloud Contract Verifier is looking for stubs in <code>src/test/resources/contracts</code> directory.</p>
</div>
<div class="paragraph">
<p>Directory containing stub definitions is treated as a class name, and each stub definition is treated as a single test.
We assume that it contains at least one directory which will be used as test class name. If there is more than one level of nested directories all except the last one will be used as package name.
So with following structure</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">src/test/resources/contracts/myservice/shouldCreateUser.groovy
src/test/resources/contracts/myservice/shouldReturnUser.groovy</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Contract Verifier will create test class <code>defaultBasePackage.MyService</code> with two methods</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>shouldCreateUser()</code></p>
</li>
<li>
<p><code>shouldReturnUser()</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_run_plugin">Run plugin</h5>
<div class="paragraph">
<p>Plugin registers itself to be invoked before <code>check</code> task. You have nothing to do as long as you want it to be part of your build process. If you just want to generate tests please invoke <code>generateContractTests</code> task.</p>
</div>
</div>
<div class="sect4">
<h5 id="_default_setup">Default setup</h5>
<div class="paragraph">
<p>Default Gradle Plugin setup creates the following Gradle part of the build (it&#8217;s a pseudocode)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">contracts {
    targetFramework = 'JUNIT'
    testMode = 'MockMvc'
    generatedTestSourcesDir = project.file("${project.buildDir}/generated-test-sources/contracts")
    contractsDslDir = "${project.rootDir}/src/test/resources/contracts"
    basePackageForTests = 'org.springframework.cloud.verifier.tests'
    stubsOutputDir = project.file("${project.buildDir}/stubs")

    // the following properties are used when you want to provide where the JAR with contract lays
    contractDependency {
        stringNotation = ''
    }
    contractsPath = ''
    contractsWorkOffline = false
}

tasks.create(type: Jar, name: 'verifierStubsJar', dependsOn: 'generateClientStubs') {
    baseName = project.name
    classifier = contracts.stubsSuffix
    from contractVerifier.stubsOutputDir
}

project.artifacts {
    archives task
}

tasks.create(type: Copy, name: 'copyContracts') {
    from contracts.contractsDslDir
    into contracts.stubsOutputDir
}

verifierStubsJar.dependsOn 'copyContracts'

publishing {
    publications {
        stubs(MavenPublication) {
            artifactId project.name
            artifact verifierStubsJar
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_configure_plugin">Configure plugin</h5>
<div class="paragraph">
<p>To change default configuration just add <code>contracts</code> snippet to your Gradle config</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">contracts {
	testMode = 'MockMvc'
	baseClassForTests = 'org.mycompany.tests'
	generatedTestSourcesDir = project.file('src/generatedContract')
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_configuration_options">Configuration options</h6>
<div class="ulist">
<ul>
<li>
<p><strong>testMode</strong> - defines mode for acceptance tests. By default MockMvc which is based on Spring&#8217;s MockMvc. It can also be changed to <strong>JaxRsClient</strong> or to <strong>Explicit</strong> for real HTTP calls.</p>
</li>
<li>
<p><strong>imports</strong> - array with imports that should be included in generated tests (for example ['org.myorg.Matchers']). By default empty array []</p>
</li>
<li>
<p><strong>staticImports</strong> - array with static imports that should be included in generated tests(for example ['org.myorg.Matchers.*']). By default empty array []</p>
</li>
<li>
<p><strong>basePackageForTests</strong> - specifies base package for all generated tests. By default set to org.springframework.cloud.verifier.tests</p>
</li>
<li>
<p><strong>baseClassForTests</strong> - base class for all generated tests. By default <code>spock.lang.Specification</code> if using Spock tests.</p>
</li>
<li>
<p><strong>packageWithBaseClasses</strong> - instead of providing a fixed value for base class you can provide a package where all the base classes lay. Takes precedence over <strong>baseClassForTests</strong>.</p>
</li>
<li>
<p><strong>baseClassMappings</strong> - explicitly map contract package to a FQN of a base class. Takes precedence over <strong>packageWithBaseClasses</strong> and <strong>baseClassForTests</strong>.</p>
</li>
<li>
<p><strong>ruleClassForTests</strong> - specifies Rule which should be added to generated test classes.</p>
</li>
<li>
<p><strong>ignoredFiles</strong> - Ant matcher allowing defining stub files for which processing should be skipped. By default empty array []</p>
</li>
<li>
<p><strong>contractsDslDir</strong> - directory containing contracts written using the GroovyDSL. By default <code>$rootDir/src/test/resources/contracts</code></p>
</li>
<li>
<p><strong>generatedTestSourcesDir</strong> - test source directory where tests generated from Groovy DSL should be placed. By default <code>$buildDir/generated-test-sources/contractVerifier</code></p>
</li>
<li>
<p><strong>stubsOutputDir</strong> - dir where the generated WireMock stubs from Groovy DSL should be placed</p>
</li>
<li>
<p><strong>targetFramework</strong> - the target test framework to be used; currently Spock and JUnit are supported with JUnit being the default framework</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following properties are used when you want to provide where the JAR with contract lays</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>contractDependency</strong> - the Dependency that provides <code>groupid:artifactid:version:classifier</code> coordinates. You can use the <code>contractDependency</code> closure to set it up</p>
</li>
<li>
<p><strong>contractsPath</strong> - if contract deps are downloaded will default to <code>groupid/artifactid</code> where <code>groupid</code> will be slash separated. Otherwise will scan contracts under provided directory</p>
</li>
<li>
<p><strong>contractsWorkOffline</strong> - in order not to download the dependencies each time you can download them once and work offline afterwards (reuse local Maven repo)</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_single_base_class_for_all_tests">Single base class for all tests</h6>
<div class="paragraph">
<p>When using Spring Cloud Contract Verifier in default MockMvc you need to create a base specification for all generated acceptance tests. In this class you need to point to endpoint which should be verified.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">abstract class BaseMockMvcSpec extends Specification {

	def setup() {
		RestAssuredMockMvc.standaloneSetup(new PairIdController())
	}

	void isProperCorrelationId(Integer correlationId) {
		assert correlationId == 123456
	}

	void isEmpty(String value) {
		assert value == null
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In case of using <code>Explicit</code> mode, you can use base class to initialize the whole tested app similarly as in regular integration tests. In case of <code>JAXRSCLIENT</code> mode this base class
should also contain <code>protected WebTarget webTarget</code> field, right now the only option to test JAX-RS API is to start a web server.</p>
</div>
</div>
<div class="sect5">
<h6 id="_different_base_classes_for_contracts">Different base classes for contracts</h6>
<div class="paragraph">
<p>If your base classes differ between contracts you can tell the Spring Cloud Contract plugin which class should get
extended by the autogenerated tests. You have two options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>follow a convention by providing the <code>packageWithBaseClasses</code></p>
</li>
<li>
<p>provide explicit mapping via <code>baseClassMappings</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Convention</strong></p>
</div>
<div class="paragraph">
<p>The convention is such that if you have a contract under e.g. <code>src/test/resources/contract/foo/bar/baz/</code> and provide the value of the <code>packageWithBaseClasses</code> property
to <code>com.example.base</code> then we will assume that there is a <code>BarBazBase</code> class under <code>com.example.base</code> package. In other words we take last two parts of package
if they exist and form a class with a <code>Base</code> suffix. Takes precedence over <strong>baseClassForTests</strong>. Example of usage in the <code>contracts</code> closure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">packageWithBaseClasses = 'com.example.base'</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Mapping</strong></p>
</div>
<div class="paragraph">
<p>You can manually map a regular expression of the contract&#8217;s package to fully qualified name of the base class for the matched contract.
Let&#8217;s take a look at the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">baseClassForTests = "com.example.FooBase"
baseClassMappings {
	baseClassMapping('.*/com/.*', 'com.example.ComBase')
	baseClassMapping('.*/bar/.*':'com.example.BarBase')
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that you have contracts under
 - <code>src/test/resources/contract/com/</code>
 - <code>src/test/resources/contract/foo/</code></p>
</div>
<div class="paragraph">
<p>By providing the <code>baseClassForTests</code> we have a fallback in case mapping didn&#8217;t succeed (you could also provide
the <code>packageWithBaseClasses</code> as fallback). That way the tests generated from <code>src/test/resources/contract/com/</code> contracts
will be extending the <code>com.example.ComBase</code> whereas the rest of tests will extend <code>com.example.FooBase</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_invoking_generated_tests">Invoking generated tests</h5>
<div class="paragraph">
<p>To ensure that provider side is complaint with defined contracts, you need to invoke:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">./gradlew generateContractTests test</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_spring_cloud_contract_verifier_on_consumer_side">Spring Cloud Contract Verifier on consumer side</h5>
<div class="paragraph">
<p>In consumer service you need to configure Spring Cloud Contract Verifier plugin in exactly the same way as in case of provider. If you don&#8217;t want to use Stub Runner then you need to copy contracts stored in
<code>src/test/resources/contracts</code> and generate WireMock json stubs using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">./gradlew generateClientStubs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>stubsOutputDir</code> option has to be set for stub generation to work.</p>
</div>
<div class="paragraph">
<p>When present, json stubs can be used in consumer automated tests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@ContextConfiguration(loader == SpringApplicationContextLoader, classes == Application)
class LoanApplicationServiceSpec extends Specification {

 @ClassRule
 @Shared
 WireMockClassRule wireMockRule == new WireMockClassRule()

 @Autowired
 LoanApplicationService sut

 def 'should successfully apply for loan'() {
   given:
 	LoanApplication application =
			new LoanApplication(client: new Client(clientPesel: '12345678901'), amount: 123.123)
   when:
	LoanApplicationResult loanApplication == sut.loanApplication(application)
   then:
	loanApplication.loanApplicationStatus == LoanApplicationStatus.LOAN_APPLIED
	loanApplication.rejectionReason == null
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Underneath LoanApplication makes a call to FraudDetection service. This request is handled by WireMock server configured using stubs generated by Spring Cloud Contract Verifier.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_in_your_maven_project">Using in your Maven project</h4>
<div class="sect4">
<h5 id="_add_maven_plugin">Add maven plugin</h5>
<div class="paragraph">
<p>Add the Spring Cloud Contract BOM</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, the <code>Spring Cloud Contract Verifier</code> Maven plugin</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can read more in the <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/">Spring Cloud Contract Maven Plugin Docs</a></p>
</div>
<div class="sect5">
<h6 id="_snapshot_versions_for_maven">Snapshot versions for Maven</h6>
<div class="paragraph">
<p>For Snapshot / Milestone versions you have to add the following section to your <code>pom.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_add_stubs_2">Add stubs</h5>
<div class="paragraph">
<p>By default Spring Cloud Contract Verifier is looking for stubs in <code>src/test/resources/contracts</code> directory.
Directory containing stub definitions is treated as a class name, and each stub definition is treated as a single test.
We assume that it contains at least one directory which will be used as test class name. If there is more than one level of nested directories all except the last one will be used as package name.
So with following structure</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">src/test/resources/contracts/myservice/shouldCreateUser.groovy
src/test/resources/contracts/myservice/shouldReturnUser.groovy</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Contract Verifier will create test class <code>defaultBasePackage.MyService</code> with two methods
 - <code>shouldCreateUser()</code>
 - <code>shouldReturnUser()</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_run_plugin_2">Run plugin</h5>
<div class="paragraph">
<p>Plugin goal <code>generateTests</code> is assigned to be invoked in phase <code>generate-test-sources</code>. You have nothing to do as long as you want it to be part of your build process. If you just want to generate tests please invoke <code>generateTests</code> goal.</p>
</div>
</div>
<div class="sect4">
<h5 id="_configure_plugin_2">Configure plugin</h5>
<div class="paragraph">
<p>To change default configuration just add <code>configuration</code> section to plugin definition or <code>execution</code> definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;convert&lt;/goal&gt;
                &lt;goal&gt;generateStubs&lt;/goal&gt;
                &lt;goal&gt;generateTests&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;basePackageForTests&gt;org.springframework.cloud.verifier.twitter.place&lt;/basePackageForTests&gt;
        &lt;baseClassForTests&gt;org.springframework.cloud.verifier.twitter.place.BaseMockMvcSpec&lt;/baseClassForTests&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_important_configuration_options">Important configuration options</h6>
<div class="ulist">
<ul>
<li>
<p><strong>testMode</strong> - defines mode for acceptance tests. By default <code>MockMvc</code> which is based on Spring&#8217;s MockMvc. It can also be changed to <code>JaxRsClient</code> or to <code>Explicit</code> for real HTTP calls.</p>
</li>
<li>
<p><strong>basePackageForTests</strong> - specifies base package for all generated tests. By default set to <code>org.springframework.cloud.verifier.tests</code>.</p>
</li>
<li>
<p><strong>ruleClassForTests</strong> - specifies Rule which should be added to generated test classes.</p>
</li>
<li>
<p><strong>baseClassForTests</strong> - base class for generated tests. By default <code>spock.lang.Specification</code> if using Spock tests.</p>
</li>
<li>
<p><strong>contractsDir</strong> - directory containing contracts written using the GroovyDSL. By default <code>/src/test/resources/contracts</code>.</p>
</li>
<li>
<p><strong>testFramework</strong> - the target test framework to be used; currently Spock and JUnit are supported with JUnit being the default framework</p>
</li>
<li>
<p><strong>packageWithBaseClasses</strong> - instead of providing a fixed value for base class you can provide a package where all the base classes lay.
The convention is such that if you have a contract under <code>src/test/resources/contract/foo/bar/baz/</code> and provide the value of this property
to <code>com.example.base</code> then we will assume that there is a <code>BarBazBase</code> class under <code>com.example.base</code> package. Takes precedence
over <strong>baseClassForTests</strong></p>
</li>
<li>
<p><strong>baseClassMappings</strong> - list of base class mappings that where you have to provide <code>contractPackageRegex</code> which is checked
against the package in which the contract lays and <code>baseClassFQN</code> that maps to fully qualified name of the base class for the matched
contract. If you have a contract under <code>src/test/resources/contract/foo/bar/baz/</code> and map the property <code>.*</code> &#8594; <code>com.example.base.BaseClass</code> then
the test class generated from these contracts will extend <code>com.example.base.BaseClass</code>. Takes precedence over <strong>packageWithBaseClasses</strong>
 and <strong>baseClassForTests</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want to download your contract definitions from a Maven repository you can use</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>contractsRepositoryUrl</strong> - URL to a repo with the artifacts with contracts, if not provided should use the current Maven ones</p>
</li>
<li>
<p><strong>contractDependency</strong> - the contract dependency that contains all the packaged contracts</p>
</li>
<li>
<p><strong>contractsPath</strong> - path to concrete contracts in the JAR with packaged contracts. Defaults to <code>groupid/artifactid</code> where <code>gropuid</code> is slash separated.</p>
</li>
<li>
<p><strong>contractsWorkOffline</strong> - if the dependencies should be downloaded or local Maven only should be reused</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For complete information take a look at <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/plugin-info.html">Plugin Documentation</a></p>
</div>
</div>
<div class="sect5">
<h6 id="_single_base_class_for_all_tests_2">Single base class for all tests</h6>
<div class="paragraph">
<p>When using Spring Cloud Contract Verifier in default MockMvc you need to create a base specification for all generated acceptance tests.
In this class you need to point to endpoint which should be verified.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package org.mycompany.tests

import org.mycompany.ExampleSpringController
import com.jayway.restassured.module.mockmvc.RestAssuredMockMvc
import spock.lang.Specification

class  MvcSpec extends Specification {
  def setup() {
   RestAssuredMockMvc.standaloneSetup(new ExampleSpringController())
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In case of using <code>Explicit</code> mode, you can use base class to initialize the whole tested app similarly as in regular integration tests. In case of <code>JAXRSCLIENT</code> mode this base class should also contain <code>protected WebTarget webTarget</code> field, right now the only option to test JAX-RS API is to start a web server.</p>
</div>
</div>
<div class="sect5">
<h6 id="_different_base_classes_for_contracts_2">Different base classes for contracts</h6>
<div class="paragraph">
<p>If your base classes differ between contracts you can tell the Spring Cloud Contract plugin which class should get
extended by the autogenerated tests. You have two options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>follow a convention by providing the <code>packageWithBaseClasses</code></p>
</li>
<li>
<p>provide explicit mapping via <code>baseClassMappings</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Convention</strong></p>
</div>
<div class="paragraph">
<p>The convention is such that if you have a contract under e.g. <code>src/test/resources/contract/hello/v1/</code> and provide the value of the <code>packageWithBaseClasses</code> property
to <code>hello</code> then we will assume that there is a <code>HelloV1Base</code> class under <code>hello</code> package. In other words we take last two parts of package
if they exist and form a class with a <code>Base</code> suffix. Takes precedence over <strong>baseClassForTests</strong>. Example of usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;hello&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Mapping</strong></p>
</div>
<div class="paragraph">
<p>You can manually map a regular expression of the contract&#8217;s package to fully qualified name of the base class for the matched contract.
You have to provide a list <code>baseClassMappings</code> of <code>baseClassMapping</code> that takes a <code>contractPackageRegex</code> to <code>baseClassFQN</code> mapping.
Let&#8217;s take a look at the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;configuration&gt;
		&lt;baseClassForTests&gt;com.example.FooBase&lt;/baseClassForTests&gt;
		&lt;baseClassMappings&gt;
			&lt;baseClassMapping&gt;
				&lt;contractPackageRegex&gt;.*com.*&lt;/contractPackageRegex&gt;
				&lt;baseClassFQN&gt;com.example.TestBase&lt;/baseClassFQN&gt;
			&lt;/baseClassMapping&gt;
		&lt;/baseClassMappings&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that you have contracts under
 - <code>src/test/resources/contract/com/</code>
 - <code>src/test/resources/contract/foo/</code></p>
</div>
<div class="paragraph">
<p>By providing the <code>baseClassForTests</code> we have a fallback in case mapping didn&#8217;t succeed (you could also provide
the <code>packageWithBaseClasses</code> as fallback). That way the tests generated from <code>src/test/resources/contract/com/</code> contracts
will be extending the <code>com.example.ComBase</code> whereas the rest of tests will extend <code>com.example.FooBase</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_invoking_generated_tests_2">Invoking generated tests</h5>
<div class="paragraph">
<p>Spring Cloud Contract Maven Plugin generates verification code into directory <code>/generated-test-sources/contractVerifier</code> and attach this directory to <code>testCompile</code> goal.</p>
</div>
<div class="paragraph">
<p>For Groovy Spock code use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.codehaus.gmavenplus&lt;/groupId&gt;
	&lt;artifactId&gt;gmavenplus-plugin&lt;/artifactId&gt;
	&lt;version&gt;1.5&lt;/version&gt;
	&lt;executions&gt;
		&lt;execution&gt;
			&lt;goals&gt;
				&lt;goal&gt;testCompile&lt;/goal&gt;
			&lt;/goals&gt;
		&lt;/execution&gt;
	&lt;/executions&gt;
	&lt;configuration&gt;
		&lt;testSources&gt;
			&lt;testSource&gt;
				&lt;directory&gt;${project.basedir}/src/test/groovy&lt;/directory&gt;
				&lt;includes&gt;
					&lt;include&gt;**/*.groovy&lt;/include&gt;
				&lt;/includes&gt;
			&lt;/testSource&gt;
			&lt;testSource&gt;
				&lt;directory&gt;${project.build.directory}/generated-test-sources/contractVerifier&lt;/directory&gt;
				&lt;includes&gt;
					&lt;include&gt;**/*.groovy&lt;/include&gt;
				&lt;/includes&gt;
			&lt;/testSource&gt;
		&lt;/testSources&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To ensure that provider side is complaint with defined contracts, you need to invoke <code>mvn generateTest test</code></p>
</div>
</div>
<div class="sect4">
<h5 id="_faq_with_maven_plugin">FAQ with Maven Plugin</h5>
<div class="sect5">
<h6 id="_maven_plugin_and_sts">Maven Plugin and STS</h6>
<div class="paragraph">
<p>In case you see the following exception while using STS</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-contract/1.0.x/docs/src/main/asciidoc/images/sts_exception.png" alt="STS Exception">
</div>
</div>
<div class="paragraph">
<p>when you click on the marker you should see sth like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"> plugin:1.1.0.M1:convert:default-convert:process-test-resources) org.apache.maven.plugin.PluginExecutionException: Execution default-convert of goal org.springframework.cloud:spring-
 cloud-contract-maven-plugin:1.1.0.M1:convert failed. at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:145) at
 org.eclipse.m2e.core.internal.embedder.MavenImpl.execute(MavenImpl.java:331) at org.eclipse.m2e.core.internal.embedder.MavenImpl$11.call(MavenImpl.java:1362) at
...
 org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) Caused by: java.lang.NullPointerException at
 org.eclipse.m2e.core.internal.builder.plexusbuildapi.EclipseIncrementalBuildContext.hasDelta(EclipseIncrementalBuildContext.java:53) at
 org.sonatype.plexus.build.incremental.ThreadBuildContext.hasDelta(ThreadBuildContext.java:59) at</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to fix this issue just provide the following section in your <code>pom.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;build&gt;
    &lt;pluginManagement&gt;
        &lt;plugins&gt;
            &lt;!--This plugin's configuration is used to store Eclipse m2e settings
                only. It has no influence on the Maven build itself. --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.eclipse.m2e&lt;/groupId&gt;
                &lt;artifactId&gt;lifecycle-mapping&lt;/artifactId&gt;
                &lt;version&gt;1.0.0&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;lifecycleMappingMetadata&gt;
                        &lt;pluginExecutions&gt;
                             &lt;pluginExecution&gt;
                                &lt;pluginExecutionFilter&gt;
                                    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                                    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
                                    &lt;versionRange&gt;[1.0,)&lt;/versionRange&gt;
                                    &lt;goals&gt;
                                        &lt;goal&gt;convert&lt;/goal&gt;
                                    &lt;/goals&gt;
                                &lt;/pluginExecutionFilter&gt;
                                &lt;action&gt;
                                    &lt;execute /&gt;
                                &lt;/action&gt;
                             &lt;/pluginExecution&gt;
                        &lt;/pluginExecutions&gt;
                    &lt;/lifecycleMappingMetadata&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_spring_cloud_contract_verifier_on_consumer_side_2">Spring Cloud Contract Verifier on consumer side</h5>
<div class="paragraph">
<p>You can actually use the Spring Cloud Contract Verifier also for the consumer side!
You can use the plugin so that it only converts the contracts and generates the stubs.
To achieve that you need to configure Spring Cloud Contract Verifier plugin in exactly
the same way as in case of provider. You need to copy contracts stored in
<code>src/test/resources/contracts</code> and generate WireMock json stubs using:
<code>mvn generateStubs</code> command. By default generated WireMock mapping is
stored in directory <code>target/mappings</code>. Your project should create from
this generated mappings additional artifact with classifier <code>stubs</code> for
easy deploy to maven repository.</p>
</div>
<div class="paragraph">
<p>Sample configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${verifier-plugin.version}&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;convert&lt;/goal&gt;
                &lt;goal&gt;generateStubs&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When present, json stubs can be used in consumer automated tests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@RunWith(SpringTestRunner.class)
@SpringBootTest
@AutoConfigureStubRunner
public class LoanApplicationServiceTests {

  @Autowired
  LoanApplicationService service;

  @Test
  public void shouldSuccessfullyApplyForLoan() {
    //given:
 	LoanApplication application =
			new LoanApplication(new Client("12345678901"), 123.123);
    //when:
	LoanApplicationResult loanApplication = service.loanApplication(application);
    // then:
	assertThat(loanApplication.loanApplicationStatus).isEqualTo(LoanApplicationStatus.LOAN_APPLIED);
	assertThat(loanApplication.rejectionReason).isNull();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Underneath <code>LoanApplication</code> makes a call to the <code>FraudDetection</code> service. This request is handled by
a WireMock server configured using stubs generated by Spring Cloud Contract Verifier.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_scenarios">Scenarios</h4>
<div class="paragraph">
<p>It&#8217;s possible to handle scenarios with Spring Cloud Contract Verifier. All you need to do is to stick to proper naming convention while creating your contracts. The convention requires to include order number followed by the underscore.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>my_contracts_dir\
  scenario1\
    1_login.groovy
    2_showCart.groovy
    3_logout.groovy</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such tree will cause Spring Cloud Contract Verifier generating WireMock&#8217;s scenario with name <code>scenario1</code> and three steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>login marked as <code>Started</code> pointing to:</p>
</li>
<li>
<p>showCart marked as <code>Step1</code> pointing to:</p>
</li>
<li>
<p>logout marked as <code>Step2</code> which will close the scenario.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>More details about WireMock scenarios can be found under <a href="http://wiremock.org/stateful-behaviour.html">http://wiremock.org/stateful-behaviour.html</a></p>
</div>
<div class="paragraph">
<p>Spring Cloud Contract Verifier will also generate tests with guaranteed order of execution.</p>
</div>
</div>
<div class="sect3">
<h4 id="_stubs_and_transitive_dependencies">Stubs and transitive dependencies</h4>
<div class="paragraph">
<p>The Maven and Gradle plugin that we&#8217;re created are adding the tasks that create the stubs jar for you. What can be problematic
is that when reusing the stubs you can by mistake import all of that stub dependencies! When building a Maven artifact
even though you have a couple of different jars, all of them share one pom:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">├── github-webhook-0.0.1.BUILD-20160903.075506-1-stubs.jar
├── github-webhook-0.0.1.BUILD-20160903.075506-1-stubs.jar.sha1
├── github-webhook-0.0.1.BUILD-20160903.075655-2-stubs.jar
├── github-webhook-0.0.1.BUILD-20160903.075655-2-stubs.jar.sha1
├── github-webhook-0.0.1.BUILD-SNAPSHOT.jar
├── github-webhook-0.0.1.BUILD-SNAPSHOT.pom
├── github-webhook-0.0.1.BUILD-SNAPSHOT-stubs.jar
├── ...
└── ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are three possibilities of working with those dependencies so as not to have any issues with transitive dependencies.</p>
</div>
<div class="paragraph">
<p><strong>Mark all application dependencies as optional</strong></p>
</div>
<div class="paragraph">
<p>If in the <code>github-webhook</code> application we would mark all of our dependencies as optional, when you include the
<code>github-webhook</code> stubs in another application (or when that dependency gets downloaded by Stub Runner) then, since
all of the depenencies are optional, they will not get downloaded.</p>
</div>
<div class="paragraph">
<p><strong>Create a separate artifactid for stubs</strong></p>
</div>
<div class="paragraph">
<p>If you create a separate artifactid then you can set it up in whatever way you wish. For example by having no dependencies at all.</p>
</div>
<div class="paragraph">
<p><strong>Exclude dependencies on the consumer side</strong></p>
</div>
<div class="paragraph">
<p>As a consumer, if you add the stub dependency to your classpath you can explicitly exclude the unwanted dependencies.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring_cloud_contract_verifier_messaging">Spring Cloud Contract Verifier Messaging</h3>
<div class="paragraph">
<p>Spring Cloud Contract Verifier allows you to verify your application that uses messaging as means of communication.
All of our integrations are working with Spring but you can also create one yourself and use it.</p>
</div>
<div class="sect3">
<h4 id="_integrations">Integrations</h4>
<div class="paragraph">
<p>You can use one of the four integration configurations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apache Camel</p>
</li>
<li>
<p>Spring Integration</p>
</li>
<li>
<p>Spring Cloud Stream</p>
</li>
<li>
<p>Spring AMQP</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since we&#8217;re using Spring Boot then if you have added one of the aforementioned libraries
to the classpath then automatically all the messaging configuration will be set up.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Remember to put <code>@AutoConfigureMessageVerifier</code> on the base class of your
generated tests. Otherwise messaging part of Spring Cloud Contract Verifier will not work.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_manual_integration_testing">Manual Integration Testing</h4>
<div class="paragraph">
<p>The main interface used by the tests is the <code>org.springframework.cloud.contract.verifier.messaging.MessageVerifier</code>.
It defines how to send and receive messages. You can create your own implementation to achieve the
same goal.</p>
</div>
<div class="paragraph">
<p>In the a test you can inject a <code>ContractVerifierMessageExchange</code> to send and receive messages that follow the contract.
Then add <code>@AutoConfigureMessageVerifier</code> to your test, e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringTestRunner.class)
@SpringBootTest
@AutoConfigureMessageVerifier
public static class MessagingContractTests {

  @Autowired
  private MessageVerifier verifier;
  ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If your tests require stubs as well, then
<code>@AutoConfigureStubRunner</code> includes the messaging configuration, so
you only need the one annotation.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_publisher_side_test_generation">Publisher side test generation</h4>
<div class="paragraph">
<p>Having the <code>input</code> or <code>outputMessage</code> sections in your DSL will result in creation of tests on the publisher&#8217;s side. By default
JUnit tests will be created, however there is also a possibility to create Spock tests.</p>
</div>
<div class="paragraph">
<p>There are 3 main scenarios that we should take into consideration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Scenario 1: there is no input message that produces an output one. The output message is triggered by a component
inside the application (e.g. scheduler)</p>
</li>
<li>
<p>Scenario 2: the input message triggers an output message</p>
</li>
<li>
<p>Scenario 3: the input message is consumed and there is no output message</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_scenario_1_no_input_message">Scenario 1 (no input message)</h5>
<div class="paragraph">
<p>For the given contract:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">def contractDsl = Contract.make {
	label 'some_label'
	input {
		triggeredBy('bookReturnedTriggered()')
	}
	outputMessage {
		sentTo('activemq:output')
		body('''{ "bookName" : "foo" }''')
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following JUnit test will be created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">'''
 // when:
  bookReturnedTriggered();

 // then:
  ContractVerifierMessage response = contractVerifierMessaging.receive("activemq:output");
  assertThat(response).isNotNull();
  assertThat(response.getHeader("BOOK-NAME")).isEqualTo("foo");
 // and:
  DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()));
  assertThatJson(parsedJson).field("bookName").isEqualTo("foo");
'''</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following Spock test would be created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">'''
 when:
  bookReturnedTriggered()

 then:
  ContractVerifierMessage response = contractVerifierMessaging.receive('activemq:output')
  assert response != null
  response.getHeader('BOOK-NAME')  == 'foo'
 and:
  DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.payload))
  assertThatJson(parsedJson).field("bookName").isEqualTo("foo")

'''</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_2_output_triggered_by_input">Scenario 2 (output triggered by input)</h5>
<div class="paragraph">
<p>For the given contract:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">def contractDsl = Contract.make {
	label 'some_label'
	input {
		messageFrom('jms:input')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('jms:output')
		body([
				bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following JUnit test will be created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">'''
// given:
 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
  "{\\"bookName\\":\\"foo\\"}"
, headers()
  .header("sample", "header"));

// when:
 contractVerifierMessaging.send(inputMessage, "jms:input");

// then:
 ContractVerifierMessage response = contractVerifierMessaging.receive("jms:output");
 assertThat(response).isNotNull();
 assertThat(response.getHeader("BOOK-NAME")).isEqualTo("foo");
// and:
 DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()));
 assertThatJson(parsedJson).field("bookName").isEqualTo("foo");
'''</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following Spock test would be created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">"""\
given:
   ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
    '''{"bookName":"foo"}''',
    ['sample': 'header']
  )

when:
   contractVerifierMessaging.send(inputMessage, 'jms:input')

then:
   ContractVerifierMessage response = contractVerifierMessaging.receive('jms:output')
   assert response !- null
   response.getHeader('BOOK-NAME')  == 'foo'
and:
   DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.payload))
   assertThatJson(parsedJson).field("bookName").isEqualTo("foo")
"""</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_3_no_output_message">Scenario 3 (no output message)</h5>
<div class="paragraph">
<p>For the given contract:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">def contractDsl = Contract.make {
	label 'some_label'
	input {
		messageFrom('jms:delete')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
		assertThat('bookWasDeleted()')
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following JUnit test will be created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">'''
// given:
 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
	"{\\"bookName\\":\\"foo\\"}"
, headers()
	.header("sample", "header"));

// when:
 contractVerifierMessaging.send(inputMessage, "jms:delete");

// then:
 bookWasDeleted();
'''</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following Spock test would be created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">'''
given:
	 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
		\'\'\'{"bookName":"foo"}\'\'\',
		['sample': 'header']
	)

when:
	 contractVerifierMessaging.send(inputMessage, 'jms:delete')

then:
	 noExceptionThrown()
	 bookWasDeleted()
'''</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_consumer_stub_side_generation">Consumer Stub Side generation</h4>
<div class="paragraph">
<p>Unlike the HTTP part - in Messaging we need to publish the Groovy DSL inside the JAR with a stub. Then it&#8217;s parsed on the consumer side
and proper stubbed routes are created.</p>
</div>
<div class="paragraph">
<p>For more information please consult the Stub Runner Messaging sections.</p>
</div>
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
		&lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
	&lt;/dependency&gt;

	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
		&lt;artifactId&gt;spring-cloud-starter-contract-stub-runner&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
		&lt;artifactId&gt;spring-cloud-stream-test-support&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;Dalston.BUILD-SNAPSHOT&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">ext {
	contractsDir = file("mappings")
	stubsOutputDirRoot = file("${project.buildDir}/production/${project.name}-stubs/")
}

// Automatically added by plugin:
// copyContracts - copies contracts to the output folder from which JAR will be created
// verifierStubsJar - JAR with a provided stub suffix
// the presented publication is also added by the plugin but you can modify it as you wish

publishing {
	publications {
		stubs(MavenPublication) {
			artifactId "${project.name}-stubs"
			artifact verifierStubsJar
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring_cloud_contract_stub_runner">Spring Cloud Contract Stub Runner</h3>
<div class="paragraph">
<p>One of the issues that you could have encountered while using Spring Cloud Contract Verifier was to pass the generated WireMock JSON stubs from the server side to the client side (or various clients).
 The same takes place in terms of client side generation for messaging.</p>
</div>
<div class="paragraph">
<p>Copying the JSON files / setting the client side for messaging manually is out of the question.</p>
</div>
<div class="paragraph">
<p>That&#8217;s why we&#8217;ll introduce Spring Cloud Contract Stub Runner that can download and run the stubs
automatically for you.</p>
</div>
<div class="sect3">
<h4 id="_snapshot_versions">Snapshot versions</h4>
<div class="paragraph">
<p>Add the additional snapshot repository to your build.gradle to use snapshot versions which are automatically uploaded after every successful build:</p>
</div>
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">buildscript {
	repositories {
		mavenCentral()
		mavenLocal()
		maven { url "https://repo.spring.io/snapshot" }
		maven { url "https://repo.spring.io/milestone" }
		maven { url "https://repo.spring.io/release" }
	}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_publishing_stubs_as_jars">Publishing stubs as JARs</h4>
<div class="paragraph">
<p>The easiest approach would be to centralize the way stubs are kept. For example you can keep them as JARs in a Maven repository.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
For both Maven and Gradle the setup comes out of the box. But you can customize it if you want to.
</td>
</tr>
</table>
</div>
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;!-- First disable the default jar setup in the properties section--&gt;
&lt;!-- we don't want the verifier to do a jar for us --&gt;
&lt;spring.cloud.contract.verifier.skip&gt;true&lt;/spring.cloud.contract.verifier.skip&gt;

&lt;!-- Next add the assembly plugin to your build --&gt;
&lt;plugin&gt;
	&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
	&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
	&lt;executions&gt;
		&lt;execution&gt;
			&lt;id&gt;stub&lt;/id&gt;
			&lt;phase&gt;prepare-package&lt;/phase&gt;
			&lt;goals&gt;
				&lt;goal&gt;single&lt;/goal&gt;
			&lt;/goals&gt;
			&lt;inherited&gt;false&lt;/inherited&gt;
			&lt;configuration&gt;
				&lt;attach&gt;true&lt;/attach&gt;
				&lt;descriptor&gt;${basedir}/src/assembly/stub.xml&lt;/descriptor&gt;
			&lt;/configuration&gt;
		&lt;/execution&gt;
	&lt;/executions&gt;
&lt;/plugin&gt;

&lt;!-- Finally setup your assembly. Below you can find the contents of src/main/assembly/stub.xml --&gt;
&lt;assembly
	xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd"&gt;
	&lt;id&gt;stubs&lt;/id&gt;
	&lt;formats&gt;
		&lt;format&gt;jar&lt;/format&gt;
	&lt;/formats&gt;
	&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
	&lt;fileSets&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;src/main/java&lt;/directory&gt;
			&lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**com/example/model/*.*&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${project.build.directory}/classes&lt;/directory&gt;
			&lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**com/example/model/*.*&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${project.build.directory}/snippets/stubs&lt;/directory&gt;
			&lt;outputDirectory&gt;META-INF/${project.groupId}/${project.artifactId}/${project.version}/mappings&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**/*&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${basedir}/src/test/resources/contracts&lt;/directory&gt;
			&lt;outputDirectory&gt;META-INF/${project.groupId}/${project.artifactId}/${project.version}/contracts&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**/*.groovy&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
	&lt;/fileSets&gt;
&lt;/assembly&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">ext {
	contractsDir = file("mappings")
	stubsOutputDirRoot = file("${project.buildDir}/production/${project.name}-stubs/")
}

// Automatically added by plugin:
// copyContracts - copies contracts to the output folder from which JAR will be created
// verifierStubsJar - JAR with a provided stub suffix
// the presented publication is also added by the plugin but you can modify it as you wish

publishing {
	publications {
		stubs(MavenPublication) {
			artifactId "${project.name}-stubs"
			artifact verifierStubsJar
		}
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_modules">Modules</h4>

</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_core">Stub Runner Core</h3>
<div class="paragraph">
<p>Runs stubs for service collaborators. Treating stubs as contracts of services allows to use stub-runner as an implementation of
<a href="https://martinfowler.com/articles/consumerDrivenContracts.html">Consumer Driven Contracts</a>.</p>
</div>
<div class="paragraph">
<p>Stub Runner allows you to automatically download the stubs of the provided dependencies, start WireMock servers for them and feed them with proper stub definitions.
For messaging, special stub routes are defined.</p>
</div>
<div class="sect3">
<h4 id="_running_stubs">Running stubs</h4>
<div class="sect4">
<h5 id="_limitations">Limitations</h5>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
There might be a problem with StubRunner shutting down ports between tests. You might
 have a situation in which you get port conflicts. As long as you use the same context across tests
 everything works fine. But when the context are different (e.g. different stubs or different profiles)
 then you have to either use <code>@DirtiesContext</code> to shut down the stub servers, or else run them on
 different ports per test.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_running_using_main_app">Running using main app</h5>
<div class="paragraph">
<p>You can set the following options to the main class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">-c, --classifier                Suffix for the jar containing stubs (e.
                                  g. 'stubs' if the stub jar would
                                  have a 'stubs' classifier for stubs:
                                  foobar-stubs ). Defaults to 'stubs'
                                  (default: stubs)
--maxPort, --maxp &lt;Integer&gt;     Maximum port value to be assigned to
                                  the WireMock instance. Defaults to
                                  15000 (default: 15000)
--minPort, --minp &lt;Integer&gt;     Minimum port value to be assigned to
                                  the WireMock instance. Defaults to
                                  10000 (default: 10000)
-p, --password                  Password to user when connecting to
                                  repository
--phost, --proxyHost            Proxy host to use for repository
                                  requests
--pport, --proxyPort [Integer]  Proxy port to use for repository
                                  requests
-r, --root                      Location of a Jar containing server
                                  where you keep your stubs (e.g. http:
                                  //nexus.
                                  net/content/repositories/repository)
-s, --stubs                     Comma separated list of Ivy
                                  representation of jars with stubs.
                                  Eg. groupid:artifactid1,groupid2:
                                  artifactid2:classifier
-u, --username                  Username to user when connecting to
                                  repository
--wo, --workOffline             Switch to work offline. Defaults to
                                  'false'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_http_stubs">HTTP Stubs</h5>
<div class="paragraph">
<p>Stubs are defined in JSON documents, whose syntax is defined in <a href="http://wiremock.org/stubbing.html">WireMock documentation</a></p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
    "request": {
        "method": "GET",
        "url": "/ping"
    },
    "response": {
        "status": 200,
        "body": "pong",
        "headers": {
            "Content-Type": "text/plain"
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_viewing_registered_mappings">Viewing registered mappings</h5>
<div class="paragraph">
<p>Every stubbed collaborator exposes list of defined mappings under <code>__/admin/</code> endpoint.</p>
</div>
</div>
<div class="sect4">
<h5 id="_messaging_stubs">Messaging Stubs</h5>
<div class="paragraph">
<p>Depending on the provided Stub Runner dependency and the DSL the messaging routes are automatically set up.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_junit_rule">Stub Runner JUnit Rule</h3>
<div class="paragraph">
<p>Stub Runner comes with a JUnit rule thanks to which you can very easily download and run stubs for given group and artifact id:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ClassRule public static StubRunnerRule rule = new StubRunnerRule()
		.repoRoot(repoRoot())
		.downloadStub("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")
		.downloadStub("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer");</code></pre>
</div>
</div>
<div class="paragraph">
<p>After that rule gets executed Stub Runner connects to your Maven repository and for the given list of dependencies tries to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>download them</p>
</li>
<li>
<p>cache them locally</p>
</li>
<li>
<p>unzip them to a temporary folder</p>
</li>
<li>
<p>start a WireMock server for each Maven dependency on a random port from the provided range of ports / provided port</p>
</li>
<li>
<p>feed the WireMock server with all JSON files that are valid WireMock definitions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Stub Runner uses <a href="https://wiki.eclipse.org/Aether">Eclipse Aether</a> mechanism to download the Maven dependencies.
Check their <a href="https://wiki.eclipse.org/Aether">docs</a> for more information.</p>
</div>
<div class="paragraph">
<p>Since the <code>StubRunnerRule</code> implements the <code>StubFinder</code> it allows you to find the started stubs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.stubrunner;

import java.net.URL;
import java.util.Collection;
import java.util.Map;

import org.springframework.cloud.contract.spec.Contract;

public interface StubFinder extends StubTrigger {
	/**
	 * For the given groupId and artifactId tries to find the matching
	 * URL of the running stub.
	 *
	 * @param groupId - might be null. In that case a search only via artifactId takes place
	 * @return URL of a running stub or throws exception if not found
	 */
	URL findStubUrl(String groupId, String artifactId) throws StubNotFoundException;

	/**
	 * For the given Ivy notation {@code [groupId]:artifactId:[version]:[classifier]} tries to
	 * find the matching URL of the running stub. You can also pass only {@code artifactId}.
	 *
	 * @param ivyNotation - Ivy representation of the Maven artifact
	 * @return URL of a running stub or throws exception if not found
	 */
	URL findStubUrl(String ivyNotation) throws StubNotFoundException;

	/**
	 * Returns all running stubs
	 */
	RunningStubs findAllRunningStubs();

	/**
	 * Returns the list of Contracts
	 */
	Map&lt;StubConfiguration, Collection&lt;Contract&gt;&gt; getContracts();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example of usage in Spock tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@ClassRule @Shared StubRunnerRule rule = new StubRunnerRule()
		.repoRoot(StubRunnerRuleSpec.getResource("/m2repo/repository").toURI().toString())
		.downloadStub("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")
		.downloadStub("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")

def 'should start WireMock servers'() {
	expect: 'WireMocks are running'
		rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance') != null
		rule.findStubUrl('loanIssuance') != null
		rule.findStubUrl('loanIssuance') == rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance')
		rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer') != null
	and:
		rule.findAllRunningStubs().isPresent('loanIssuance')
		rule.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs', 'fraudDetectionServer')
		rule.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer')
	and: 'Stubs were registered'
		"${rule.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
		"${rule.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example of usage in JUnit tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void should_start_wiremock_servers() throws Exception {
	// expect: 'WireMocks are running'
		then(rule.findStubUrl("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")).isNotNull();
		then(rule.findStubUrl("loanIssuance")).isNotNull();
		then(rule.findStubUrl("loanIssuance")).isEqualTo(rule.findStubUrl("org.springframework.cloud.contract.verifier.stubs", "loanIssuance"));
		then(rule.findStubUrl("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")).isNotNull();
	// and:
		then(rule.findAllRunningStubs().isPresent("loanIssuance")).isTrue();
		then(rule.findAllRunningStubs().isPresent("org.springframework.cloud.contract.verifier.stubs", "fraudDetectionServer")).isTrue();
		then(rule.findAllRunningStubs().isPresent("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")).isTrue();
	// and: 'Stubs were registered'
		then(httpGet(rule.findStubUrl("loanIssuance").toString() + "/name")).isEqualTo("loanIssuance");
		then(httpGet(rule.findStubUrl("fraudDetectionServer").toString() + "/name")).isEqualTo("fraudDetectionServer");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Check the <strong>Common properties for JUnit and Spring</strong> for more information on how to apply global configuration of Stub Runner.</p>
</div>
<div class="sect3">
<h4 id="_maven_settings">Maven settings</h4>
<div class="paragraph">
<p>The stub downloader honors Maven settings for a different local repository folder.
Authentication details for repositories and profiles are currently not taken into account, so you need to specify it using the properties mentioned above.</p>
</div>
</div>
<div class="sect3">
<h4 id="_providing_fixed_ports">Providing fixed ports</h4>
<div class="paragraph">
<p>You can also run your stubs on fixed ports. You can do it in two different ways. One is to pass it in the properties, and the other via fluent API of
JUnit rule.</p>
</div>
</div>
<div class="sect3">
<h4 id="_fluent_api">Fluent API</h4>
<div class="paragraph">
<p>When using the <code>StubRunnerRule</code> you can add a stub to download and then pass the port for the last downloaded stub.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ClassRule public static StubRunnerRule rule = new StubRunnerRule()
		.repoRoot(repoRoot())
		.downloadStub("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")
		.withPort(12345)
		.downloadStub("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer:12346");</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that for this example the following test is valid:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">then(rule.findStubUrl("loanIssuance")).isEqualTo(URI.create("http://localhost:12345").toURL());
then(rule.findStubUrl("fraudDetectionServer")).isEqualTo(URI.create("http://localhost:12346").toURL());</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_stub_runner_with_spring">Stub Runner with Spring</h4>
<div class="paragraph">
<p>Sets up Spring configuration of the Stub Runner project.</p>
</div>
<div class="paragraph">
<p>By providing a list of stubs inside your configuration file the Stub Runner automatically downloads
and registers in WireMock the selected stubs.</p>
</div>
<div class="paragraph">
<p>If you want to find the URL of your stubbed dependency you can autowire the <code>StubFinder</code> interface and use
its methods as presented below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@ContextConfiguration(classes = Config, loader = SpringBootContextLoader)
@SpringBootTest(properties = [" stubrunner.cloud.enabled=false",
		"stubrunner.camel.enabled=false",
		'foo=${stubrunner.runningstubs.fraudDetectionServer.port}'])
@AutoConfigureStubRunner
@DirtiesContext
@ActiveProfiles("test")
class StubRunnerConfigurationSpec extends Specification {

	@Autowired StubFinder stubFinder
	@Autowired Environment environment
	@Value('${foo}') Integer foo

	@BeforeClass
	@AfterClass
	void setupProps() {
		System.clearProperty("stubrunner.repository.root")
		System.clearProperty("stubrunner.classifier")
	}

	def 'should start WireMock servers'() {
		expect: 'WireMocks are running'
			stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance') != null
			stubFinder.findStubUrl('loanIssuance') != null
			stubFinder.findStubUrl('loanIssuance') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance')
			stubFinder.findStubUrl('loanIssuance') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance')
			stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT:stubs')
			stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer') != null
		and:
			stubFinder.findAllRunningStubs().isPresent('loanIssuance')
			stubFinder.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs', 'fraudDetectionServer')
			stubFinder.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer')
		and: 'Stubs were registered'
			"${stubFinder.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
			"${stubFinder.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
	}

	def 'should throw an exception when stub is not found'() {
		when:
			stubFinder.findStubUrl('nonExistingService')
		then:
			thrown(StubNotFoundException)
		when:
			stubFinder.findStubUrl('nonExistingGroupId', 'nonExistingArtifactId')
		then:
			thrown(StubNotFoundException)
	}

	def 'should register started servers as environment variables'() {
		expect:
			environment.getProperty("stubrunner.runningstubs.loanIssuance.port") != null
			stubFinder.findAllRunningStubs().getPort("loanIssuance") == (environment.getProperty("stubrunner.runningstubs.loanIssuance.port") as Integer)
		and:
			environment.getProperty("stubrunner.runningstubs.fraudDetectionServer.port") != null
			stubFinder.findAllRunningStubs().getPort("fraudDetectionServer") == (environment.getProperty("stubrunner.runningstubs.fraudDetectionServer.port") as Integer)
	}

	def 'should be able to interpolate a running stub in the passed test property'() {
		given:
			int fraudPort = stubFinder.findAllRunningStubs().getPort("fraudDetectionServer")
		expect:
			fraudPort &gt; 0
			environment.getProperty("foo", Integer) == fraudPort
			foo == fraudPort
	}

	@Configuration
	@EnableAutoConfiguration
	static class Config {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>for the following configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">stubrunner:
  repositoryRoot: classpath:m2repo/repository/
  ids:
    - org.springframework.cloud.contract.verifier.stubs:loanIssuance
    - org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer
    - org.springframework.cloud.contract.verifier.stubs:bootService
  cloud:
    enabled: false
  camel:
    enabled: false

spring.cloud:
  consul.enabled: false
  service-registry.enabled: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of using the properties you can also use the properties inside the <code>@AutoConfigureStubRunner</code>.
Below you can find an example of achieving the same result by setting values on the annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@AutoConfigureStubRunner(
		ids = ["org.springframework.cloud.contract.verifier.stubs:loanIssuance",
		"org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer",
		"org.springframework.cloud.contract.verifier.stubs:bootService"],
		repositoryRoot = "classpath:m2repo/repository/")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Stub Runner Spring registers environment variables in the following manner
for every registered WireMock server. Example for Stub Runner ids
 <code>com.example:foo</code>, <code>com.example:bar</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>stubrunner.runningstubs.foo.port</code></p>
</li>
<li>
<p><code>stubrunner.runningstubs.bar.port</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Which you can reference in your code.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_spring_cloud">Stub Runner Spring Cloud</h3>
<div class="paragraph">
<p>Stub Runner can integrate with Spring Cloud.</p>
</div>
<div class="paragraph">
<p>For real life examples you can check the</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/master/producer">producer app sample</a></p>
</li>
<li>
<p><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/master/consumer_with_discovery">consumer app sample</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_stubbing_service_discovery">Stubbing Service Discovery</h4>
<div class="paragraph">
<p>The most important feature of <code>Stub Runner Spring Cloud</code> is the fact that it&#8217;s stubbing</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DiscoveryClient</code></p>
</li>
<li>
<p><code>Ribbon</code> <code>ServerList</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>that means that regardless of the fact whether you&#8217;re using Zookeeper, Consul, Eureka or anything else, you don&#8217;t need that in your tests.
We&#8217;re starting WireMock instances of your dependencies and we&#8217;re telling your application whenever you&#8217;re using <code>Feign</code>, load balanced <code>RestTemplate</code>
or <code>DiscoveryClient</code> directly, to call those stubbed servers instead of calling the real Service Discovery tool.</p>
</div>
<div class="paragraph">
<p>For example this test will pass</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">def 'should make service discovery work'() {
	expect: 'WireMocks are running'
		"${stubFinder.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
		"${stubFinder.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
	and: 'Stubs can be reached via load service discovery'
		restTemplate.getForObject('http://loanIssuance/name', String) == 'loanIssuance'
		restTemplate.getForObject('http://someNameThatShouldMapFraudDetectionServer/name', String) == 'fraudDetectionServer'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>for the following configuration file</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">spring.cloud:
  zookeeper.enabled: false
  consul.enabled: false
eureka.client.enabled: false
stubrunner:
  camel.enabled: false
  idsToServiceIds:
    ivyNotation: someValueInsideYourCode
    fraudDetectionServer: someNameThatShouldMapFraudDetectionServer</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_test_profiles_and_service_discovery">Test profiles and service discovery</h5>
<div class="paragraph">
<p>In your integration tests you typically don&#8217;t want to call neither a discovery service (e.g. Eureka)
or Config Server. That&#8217;s why you create an additional test configuration in which you want to disable
these features.</p>
</div>
<div class="paragraph">
<p>Due to certain limitations of <a href="https://github.com/spring-cloud/spring-cloud-commons/issues/156"><code>spring-cloud-commons</code></a> to achieve this you have disable these properties
via a static block like presented below (example for Eureka)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    //Hack to work around https://github.com/spring-cloud/spring-cloud-commons/issues/156
    static {
        System.setProperty("eureka.client.enabled", "false");
        System.setProperty("spring.cloud.config.failFast", "false");
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_additional_configuration">Additional Configuration</h4>
<div class="paragraph">
<p>You can match the artifactId of the stub with the name of your app by using the <code>stubrunner.idsToServiceIds:</code> map.
You can disable Stub Runner Ribbon support by providing: <code>stubrunner.cloud.ribbon.enabled</code> equal to <code>false</code>
You can disable Stub Runner support by providing: <code>stubrunner.cloud.enabled</code> equal to <code>false</code></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
By default all service discovery will be stubbed. That means that regardless of the fact if you have
an existing <code>DiscoveryClient</code> its results will be ignored. However, if you want to reuse it, just set
 <code>stubrunner.cloud.delegate.enabled</code> to <code>true</code> and then your existing <code>DiscoveryClient</code> results will be
 merged with the stubbed ones.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_boot_application">Stub Runner Boot Application</h3>
<div class="paragraph">
<p>Spring Cloud Contract Verifier Stub Runner Boot is a Spring Boot application that exposes REST endpoints to
trigger the messaging labels and to access started WireMock servers.</p>
</div>
<div class="paragraph">
<p>One of the use-cases is to run some smoke (end to end) tests on a deployed application. You can read
 more about this in the  <a href="http://toomuchcoding.com/blog/2015/09/27/microservice-deployment/">"Microservice Deployment" article at Too Much Coding blog.</a></p>
</div>
<div class="sect3">
<h4 id="_how_to_use_it">How to use it?</h4>
<div class="paragraph">
<p>Just add the</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compile "org.springframework.cloud:spring-cloud-starter-stub-runner"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Annotate a class with <code>@EnableStubRunnerServer</code>, build a fat-jar and you&#8217;re ready to go!</p>
</div>
<div class="paragraph">
<p>For the properties check the <strong>Stub Runner Spring</strong> section.</p>
</div>
</div>
<div class="sect3">
<h4 id="_endpoints">Endpoints</h4>
<div class="sect4">
<h5 id="_http">HTTP</h5>
<div class="ulist">
<ul>
<li>
<p>GET <code>/stubs</code> - returns a list of all running stubs in <code>ivy:integer</code> notation</p>
</li>
<li>
<p>GET <code>/stubs/{ivy}</code> - returns a port for the given <code>ivy</code> notation (when calling the endpoint <code>ivy</code> can also be <code>artifactId</code> only)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_messaging">Messaging</h5>
<div class="paragraph">
<p>For Messaging</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GET <code>/triggers</code> - returns a list of all running labels in <code>ivy : [ label1, label2 &#8230;&#8203;]</code> notation</p>
</li>
<li>
<p>POST <code>/triggers/{label}</code> - executes a trigger with <code>label</code></p>
</li>
<li>
<p>POST <code>/triggers/{ivy}/{label}</code> - executes a trigger with <code>label</code> for the given <code>ivy</code> notation (when calling the endpoint <code>ivy</code> can also be <code>artifactId</code> only)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_example">Example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@ContextConfiguration(classes = StubRunnerBoot, loader = SpringBootContextLoader)
@SpringBootTest(properties = "spring.cloud.zookeeper.enabled=false")
@ActiveProfiles("test")
class StubRunnerBootSpec extends Specification {

	@Autowired StubRunning stubRunning

	def setup() {
		RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning),
				new TriggerController(stubRunning))
	}

	def 'should return a list of running stub servers in "full ivy:port" notation'() {
		when:
			String response = RestAssuredMockMvc.get('/stubs').body.asString()
		then:
			def root = new JsonSlurper().parseText(response)
			root.'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs' instanceof Integer
	}

	def 'should return a port on which a [#stubId] stub is running'() {
		when:
			def response = RestAssuredMockMvc.get("/stubs/${stubId}")
		then:
			response.statusCode == 200
			response.body.as(Integer) &gt; 0
		where:
			stubId &lt;&lt; ['org.springframework.cloud.contract.verifier.stubs:bootService:+:stubs',
					   'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs',
					   'org.springframework.cloud.contract.verifier.stubs:bootService:+',
					   'org.springframework.cloud.contract.verifier.stubs:bootService',
					   'bootService']
	}

	def 'should return 404 when missing stub was called'() {
		when:
			def response = RestAssuredMockMvc.get("/stubs/a:b:c:d")
		then:
			response.statusCode == 404
	}

	def 'should return a list of messaging labels that can be triggered when version and classifier are passed'() {
		when:
			String response = RestAssuredMockMvc.get('/triggers').body.asString()
		then:
			def root = new JsonSlurper().parseText(response)
			root.'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs'?.containsAll(["delete_book","return_book_1","return_book_2"])
	}

	def 'should trigger a messaging label'() {
		given:
			StubRunning stubRunning = Mock()
			RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning), new TriggerController(stubRunning))
		when:
			def response = RestAssuredMockMvc.post("/triggers/delete_book")
		then:
			response.statusCode == 200
		and:
			1 * stubRunning.trigger('delete_book')
	}

	def 'should trigger a messaging label for a stub with [#stubId] ivy notation'() {
		given:
			StubRunning stubRunning = Mock()
			RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning), new TriggerController(stubRunning))
		when:
			def response = RestAssuredMockMvc.post("/triggers/$stubId/delete_book")
		then:
			response.statusCode == 200
		and:
			1 * stubRunning.trigger(stubId, 'delete_book')
		where:
			stubId &lt;&lt; ['org.springframework.cloud.contract.verifier.stubs:bootService:stubs', 'org.springframework.cloud.contract.verifier.stubs:bootService', 'bootService']
	}

	def 'should throw exception when trigger is missing'() {
		when:
			RestAssuredMockMvc.post("/triggers/missing_label")
		then:
			Exception e = thrown(Exception)
			e.message.contains("Exception occurred while trying to return [missing_label] label.")
			e.message.contains("Available labels are")
			e.message.contains("org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT:stubs=[]")
			e.message.contains("org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs=")
	}

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_stub_runner_boot_with_service_discovery">Stub Runner Boot with Service Discovery</h4>
<div class="paragraph">
<p>One of the possibilities of using Stub Runner Boot is to use it as a feed of stubs for "smoke-tests". What does it mean?
 Let&#8217;s assume that you don&#8217;t want to deploy 50 microservice to a test environment in order
 to check if your application is working fine. You&#8217;ve already executed a suite of tests during the build process
 but you would also like to ensure that the packaging of your application is fine. What you can do
 is to deploy your application to an environment, start it and run a couple of tests on it to see if
 it&#8217;s working fine. We can call those tests smoke-tests since their idea is to check only a handful
 of testing scenarios.</p>
</div>
<div class="paragraph">
<p>The problem with this approach is such that if you&#8217;re doing microservices most likely you&#8217;re
 using a service discovery tool. Stub Runner Boot allows you to solve this issue by starting the
 required stubs and register them in a service discovery tool. Let&#8217;s take a look at an example of
 such a setup with Eureka. Let&#8217;s assume that Eureka was already running.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableStubRunnerServer
@EnableEurekaClient
@AutoConfigureStubRunner
public class StubRunnerBootEurekaExample {

	public static void main(String[] args) {
		SpringApplication.run(StubRunnerBootEurekaExample.class, args);
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see we want to start a Stub Runner Boot server <code>@EnableStubRunnerServer</code>, enable Eureka client <code>@EnableEurekaClient</code>
and we want to have the stub runner feature turned on <code>@AutoConfigureStubRunner</code>.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s assume that we want to start this application so that the stubs get automatically registered.
 We can do it by running the app <code>java -jar ${SYSTEM_PROPS} stub-runner-boot-eureka-example.jar</code> where
 <code>${SYSTEM_PROPS}</code> would contain the following list of properties</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">-Dstubrunner.repositoryRoot=https://repo.spring.io/snapshots (1)
-Dstubrunner.cloud.stubbed.discovery.enabled=false (2)
-Dstubrunner.ids=org.springframework.cloud.contract.verifier.stubs:loanIssuance,org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer,org.springframework.cloud.contract.verifier.stubs:bootService (3)
-Dstubrunner.idsToServiceIds.fraudDetectionServer=someNameThatShouldMapFraudDetectionServer (4)

(1) - we tell Stub Runner where all the stubs reside
(2) - we don't want the default behaviour where the discovery service is stubbed. That's why the stub registration will be picked
(3) - we provide a list of stubs to download
(4) - we provide a list of artifactId to serviceId mapping</code></pre>
</div>
</div>
<div class="paragraph">
<p>That way your deployed application can send requests to started WireMock servers via the service
discovery. Most likely points 1-3 could be set by default in <code>application.yml</code> cause they are not
likely to change. That way you can provide only the list of stubs to download whenever you start
the Stub Runner Boot.</p>
</div>
</div>
<div class="sect3">
<h4 id="_common_properties_for_junit_and_spring">Common properties for JUnit and Spring</h4>
<div class="paragraph">
<p>Some of the properties that are repetitive can be set using system properties or configuration properties (for Spring). Here are their names with their default values:</p>
</div>
<table class="tableblock frame-topbot grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property name</th>
<th class="tableblock halign-left valign-top">Default value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.minPort</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Minimal value of a port for a started WireMock with stubs</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.maxPort</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Minimal value of a port for a started WireMock with stubs</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.repositoryRoot</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maven repo url. If blank then will call the local maven repo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.classifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default classifier for the stub artifacts</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.workOffline</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If true then will not contact any remote repositories to download stubs</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.ids</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array of Ivy notation stubs to download</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.username</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional username to access the tool that stores the JARs with stubs</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional password to access the tool that stores the JARs with stubs</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_stub_runner_stubs_ids">Stub runner stubs ids</h5>
<div class="paragraph">
<p>You can provide the stubs to download via the <code>stubrunner.ids</code> system property. They follow the following pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">groupId:artifactId:version:classifier:port</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>version</code>, <code>classifier</code> and <code>port</code> are optional.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you don&#8217;t provide the <code>port</code> then a random one will be picked</p>
</li>
<li>
<p>If you don&#8217;t provide the <code>classifier</code> then the default one will be taken. (NOTE that you can pass an empty classifier like this <code>groupId:artifactId:version:</code>)</p>
</li>
<li>
<p>If you don&#8217;t provide the <code>version</code> then the <code>+</code> will be passed and the latest one will be downloaded</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Where <code>port</code> means the port of the WireMock server.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Starting from version 1.0.4 as a version you can provide a range of versions that you would like
the Stub Runner to take into consideration. You can read more about the <a href="https://wiki.eclipse.org/Aether/New_and_Noteworthy#Version_Ranges">Aether versioning ranges here</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Taken from <a href="https://download.eclipse.org/aether/aether-core/0.9.0/apidocs/org/eclipse/aether/util/version/GenericVersionScheme.html">Aether Docs</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>This scheme accepts versions of any form, interpreting a version as a sequence of numeric and alphabetic segments. The characters '-', '_', and '.' as well as the mere
transitions from digit to letter and vice versa delimit the version segments. Delimiters are treated as equivalent.</p>
</div>
<div class="paragraph">
<p>Numeric segments are compared mathematically, alphabetic segments are compared lexicographically and case-insensitively. However, the following qualifier strings are
recognized and treated specially: "alpha" = "a" &lt; "beta" = "b" &lt; "milestone" = "m" &lt; "cr" = "rc" &lt; "snapshot" &lt; "final" = "ga" &lt; "sp". All of those well-known qualifiers
are considered smaller/older than other strings. An empty segment/string is equivalent to 0.</p>
</div>
<div class="paragraph">
<p>In addition to the above mentioned qualifiers, the tokens "min" and "max" may be used as final version segment to denote the smallest/greatest version having a given prefix.
For example, "1.2.min" denotes the smallest version in the 1.2 line, "1.2.max" denotes the greatest version in the 1.2 line. A version range of the form "[M.N.*]" is short for "[M.N.min, M.N.max]".</p>
</div>
<div class="paragraph">
<p>Numbers and strings are considered incomparable against each other. Where version segments of different kind would collide, comparison will instead assume that the previous
segments are padded with trailing 0 or "ga" segments, respectively, until the kind mismatch is resolved, e.g. "1-alpha" = "1.0.0-alpha" &lt; "1.0.1-ga" = "1.0.1".</p>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_for_messaging">Stub Runner for Messaging</h3>
<div class="paragraph">
<p>Stub Runner has the functionality to run the published stubs in memory. It can integrate with the following frameworks out of the box</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Integration</p>
</li>
<li>
<p>Spring Cloud Stream</p>
</li>
<li>
<p>Apache Camel</p>
</li>
<li>
<p>Spring AMQP</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It also provides points of entry to integrate with any other solution on the market.</p>
</div>
<div class="sect3">
<h4 id="_stub_triggering">Stub triggering</h4>
<div class="paragraph">
<p>To trigger a message it&#8217;s enough to use the <code>StubTrigger</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.stubrunner;

import java.util.Collection;
import java.util.Map;

public interface StubTrigger {

	/**
	 * Triggers an event by a given label for a given {@code groupid:artifactid} notation. You can use only {@code artifactId} too.
	 *
	 * Feature related to messaging.
	 *
	 * @return true - if managed to run a trigger
	 */
	boolean trigger(String ivyNotation, String labelName);

	/**
	 * Triggers an event by a given label.
	 *
	 * Feature related to messaging.
	 *
	 * @return true - if managed to run a trigger
	 */
	boolean trigger(String labelName);

	/**
	 * Triggers all possible events.
	 *
	 * Feature related to messaging.
	 *
	 * @return true - if managed to run a trigger
	 */
	boolean trigger();

	/**
	 * Returns a mapping of ivy notation of a dependency to all the labels it has.
	 *
	 * Feature related to messaging.
	 */
	Map&lt;String, Collection&lt;String&gt;&gt; labels();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For convenience the <code>StubFinder</code> interface extends <code>StubTrigger</code> so it&#8217;s enough to use only one in your tests.</p>
</div>
<div class="paragraph">
<p><code>StubTrigger</code> gives you the following options to trigger a message:</p>
</div>
<div class="sect4">
<h5 id="_trigger_by_label">Trigger by label</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_trigger_by_group_and_artifact_ids">Trigger by group and artifact ids</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('org.springframework.cloud.contract.verifier.stubs:camelService', 'return_book_1')</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_trigger_by_artifact_ids">Trigger by artifact ids</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('camelService', 'return_book_1')</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trigger_all_messages">Trigger all messages</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">stubFinder.trigger()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_camel">Stub Runner Camel</h3>
<div class="paragraph">
<p>Spring Cloud Contract Verifier Stub Runner&#8217;s messaging module gives you an easy way to integrate with Apache Camel.
For the provided artifacts it will automatically download the stubs and register the required
routes.</p>
</div>
<div class="sect3">
<h4 id="_adding_it_to_the_project">Adding it to the project</h4>
<div class="paragraph">
<p>It&#8217;s enough to have both Apache Camel and Spring Cloud Contract Stub Runner on classpath.
Remember to annotate your test class with <code>@AutoConfigureMessageVerifier</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_examples">Examples</h4>
<div class="sect4">
<h5 id="_stubs_structure">Stubs structure</h5>
<div class="paragraph">
<p>Let us assume that we have the following Maven repository with a deployed stubs for the
<code>camelService</code> application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── camelService
                            ├── 0.0.1-SNAPSHOT
                            │   ├── camelService-0.0.1-SNAPSHOT.pom
                            │   ├── camelService-0.0.1-SNAPSHOT-stubs.jar
                            │   └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the stubs contain the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">├── META-INF
│   └── MANIFEST.MF
└── repository
    ├── accurest
    │   ├── bookDeleted.groovy
    │   ├── bookReturned1.groovy
    │   └── bookReturned2.groovy
    └── mappings</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following contracts (let' number it with <strong>1</strong>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_1'
	input {
		triggeredBy('bookReturnedTriggered()')
	}
	outputMessage {
		sentTo('jms:output')
		body('''{ "bookName" : "foo" }''')
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and number <strong>2</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_2'
	input {
		messageFrom('jms:input')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('jms:output')
		body([
				bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_1_no_input_message_2">Scenario 1 (no input message)</h5>
<div class="paragraph">
<p>So as to trigger a message via the <code>return_book_1</code> label we&#8217;ll use the <code>StubTigger</code> interface as follows</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we&#8217;ll want to listen to the output of the message sent to <code>jms:output</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Exchange receivedMessage = camelContext.createConsumerTemplate().receive('jms:output', 5000)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the received message would pass the following assertions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.in.body)
receivedMessage.in.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_2_output_triggered_by_input_2">Scenario 2 (output triggered by input)</h5>
<div class="paragraph">
<p>Since the route is set for you it&#8217;s enough to just send a message to the <code>jms:output</code> destination.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">camelContext.createProducerTemplate().sendBodyAndHeaders('jms:input', new BookReturned('foo'), [sample: 'header'])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we&#8217;ll want to listen to the output of the message sent to <code>jms:output</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Exchange receivedMessage = camelContext.createConsumerTemplate().receive('jms:output', 5000)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the received message would pass the following assertions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.in.body)
receivedMessage.in.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_3_input_with_no_output">Scenario 3 (input with no output)</h5>
<div class="paragraph">
<p>Since the route is set for you it&#8217;s enough to just send a message to the <code>jms:output</code> destination.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">camelContext.createProducerTemplate().sendBodyAndHeaders('jms:delete', new BookReturned('foo'), [sample: 'header'])</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_integration">Stub Runner Integration</h3>
<div class="paragraph">
<p>Spring Cloud Contract Verifier Stub Runner&#8217;s messaging module gives you an easy way to integrate with Spring Integration.
For the provided artifacts it will automatically download the stubs and register the required
routes.</p>
</div>
<div class="sect3">
<h4 id="_adding_it_to_the_project_2">Adding it to the project</h4>
<div class="paragraph">
<p>It&#8217;s enough to have both Apache Camel and Spring Cloud Contract Stub Runner on classpath.
Remember to annotate your test class with <code>@AutoConfigureMessageVerifier</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_examples_2">Examples</h4>
<div class="sect4">
<h5 id="_stubs_structure_2">Stubs structure</h5>
<div class="paragraph">
<p>Let us assume that we have the following Maven repository with a deployed stubs for the
<code>integrationService</code> application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── integrationService
                            ├── 0.0.1-SNAPSHOT
                            │   ├── integrationService-0.0.1-SNAPSHOT.pom
                            │   ├── integrationService-0.0.1-SNAPSHOT-stubs.jar
                            │   └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the stubs contain the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">├── META-INF
│   └── MANIFEST.MF
└── repository
    ├── accurest
    │   ├── bookDeleted.groovy
    │   ├── bookReturned1.groovy
    │   └── bookReturned2.groovy
    └── mappings</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following contracts (let' number it with <strong>1</strong>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_1'
	input {
		triggeredBy('bookReturnedTriggered()')
	}
	outputMessage {
		sentTo('output')
		body('''{ "bookName" : "foo" }''')
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and number <strong>2</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_2'
	input {
		messageFrom('input')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('output')
		body([
				bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the following Spring Integration Route:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns="http://www.springframework.org/schema/integration"
			 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xmlns:beans="http://www.springframework.org/schema/beans"
			 xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/integration
			https://www.springframework.org/schema/integration/spring-integration.xsd"&gt;


	&lt;!-- REQUIRED FOR TESTING --&gt;
	&lt;bridge input-channel="output"
			output-channel="outputTest"/&gt;

	&lt;channel id="outputTest"&gt;
		&lt;queue/&gt;
	&lt;/channel&gt;

&lt;/beans:beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_1_no_input_message_3">Scenario 1 (no input message)</h5>
<div class="paragraph">
<p>So as to trigger a message via the <code>return_book_1</code> label we&#8217;ll use the <code>StubTigger</code> interface as follows</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we&#8217;ll want to listen to the output of the message sent to <code>output</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Message&lt;?&gt; receivedMessage = messaging.receive('outputTest')</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the received message would pass the following assertions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_2_output_triggered_by_input_3">Scenario 2 (output triggered by input)</h5>
<div class="paragraph">
<p>Since the route is set for you it&#8217;s enough to just send a message to the <code>output</code> destination.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'input')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we&#8217;ll want to listen to the output of the message sent to <code>output</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Message&lt;?&gt; receivedMessage = messaging.receive('outputTest')</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the received message would pass the following assertions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_3_input_with_no_output_2">Scenario 3 (input with no output)</h5>
<div class="paragraph">
<p>Since the route is set for you it&#8217;s enough to just send a message to the <code>input</code> destination.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'delete')</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_stream">Stub Runner Stream</h3>
<div class="paragraph">
<p>Spring Cloud Contract Verifier Stub Runner&#8217;s messaging module gives you an easy way to integrate with Spring Stream.
For the provided artifacts it will automatically download the stubs and register the required
routes.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
In Stub Runner&#8217;s integration with Stream the <code>messageFrom</code> or <code>sentTo</code> Strings are resolved
first as a <code>destination</code> of a channel, and then if there is no such <code>destination</code> it&#8217;s resolved as a
channel name.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_adding_it_to_the_project_3">Adding it to the project</h4>
<div class="paragraph">
<p>It&#8217;s enough to have both Apache Camel and Spring Cloud Contract Stub Runner on classpath.
Remember to annotate your test class with <code>@AutoConfigureMessageVerifier</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_examples_3">Examples</h4>
<div class="sect4">
<h5 id="_stubs_structure_3">Stubs structure</h5>
<div class="paragraph">
<p>Let us assume that we have the following Maven repository with a deployed stubs for the
<code>streamService</code> application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── streamService
                            ├── 0.0.1-SNAPSHOT
                            │   ├── streamService-0.0.1-SNAPSHOT.pom
                            │   ├── streamService-0.0.1-SNAPSHOT-stubs.jar
                            │   └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the stubs contain the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">├── META-INF
│   └── MANIFEST.MF
└── repository
    ├── accurest
    │   ├── bookDeleted.groovy
    │   ├── bookReturned1.groovy
    │   └── bookReturned2.groovy
    └── mappings</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following contracts (let' number it with <strong>1</strong>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_1'
	input { triggeredBy('bookReturnedTriggered()') }
	outputMessage {
		sentTo('returnBook')
		body('''{ "bookName" : "foo" }''')
		headers { header('BOOK-NAME', 'foo') }
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and number <strong>2</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_2'
	input {
		messageFrom('bookStorage')
		messageBody([
			bookName: 'foo'
		])
		messageHeaders { header('sample', 'header') }
	}
	outputMessage {
		sentTo('returnBook')
		body([
			bookName: 'foo'
		])
		headers { header('BOOK-NAME', 'foo') }
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the following Spring configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">stubrunner.repositoryRoot: classpath:m2repo/repository/
stubrunner.ids: org.springframework.cloud.contract.verifier.stubs:streamService:0.0.1-SNAPSHOT:stubs

spring:
  cloud:
    stream:
      bindings:
        output:
          destination: returnBook
        input:
          destination: bookStorage

server:
  port: 0

debug: true</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_1_no_input_message_4">Scenario 1 (no input message)</h5>
<div class="paragraph">
<p>So as to trigger a message via the <code>return_book_1</code> label we&#8217;ll use the <code>StubTrigger</code> interface as follows</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we&#8217;ll want to listen to the output of the message sent to a channel whose <code>destination</code> is <code>returnBook</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Message&lt;?&gt; receivedMessage = messaging.receive('returnBook')</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the received message would pass the following assertions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_2_output_triggered_by_input_4">Scenario 2 (output triggered by input)</h5>
<div class="paragraph">
<p>Since the route is set for you it&#8217;s enough to just send a message to the <code>bookStorage</code> <code>destination</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'bookStorage')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we&#8217;ll want to listen to the output of the message sent to <code>returnBook</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Message&lt;?&gt; receivedMessage = messaging.receive('returnBook')</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the received message would pass the following assertions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_3_input_with_no_output_3">Scenario 3 (input with no output)</h5>
<div class="paragraph">
<p>Since the route is set for you it&#8217;s enough to just send a message to the <code>output</code> destination.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'delete')</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_spring_amqp">Stub Runner Spring AMQP</h3>
<div class="paragraph">
<p>Spring Cloud Contract Verifier Stub Runner&#8217;s messaging module provides an easy way to integrate with Spring AMQP&#8217;s Rabbit Template.
For the provided artifacts it will automatically download the stubs and register the required
routes.</p>
</div>
<div class="paragraph">
<p>The integration tries to work standalone, that is without interaction with a running RabbitMQ message broker.
It expects a <code>RabbitTemplate</code> on the application context and uses it as a spring boot test <code>@SpyBean</code>.
Thus it can use the mockito spy functionality to verify and introspect messages sent by the application.</p>
</div>
<div class="paragraph">
<p>On the message consumer side, it considers all <code>@RabbitListener</code> annotated endpoints as well as all `SimpleMessageListenerContainer`s on the application context.</p>
</div>
<div class="paragraph">
<p>As messages are usually sent to exchanges in AMQP the message contract contains the exchange name as the destination.
Message listeners on the other side are bound to queues. Bindings connect an exchange to a queue.
If message contracts are triggered the Spring AMQP stub runner integration will look for bindings on the application context that match this exchange.
Then it collects the queues from the Spring exchanges and tries to find messages listeners bound to these queues.
The message is triggered to all matching message listeners.</p>
</div>
<div class="sect3">
<h4 id="_adding_it_to_the_project_4">Adding it to the project</h4>
<div class="paragraph">
<p>It&#8217;s enough to have both Spring AMQP and Spring Cloud Contract Stub Runner on the classpath and set the property <code>stubrunner.amqp.enabled=true</code>.
Remember to annotate your test class with <code>@AutoConfigureMessageVerifier</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_examples_4">Examples</h4>
<div class="sect4">
<h5 id="_stubs_structure_4">Stubs structure</h5>
<div class="paragraph">
<p>Let us assume that we have the following Maven repository with a deployed stubs for the
<code>spring-cloud-contract-amqp-test</code> application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">└── .m2
    └── repository
        └── com
            └── example
                └── spring-cloud-contract-amqp-test
                    ├── 0.4.0-SNAPSHOT
                    │   ├── spring-cloud-contract-amqp-test-0.4.0-SNAPSHOT.pom
                    │   ├── spring-cloud-contract-amqp-test-0.4.0-SNAPSHOT-stubs.jar
                    │   └── maven-metadata-local.xml
                    └── maven-metadata-local.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the stubs contain the following structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">├── META-INF
│   └── MANIFEST.MF
└── contracts
    └── shouldProduceValidPersonData.groovy</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following contract:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Contract.make {
    // Human readable description
    description 'Should produce valid person data'
    // Label by means of which the output message can be triggered
    label 'contract-test.person.created.event'
    // input to the contract
    input {
        // the contract will be triggered by a method
        triggeredBy('createPerson()')
    }
    // output message of the contract
    outputMessage {
        // destination to which the output message will be sent
        sentTo 'contract-test.exchange'
        headers {
            header('contentType': 'application/json')
            header('__TypeId__': 'org.springframework.cloud.contract.stubrunner.messaging.amqp.Person')
        }
        // the body of the output message
        body ([
                id: $(consumer(9), producer(regex("[0-9]+"))),
                name: "me"
        ])
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the following Spring configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">stubrunner:
  repositoryRoot: classpath:m2repo/repository/
  ids: org.springframework.cloud.contract.verifier.stubs.amqp:spring-cloud-contract-amqp-test:0.4.0-SNAPSHOT:stubs
  amqp:
    enabled: true
server:
  port: 0</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_triggering_the_message">Triggering the message</h5>
<div class="paragraph">
<p>So to trigger a message using the contract above we&#8217;ll use the <code>StubTrigger</code> interface as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">stubTrigger.trigger("contract-test.person.created.event")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The message has the destination <code>contract-test.exchange</code> so the Spring AMQP stub runner integration looks for bindings related to this exchange.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public Binding binding() {
	return BindingBuilder.bind(new Queue("test.queue")).to(new DirectExchange("contract-test.exchange")).with("#");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The binding definition binds the queue <code>test.queue</code>.
So the following listener definition is a match and is invoked with the contract message.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public SimpleMessageListenerContainer simpleMessageListenerContainer(ConnectionFactory connectionFactory,
																		MessageListenerAdapter listenerAdapter) {
	SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
	container.setConnectionFactory(connectionFactory);
	container.setQueueNames("test.queue");
	container.setMessageListener(listenerAdapter);

	return container;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, the following annotated listener represents a match and would be invoked.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RabbitListener(bindings = @QueueBinding(
		value = @Queue(value = "test.queue"),
		exchange = @Exchange(value = "contract-test.exchange", ignoreDeclarationExceptions = "true")))
public void handlePerson(Person person) {
	this.person = person;
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The message is directly handed over to the <code>onMessage</code> method of the <code>MessageListener</code> associated with the matching <code>SimpleMessageListenerContainer</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_spring_amqp_test_configuration">Spring AMQP Test Configuration</h5>
<div class="paragraph">
<p>In order to avoid that Spring AMQP is trying to connect to a running broker during our tests we configure a mock <code>ConnectionFactory</code>.</p>
</div>
<div class="paragraph">
<p>To disable the mocked ConnectionFactory set the property <code>stubrunner.amqp.mockConnection=false</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">stubrunner:
  amqp:
    mockConnection: false</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_contract_dsl">Contract DSL</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Remember that inside the contract file you have to provide the fully qualified name to
the <code>Contract</code> class and the <code>make</code> static import i.e. <code>org.springframework.cloud.spec.Contract.make { &#8230;&#8203; }</code>.
You can also provide an import to the <code>Contract</code> class <code>import org.springframework.cloud.spec.Contract</code> and then call
  <code>Contract.make { &#8230;&#8203; }</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Contract DSL is written in Groovy, but don&#8217;t be alarmed if you didn&#8217;t use Groovy before. Knowledge of the language is not really needed as our DSL uses only
a tiny subset of it (namely literals, method calls and closures). What&#8217;s more the DSL is designed to be programmer-readable without any knowledge of the DSL itself -
 it&#8217;s statically typed.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Spring Cloud Contract supports defining multiple contracts in a single file!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Contract is present in the <code>spring-cloud-contract-spec</code> module of the Spring Cloud Contract Verifier repository.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at full example of a contract definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'PUT'
		url '/api/12'
		headers {
			header 'Content-Type': 'application/vnd.org.springframework.cloud.contract.verifier.twitter-places-analyzer.v1+json'
		}
		body '''\
		[{
			"created_at": "Sat Jul 26 09:38:57 +0000 2014",
			"id": 492967299297845248,
			"id_str": "492967299297845248",
			"text": "Gonna see you at Warsaw",
			"place":
			{
				"attributes":{},
				"bounding_box":
				{
					"coordinates":
						[[
							[-77.119759,38.791645],
							[-76.909393,38.791645],
							[-76.909393,38.995548],
							[-77.119759,38.995548]
						]],
					"type":"Polygon"
				},
				"country":"United States",
				"country_code":"US",
				"full_name":"Washington, DC",
				"id":"01fbe706f872cb32",
				"name":"Washington",
				"place_type":"city",
				"url": "https://api.twitter.com/1/geo/id/01fbe706f872cb32.json"
			}
		}]
	'''
	}
	response {
		status 200
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Not all features of the DSL are used in example above. If you didn&#8217;t find what you are looking for, please check next paragraphs on this page.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>You can easily compile Contracts to WireMock stubs mapping using standalone maven command: <code>mvn org.springframework.cloud:spring-cloud-contract-maven-plugin:convert</code>.</p>
</div>
</blockquote>
</div>
<div class="sect3">
<h4 id="_limitations_2">Limitations</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Spring Cloud Contract Verifier doesn&#8217;t support XML properly. Please use JSON or help us implement this feature.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The support for the verification of size of JSON arrays is experimental. If you want to turn it on please provide
the value of a system property <code>spring.cloud.contract.verifier.assert.size</code> equal to <code>true</code>. By default this feature is set to
<code>false</code>. You can also provide the <code>assertJsonSize</code> property in the plugin configuration.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Due to the fact that JSON structure can have any form it&#8217;s sometimes impossible to parse it properly when using
the <code>value(consumer(&#8230;&#8203;), producer(&#8230;&#8203;))</code> notation when using that in GString. That&#8217;s why we highly recommend using the
Groovy Map notation.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_common_top_level_elements">Common Top-Level elements</h4>
<div class="sect4">
<h5 id="_description">Description</h5>
<div class="paragraph">
<p>You can add a <code>description</code> to your contract that is nothing else but an arbitrary text. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">		org.springframework.cloud.contract.spec.Contract.make {
			description('''
given:
	An input
when:
	Sth happens
then:
	Output
''')
		}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_name">Name</h5>
<div class="paragraph">
<p>You can provide a name of your contract. Let&#8217;s assume that you&#8217;ve provided a name <code>should register a user</code>.
If you do this then the name of the autogenerated test will be equal to <code>validate_should_register_a_user</code>.
Also the name of the stub will be <code>should_register_a_user.json</code> in case of a WireMock stub.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Please ensure that the name doesn&#8217;t contain any characters that will make the generated test
 not possible to compile. Also remember that if you provide the same name for multiple contracts then your
 autogenerated tests will fail to compile and your generated stubs will override each other.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_ignoring_contracts">Ignoring contracts</h5>
<div class="paragraph">
<p>If you want to ignore a contract you can either set a value of ignored contracts in the plugin configuration
or just set the <code>ignored</code> property on the contract itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	ignored()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_http_top_level_elements">HTTP Top-Level Elements</h4>
<div class="paragraph">
<p>Following methods can be called in the top-level closure of a contract definition. Request and response are mandatory, priority is optional.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	// Definition of HTTP request part of the contract
	// (this can be a valid request or invalid depending
	// on type of contract being specified).
	request {
		//...
	}

	// Definition of HTTP response part of the contract
	// (a service implementing this contract should respond
	// with following response after receiving request
	// specified in "request" part above).
	response {
		//...
	}

	// Contract priority, which can be used for overriding
	// contracts (1 is highest). Priority is optional.
	priority 1
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_request">Request</h4>
<div class="paragraph">
<p>HTTP protocol requires only <strong>method and address</strong> to be specified in a request. The same information is mandatory in request definition of the Contract.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		// HTTP request method (GET/POST/PUT/DELETE).
		method 'GET'

		// Path component of request URL is specified as follows.
		urlPath('/users')
	}

	response {
		//...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is possible to specify whole <code>url</code> instead of just path, but <code>urlPath</code> is the recommended way as it makes the tests <strong>host-independent</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'GET'

		// Specifying `url` and `urlPath` in one contract is illegal.
		url('http://localhost:8888/users')
	}

	response {
		//...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Request may contain <strong>query parameters</strong>, which are specified in a closure nested in a call to <code>urlPath</code> or <code>url</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...

		urlPath('/users') {

			// Each parameter is specified in form
			// `'paramName' : paramValue` where parameter value
			// may be a simple literal or one of matcher functions,
			// all of which are used in this example.
			queryParameters {

				// If a simple literal is used as value
				// default matcher function is used (equalTo)
				parameter 'limit': 100

				// `equalTo` function simply compares passed value
				// using identity operator (==).
				parameter 'filter': equalTo("email")

				// `containing` function matches strings
				// that contains passed substring.
				parameter 'gender': value(consumer(containing("[mf]")), producer('mf'))

				// `matching` function tests parameter
				// against passed regular expression.
				parameter 'offset': value(consumer(matching("[0-9]+")), producer(123))

				// `notMatching` functions tests if parameter
				// does not match passed regular expression.
				parameter 'loginStartsWith': value(consumer(notMatching(".{0,2}")), producer(3))
			}
		}

		//...
	}

	response {
		//...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It may contain additional <strong>request headers</strong>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...

		// Each header is added in form `'Header-Name' : 'Header-Value'`.
		// there are also some helper methods
		headers {
			header 'key': 'value'
			contentType(applicationJson())
		}

		//...
	}

	response {
		//...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and a <strong>request body</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...

		// Currently only JSON format of request body is supported.
		// Format will be determined from a header or body's content.
		body '''{ "login" : "john", "name": "John The Contract" }'''
	}

	response {
		//...
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_response">Response</h4>
<div class="paragraph">
<p>Minimal response must contain <strong>HTTP status code</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...
	}
	response {
		// Status code sent by the server
		// in response to request specified above.
		status 200
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Besides status response may contain <strong>headers</strong> and <strong>body</strong>, which are specified the same way as in the request (see previous paragraph).</p>
</div>
</div>
<div class="sect3">
<h4 id="_dynamic_properties">Dynamic properties</h4>
<div class="paragraph">
<p>The contract can contain some dynamic properties - timestamps / ids etc. You don&#8217;t want to enforce the consumers to stub their
clocks to always return the same value of time so that it gets matched by the stub. That&#8217;s why we allow you to provide the dynamic
parts in your contracts in two ways. One is to pass them directly in the
body and one to set them in a separate section called <code>testMatchers</code> and <code>stubMatchers</code>.</p>
</div>
<div class="sect4">
<h5 id="_dynamic_properties_inside_the_body">Dynamic properties inside the body</h5>
<div class="paragraph">
<p>You can set the properties inside the body either via the <code>value</code> method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">value(consumer(...), producer(...))
value(c(...), p(...))
value(stub(...), test(...))
value(client(...), server(...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>or if you&#8217;re using the Groovy map notation for body you can use the <code>$()</code> method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">$(consumer(...), producer(...))
$(c(...), p(...))
$(stub(...), test(...))
$(client(...), server(...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of the aforementioned approaches are equal. That means that <code>stub</code> and <code>client</code> methods are aliases over the <code>consumer</code>
method. Let&#8217;s take a closer look at what we can do with those values in the subsequent sections.</p>
</div>
<div class="sect5">
<h6 id="_regular_expressions">Regular expressions</h6>
<div class="paragraph">
<p>You can use regular expressions to write your requests in Contract DSL. It is particularly useful when you want to indicate that a given response
should be provided for requests that follow a given pattern. Also, you can use it when you need to use patterns and not exact values both
for your test and your server side tests.</p>
</div>
<div class="paragraph">
<p>Please see the example below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method('GET')
		url $(consumer(~/\/[0-9]{2}/), producer('/12'))
	}
	response {
		status 200
		body(
				id: $(anyNumber()),
				surname: $(
						consumer('Kowalsky'),
						producer(regex('[a-zA-Z]+'))
				),
				name: 'Jan',
				created: $(consumer('2014-02-02 12:23:43'), producer(execute('currentDate(it)'))),
				correlationId: value(consumer('5d1f9fef-e0dc-4f3d-a7e4-72d2220dd827'),
						producer(regex('[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'))
				)
		)
		headers {
			header 'Content-Type': 'text/plain'
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also provide only one side of the communication using a regular expression. If you do that then automatically we&#8217;ll
provide the generated string that matches the provided regular expression. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'PUT'
		url value(consumer(regex('/foo/[0-9]{5}')))
		body([
			requestElement: $(consumer(regex('[0-9]{5}')))
		])
		headers {
			header('header', $(consumer(regex('application\\/vnd\\.fraud\\.v1\\+json;.*'))))
		}
	}
	response {
		status 200
		body([
			responseElement: $(producer(regex('[0-9]{7}')))
		])
		headers {
			contentType("application/vnd.fraud.v1+json")
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example for request and response the opposite side of the communication will have the respective data generated.</p>
</div>
<div class="paragraph">
<p>Spring Cloud Contract comes with a series of predefined regular expressions that you can use in your contracts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">protected static final Pattern TRUE_OR_FALSE = Pattern.compile(/(true|false)/)
protected static final Pattern ONLY_ALPHA_UNICODE = Pattern.compile(/[\p{L}]*/)
protected static final Pattern NUMBER = Pattern.compile('-?\\d*(\\.\\d+)?')
protected static final Pattern IP_ADDRESS = Pattern.compile('([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])')
protected static final Pattern HOSTNAME_PATTERN = Pattern.compile('((http[s]?|ftp):\\/)\\/?([^:\\/\\s]+)(:[0-9]{1,5})?')
protected static final Pattern EMAIL = Pattern.compile('[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}');
protected static final Pattern URL = Pattern.compile('((www\\.|(http|https|ftp|news|file)+\\:\\/\\/)[_.a-z0-9-]+\\.[a-z0-9\\/_:@=.+?,##%&amp;~-]*[^.|\\\'|\\# |!|\\(|?|,| |&gt;|&lt;|;|\\)])')
protected static final Pattern UUID = Pattern.compile('[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}')
protected static final Pattern ANY_DATE = Pattern.compile('(\\d\\d\\d\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])')
protected static final Pattern ANY_DATE_TIME = Pattern.compile('([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])')
protected static final Pattern ANY_TIME = Pattern.compile('(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])')

String onlyAlphaUnicode() {
	return ONLY_ALPHA_UNICODE.pattern()
}

String number() {
	return NUMBER.pattern()
}

String anyBoolean() {
	return TRUE_OR_FALSE.pattern()
}

String ipAddress() {
	return IP_ADDRESS.pattern()
}

String hostname() {
	return HOSTNAME_PATTERN.pattern()
}

String email() {
	return EMAIL.pattern()
}

String url() {
	return URL.pattern()
}

String uuid(){
	return UUID.pattern()
}

String isoDate() {
	return ANY_DATE.pattern()
}

String isoDateTime() {
	return ANY_DATE_TIME.pattern()
}

String isoTime() {
	return ANY_TIME.pattern()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>so in your contract you can use it like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Contract dslWithOptionalsInString = Contract.make {
	priority 1
	request {
		method POST()
		url '/users/password'
		headers {
			contentType(applicationJson())
		}
		body(
				email: $(consumer(optional(regex(email()))), producer('abc@abc.com')),
				callback_url: $(consumer(regex(hostname())), producer('http://partners.com'))
		)
	}
	response {
		status 404
		headers {
			contentType(applicationJson())
		}
		body(
				code: value(consumer("123123"), producer(optional("123123"))),
				message: "User not found by email = [${value(producer(regex(email())), consumer('not.existing@user.com'))}]"
		)
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_passing_optional_parameters">Passing optional parameters</h6>
<div class="paragraph">
<p>It is possible to provide optional parameters in your contract. It&#8217;s only possible to have optional parameter for the:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>STUB</em> side of the Request</p>
</li>
<li>
<p><em>TEST</em> side of the Response</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	priority 1
	request {
		method 'POST'
		url '/users/password'
		headers {
			contentType(applicationJson())
		}
		body(
				email: $(consumer(optional(regex(email()))), producer('abc@abc.com')),
				callback_url: $(consumer(regex(hostname())), producer('http://partners.com'))
		)
	}
	response {
		status 404
		headers {
			header 'Content-Type': 'application/json'
		}
		body(
				code: value(consumer("123123"), producer(optional("123123")))
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By wrapping a part of the body with the <code>optional()</code> method you are in fact creating a regular expression that should be present 0 or more times.</p>
</div>
<div class="paragraph">
<p>That way for the example above the following test would be generated if you pick Spock:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">"""
 given:
  def request = given()
    .header("Content-Type", "application/json")
    .body('''{"email":"abc@abc.com","callback_url":"http://partners.com"}''')

 when:
  def response = given().spec(request)
    .post("/users/password")

 then:
  response.statusCode == 404
  response.header('Content-Type')  == 'application/json'
 and:
  DocumentContext parsedJson = JsonPath.parse(response.body.asString())
  assertThatJson(parsedJson).field("code").matches("(123123)?")
"""</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the following stub:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">'''
{
  "request" : {
    "url" : "/users/password",
    "method" : "POST",
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.email =~ /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,4})?/)]"
    }, {
      "matchesJsonPath" : "$[?(@.callback_url =~ /((http[s]?|ftp):\\\\/)\\\\/?([^:\\\\/\\\\s]+)(:[0-9]{1,5})?/)]"
    } ],
    "headers" : {
      "Content-Type" : {
        "equalTo" : "application/json"
      }
    }
  },
  "response" : {
    "status" : 404,
    "body" : "{\\"code\\":\\"123123\\",\\"message\\":\\"User not found by email == [not.existing@user.com]\\"}",
    "headers" : {
      "Content-Type" : "application/json"
    }
  },
  "priority" : 1
}
'''</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_executing_custom_methods_on_server_side">Executing custom methods on server side</h6>
<div class="paragraph">
<p>It is also possible to define a method call to be executed on the server side during the test. Such a method can be added to the class defined as "baseClassForTests"
in the configuration. Example:</p>
</div>
<div class="paragraph">
<p><strong>Contract</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'PUT'
		url $(consumer(regex('^/api/[0-9]{2}$')), producer('/api/12'))
		headers {
			header 'Content-Type': 'application/json'
		}
		body '''\
				[{
					"text": "Gonna see you at Warsaw"
				}]
			'''
	}
	response {
		body (
				path: $(consumer('/api/12'), producer(regex('^/api/[0-9]{2}$'))),
				correlationId: $(consumer('1223456'), producer(execute('isProperCorrelationId($it)')))
		)
		status 200
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Base class</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">abstract class BaseMockMvcSpec extends Specification {

	def setup() {
		RestAssuredMockMvc.standaloneSetup(new PairIdController())
	}

	void isProperCorrelationId(Integer correlationId) {
		assert correlationId == 123456
	}

	void isEmpty(String value) {
		assert value == null
	}

}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
You can&#8217;t use both a String and <code>execute</code> to perform concatenation. E.g. calling
<code>header('Authorization', 'Bearer ' + execute('authToken()'))</code> will lead to improper results.
To make this work just call <code>header('Authorization', execute('authToken()'))</code> and ensure that
the <code>authToken()</code> method returns everything that you need.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_referencing_request_from_response">Referencing request from response</h5>
<div class="paragraph">
<p>The best situation is to provide fixed values but sometimes you need to reference a request in your response.
In order to do this you can profit from the <code>fromRequest()</code> method that allows you to reference a bunch
of elements from the HTTP request. You can use the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fromRequest().url()</code> - return the request URL</p>
</li>
<li>
<p><code>fromRequest().query(String key)</code> - return the first query parameter with a given name</p>
</li>
<li>
<p><code>fromRequest().query(String key, int index)</code> - return the nth query parameter with a given name</p>
</li>
<li>
<p><code>fromRequest().header(String key)</code> - return the first header with a given name</p>
</li>
<li>
<p><code>fromRequest().header(String key, int index)</code> - return the nth header with a given name</p>
</li>
<li>
<p><code>fromRequest().body()</code> - return the full request body</p>
</li>
<li>
<p><code>fromRequest().body(String jsonPath)</code> - return the element from the request that matches the JSON Path</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at the following contract</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Contract contractDsl = Contract.make {
	request {
		method 'GET'
		url('/api/v1/xxxx') {
			queryParameters {
				parameter("foo", "bar")
				parameter("foo", "bar2")
			}
		}
		headers {
			header(authorization(), "secret")
			header(authorization(), "secret2")
		}
		body(foo: "bar", baz: 5)
	}
	response {
		status 200
		headers {
			header(authorization(), "foo ${fromRequest().header(authorization())} bar")
		}
		body(
				url: fromRequest().url(),
				param: fromRequest().query("foo"),
				paramIndex: fromRequest().query("foo", 1),
				authorization: fromRequest().header("Authorization"),
				authorization2: fromRequest().header("Authorization", 1),
				fullBody: fromRequest().body(),
				responseFoo: fromRequest().body('$.foo'),
				responseBaz: fromRequest().body('$.baz'),
				responseBaz2: "Bla bla ${fromRequest().body('$.foo')} bla bla"
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running a JUnit test generation will lead in creation of a test looking more or less like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// given:
 MockMvcRequestSpecification request = given()
   .header("Authorization", "secret")
   .header("Authorization", "secret2")
   .body("{\"foo\":\"bar\",\"baz\":5}");

// when:
 ResponseOptions response = given().spec(request)
   .queryParam("foo","bar")
   .queryParam("foo","bar2")
   .get("/api/v1/xxxx");

// then:
 assertThat(response.statusCode()).isEqualTo(200);
 assertThat(response.header("Authorization")).isEqualTo("foo secret bar");
// and:
 DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
 assertThatJson(parsedJson).field("url").isEqualTo("/api/v1/xxxx");
 assertThatJson(parsedJson).field("fullBody").isEqualTo("{\"foo\":\"bar\",\"baz\":5}");
 assertThatJson(parsedJson).field("paramIndex").isEqualTo("bar2");
 assertThatJson(parsedJson).field("responseFoo").isEqualTo("bar");
 assertThatJson(parsedJson).field("authorization2").isEqualTo("secret2");
 assertThatJson(parsedJson).field("responseBaz").isEqualTo(5);
 assertThatJson(parsedJson).field("responseBaz2").isEqualTo("Bla bla bar bla bla");
 assertThatJson(parsedJson).field("param").isEqualTo("bar");
 assertThatJson(parsedJson).field("authorization").isEqualTo("secret");</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see elements from the request have been properly referenced in the response.</p>
</div>
<div class="paragraph">
<p>The generated WireMock stub will look more or less like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "request" : {
    "urlPath" : "/api/v1/xxxx",
    "method" : "POST",
    "headers" : {
      "Authorization" : {
        "equalTo" : "secret2"
      }
    },
    "queryParameters" : {
      "foo" : {
        "equalTo" : "bar2"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.baz == 5)]"
    }, {
      "matchesJsonPath" : "$[?(@.foo == 'bar')]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\"url\":\"{{{request.url}}}\",\"param\":\"{{{request.query.foo.[0]}}}\",\"paramIndex\":\"{{{request.query.foo.[1]}}}\",\"authorization\":\"{{{request.headers.Authorization.[0]}}}\",\"authorization2\":\"{{{request.headers.Authorization.[1]}}}\",\"fullBody\":\"{{{escapejsonbody}}}\",\"responseFoo\":\"{{{jsonpath this '$.foo'}}}\",\"responseBaz\":{{{jsonpath this '$.baz'}}} ,\"responseBaz2\":\"Bla bla {{{jsonpath this '$.foo'}}} bla bla\"}",
    "headers" : {
      "Authorization" : "{{{request.headers.Authorization.[0]}}}"
    },
    "transformers" : [ "response-template" ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So sending a request as the one presented in the <code>request</code> part of the contract will lead in sending the following
response body</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "url" : "/api/v1/xxxx?foo=bar&amp;foo=bar2",
  "param" : "bar",
  "paramIndex" : "bar2",
  "authorization" : "secret",
  "authorization2" : "secret2",
  "fullBody" : "{\"foo\":\"bar\",\"baz\":5}",
  "responseFoo" : "bar",
  "responseBaz" : 5,
  "responseBaz2" : "Bla bla bar bla bla"
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
This feature will work only with WireMock having version greater or equal to 2.5.1. We&#8217;re using WireMock&#8217;s
<code>response-template</code> response transformer. It&#8217;s using Handlebars to convert the Mustache <code>{{{ }}}</code> templates into
proper values. Additionally we&#8217;re registering 2 helper functions. <code>escapejsonbody</code> - that escapes the request
body in a format that can be embedded in a JSON. Another is <code>jsonpath</code> that for a given parameter knows how to
find an object in the request body.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_dynamic_properties_in_matchers_sections">Dynamic properties in matchers sections</h5>
<div class="paragraph">
<p>If you&#8217;ve been working with <a href="https://docs.pact.io/">Pact</a> this might seem familiar. Quite a few users
are used to having a separation between the body and setting dynamic parts of your contract.</p>
</div>
<div class="paragraph">
<p>That&#8217;s why you can profit from two separate sections. One is called <code>stubMatchers</code> where you can
define the dynamic values that should end up in a stub. You can set it in the <code>request</code> or <code>inputMessage</code>
part of your contract. The other is called <code>testMatchers</code> which is present in the <code>response</code> or
<code>outputMessage</code> side of the contract.</p>
</div>
<div class="paragraph">
<p>Currently we support only JSON Path based matchers with the following matching possibilities.
For <code>stubMatchers</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>byEquality()</code> - the value taken from the response via the provided JSON Path needs
to be equal to the provided value in the contract</p>
</li>
<li>
<p><code>byRegex(&#8230;&#8203;)</code> - the value taken from the response via the provided JSON Path needs
to match the regex</p>
</li>
<li>
<p><code>byDate()</code> - the value taken from the response via the provided JSON Path needs to
match the regex for ISO Date</p>
</li>
<li>
<p><code>byTimestamp()</code> - the value taken from the response via the provided JSON Path needs
to match the regex for ISO DateTime</p>
</li>
<li>
<p><code>byTime()</code> - the value taken from the response via the provided JSON Path needs to
match the regex for ISO Time</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For <code>testMatchers</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>byEquality()</code> - the value taken from the response via the provided JSON Path needs
to be equal to the provided value in the contract</p>
</li>
<li>
<p><code>byRegex(&#8230;&#8203;)</code> - the value taken from the response via the provided JSON Path needs
to match the regex</p>
</li>
<li>
<p><code>byDate()</code> - the value taken from the response via the provided JSON Path needs to
match the regex for ISO Date</p>
</li>
<li>
<p><code>byTimestamp()</code> - the value taken from the response via the provided JSON Path needs
to match the regex for ISO DateTime</p>
</li>
<li>
<p><code>byTime()</code> - the value taken from the response via the provided JSON Path needs to
match the regex for ISO Time</p>
</li>
<li>
<p><code>byType()</code> - the value taken from the response via the provided JSON Path needs to
be of the same type as the type defined in the body of the response in the contract.
<code>byType</code> can take a closure where you can set <code>minOccurrence</code> and <code>maxOccurrence</code>.
That way you can assert on the size of the collection.</p>
</li>
<li>
<p><code>byCommand(&#8230;&#8203;)</code> - the value taken from the response via the provided JSON Path will be
passed as an input to the custom method that you&#8217;re providing. E.g. <code>byCommand('foo($it)')</code>
will result in calling a <code>foo</code> method to which the value matching the JSON Path will get
 passed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Contract contractDsl = Contract.make {
	request {
		method 'GET'
		urlPath '/get'
		body([
				duck: 123,
				alpha: "abc",
				number: 123,
				aBoolean: true,
				date: "2017-01-01",
				dateTime: "2017-01-01T01:23:45",
				time: "01:02:34",
				valueWithoutAMatcher: "foo",
				valueWithTypeMatch: "string"
		])
		stubMatchers {
			jsonPath('$.duck', byRegex("[0-9]{3}"))
			jsonPath('$.duck', byEquality())
			jsonPath('$.alpha', byRegex(onlyAlphaUnicode()))
			jsonPath('$.alpha', byEquality())
			jsonPath('$.number', byRegex(number()))
			jsonPath('$.aBoolean', byRegex(anyBoolean()))
			jsonPath('$.date', byDate())
			jsonPath('$.dateTime', byTimestamp())
			jsonPath('$.time', byTime())
		}
		headers {
			contentType(applicationJson())
		}
	}
	response {
		status 200
		body([
				duck: 123,
				alpha: "abc",
				number: 123,
				aBoolean: true,
				date: "2017-01-01",
				dateTime: "2017-01-01T01:23:45",
				time: "01:02:34",
				valueWithoutAMatcher: "foo",
				valueWithTypeMatch: "string",
				valueWithMin: [
					1,2,3
				],
				valueWithMax: [
					1,2,3
				],
				valueWithMinMax: [
					1,2,3
				],
				valueWithMinEmpty: [],
				valueWithMaxEmpty: [],
		])
		testMatchers {
			// asserts the jsonpath value against manual regex
			jsonPath('$.duck', byRegex("[0-9]{3}"))
			// asserts the jsonpath value against the provided value
			jsonPath('$.duck', byEquality())
			// asserts the jsonpath value against some default regex
			jsonPath('$.alpha', byRegex(onlyAlphaUnicode()))
			jsonPath('$.alpha', byEquality())
			jsonPath('$.number', byRegex(number()))
			jsonPath('$.aBoolean', byRegex(anyBoolean()))
			// asserts vs inbuilt time related regex
			jsonPath('$.date', byDate())
			jsonPath('$.dateTime', byTimestamp())
			jsonPath('$.time', byTime())
			// asserts that the resulting type is the same as in response body
			jsonPath('$.valueWithTypeMatch', byType())
			jsonPath('$.valueWithMin', byType {
				// results in verification of size of array (min 1)
				minOccurrence(1)
			})
			jsonPath('$.valueWithMax', byType {
				// results in verification of size of array (max 3)
				maxOccurrence(3)
			})
			jsonPath('$.valueWithMinMax', byType {
				// results in verification of size of array (min 1 &amp; max 3)
				minOccurrence(1)
				maxOccurrence(3)
			})
			jsonPath('$.valueWithMinEmpty', byType {
				// results in verification of size of array (min 0)
				minOccurrence(0)
			})
			jsonPath('$.valueWithMaxEmpty', byType {
				// results in verification of size of array (max 0)
				maxOccurrence(0)
			})
			// will execute a method `assertThatValueIsANumber`
			jsonPath('$.duck', byCommand('assertThatValueIsANumber($it)'))
		}
		headers {
			contentType(applicationJson())
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example we&#8217;re providing the dynamic portions of the contract in the matchers sections.
 For the request part you can see that for all fields but <code>valueWithoutAMatcher</code> we&#8217;re setting
 explicitly the values of regular expressions we&#8217;d like the stub to contain. For the <code>valueWithoutAMatcher</code>
 the verification will take place in the same way as without the usage of matchers - the test
 will perform an equality check in this case.</p>
</div>
<div class="paragraph">
<p>For the response side in the <code>testMatchers</code> section we&#8217;re defining all the dynamic parts
 in a similar manner. The only difference is that we have the <code>byType</code> matchers too. In that
 case we&#8217;re checking 4 fields in the way that we&#8217;re verifying whether the response from the test
 has a value whose JSON path matching the given field is of the same type as the one defined in the response body and:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>for <code>$.valueWithTypeMatch</code> - we&#8217;re just checking the whether the type is the same</p>
</li>
<li>
<p>for <code>$.valueWithMin</code> - we&#8217;re checking the type and assert if the size is greater or equal to the min occurrence</p>
</li>
<li>
<p>for <code>$.valueWithMax</code> - we&#8217;re checking the type and assert if the size is smaller or equal to the max occurrence</p>
</li>
<li>
<p>for <code>$.valueWithMinMax</code> - we&#8217;re checking the type and assert if the size is between the min and max occurrence</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The resulting test would look more or less like this (note that we&#8217;re separating the autogenerated
assertions and the one from matchers with an <code>and</code> section):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// given:
 MockMvcRequestSpecification request = given()
   .header("Content-Type", "application/json")
   .body("{\"duck\":123,\"alpha\":\"abc\",\"number\":123,\"aBoolean\":true,\"date\":\"2017-01-01\",\"dateTime\":\"2017-01-01T01:23:45\",\"time\":\"01:02:34\",\"valueWithoutAMatcher\":\"foo\",\"valueWithTypeMatch\":\"string\"}");

// when:
 ResponseOptions response = given().spec(request)
   .get("/get");

// then:
 assertThat(response.statusCode()).isEqualTo(200);
 assertThat(response.header("Content-Type")).matches("application/json.*");
// and:
 DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
 assertThatJson(parsedJson).field("valueWithoutAMatcher").isEqualTo("foo");
// and:
 assertThat(parsedJson.read("$.duck", String.class)).matches("[0-9]{3}");
 assertThat(parsedJson.read("$.duck", Integer.class)).isEqualTo(123);
 assertThat(parsedJson.read("$.alpha", String.class)).matches("[\\p{L}]*");
 assertThat(parsedJson.read("$.alpha", String.class)).isEqualTo("abc");
 assertThat(parsedJson.read("$.number", String.class)).matches("-?\\d*(\\.\\d+)?");
 assertThat(parsedJson.read("$.aBoolean", String.class)).matches("(true|false)");
 assertThat(parsedJson.read("$.date", String.class)).matches("(\\d\\d\\d\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])");
 assertThat(parsedJson.read("$.dateTime", String.class)).matches("([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])");
 assertThat(parsedJson.read("$.time", String.class)).matches("(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])");
 assertThat((Object) parsedJson.read("$.valueWithTypeMatch")).isInstanceOf(java.lang.String.class);
 assertThat((Object) parsedJson.read("$.valueWithMin")).isInstanceOf(java.util.List.class);
 assertThat(parsedJson.read("$.valueWithMin", java.util.Collection.class)).hasSizeGreaterThanOrEqualTo(1);
 assertThat((Object) parsedJson.read("$.valueWithMax")).isInstanceOf(java.util.List.class);
 assertThat(parsedJson.read("$.valueWithMax", java.util.Collection.class)).hasSizeLessThanOrEqualTo(3);
 assertThat((Object) parsedJson.read("$.valueWithMinMax")).isInstanceOf(java.util.List.class);
 assertThat(parsedJson.read("$.valueWithMinMax", java.util.Collection.class)).hasSizeBetween(1, 3);
 assertThat((Object) parsedJson.read("$.valueWithMinEmpty")).isInstanceOf(java.util.List.class);
 assertThat(parsedJson.read("$.valueWithMinEmpty", java.util.Collection.class)).hasSizeGreaterThanOrEqualTo(0);
 assertThat((Object) parsedJson.read("$.valueWithMaxEmpty")).isInstanceOf(java.util.List.class);
 assertThat(parsedJson.read("$.valueWithMaxEmpty", java.util.Collection.class)).hasSizeLessThanOrEqualTo(0);
 assertThatValueIsANumber(parsedJson.read("$.duck"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the WireMock stub like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">				'''
{
  "request" : {
    "urlPath" : "/get",
    "method" : "GET",
    "headers" : {
      "Content-Type" : {
        "matches" : "application/json.*"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.valueWithoutAMatcher == 'foo')]"
    }, {
      "matchesJsonPath" : "$[?(@.valueWithTypeMatch == 'string')]"
    }, {
      "matchesJsonPath" : "$.list.some.nested[?(@.anothervalue == 4)]"
    }, {
      "matchesJsonPath" : "$.list.someother.nested[?(@.anothervalue == 4)]"
    }, {
      "matchesJsonPath" : "$.list.someother.nested[?(@.json == 'with value')]"
    }, {
      "matchesJsonPath" : "$[?(@.duck =~ /([0-9]{3})/)]"
    }, {
      "matchesJsonPath" : "$[?(@.duck == 123)]"
    }, {
      "matchesJsonPath" : "$[?(@.alpha =~ /([\\\\p{L}]*)/)]"
    }, {
      "matchesJsonPath" : "$[?(@.alpha == 'abc')]"
    }, {
      "matchesJsonPath" : "$[?(@.number =~ /(-?\\\\d*(\\\\.\\\\d+)?)/)]"
    }, {
      "matchesJsonPath" : "$[?(@.aBoolean =~ /((true|false))/)]"
    }, {
      "matchesJsonPath" : "$[?(@.date =~ /((\\\\d\\\\d\\\\d\\\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))/)]"
    }, {
      "matchesJsonPath" : "$[?(@.dateTime =~ /(([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9]))/)]"
    }, {
      "matchesJsonPath" : "$[?(@.time =~ /((2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9]))/)]"
    }, {
      "matchesJsonPath" : "$.list.some.nested[?(@.json =~ /(.*)/)]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\\"duck\\":123,\\"alpha\\":\\"abc\\",\\"number\\":123,\\"aBoolean\\":true,\\"date\\":\\"2017-01-01\\",\\"dateTime\\":\\"2017-01-01T01:23:45\\",\\"time\\":\\"01:02:34\\",\\"valueWithoutAMatcher\\":\\"foo\\",\\"valueWithTypeMatch\\":\\"string\\",\\"valueWithMin\\":[1,2,3],\\"valueWithMax\\":[1,2,3],\\"valueWithMinMax\\":[1,2,3]}",
    "headers" : {
      "Content-Type" : "application/json"
    }
  }
}
'''</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jax_rs_support">JAX-RS support</h4>
<div class="paragraph">
<p>We support JAX-RS 2 Client API. Base class needs to define <code>protected WebTarget webTarget</code> and server initialization, right now the only option how to test JAX-RS API is to start a web server.</p>
</div>
<div class="paragraph">
<p>Request with a body needs to have a content type set otherwise <code>application/octet-stream</code> is going to be used.</p>
</div>
<div class="paragraph">
<p>In order to use JAX-RS mode, use the following settings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">testMode === 'JAXRSCLIENT'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example of a test API generated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">'''
 // when:
  Response response = webTarget
    .path("/users")
    .queryParam("limit", "10")
    .queryParam("offset", "20")
    .queryParam("filter", "email")
    .queryParam("sort", "name")
    .queryParam("search", "55")
    .queryParam("age", "99")
    .queryParam("name", "Denis.Stepanov")
    .queryParam("email", "bob@email.com")
    .request()
    .method("GET");

  String responseAsString = response.readEntity(String.class);

 // then:
  assertThat(response.getStatus()).isEqualTo(200);
 // and:
  DocumentContext parsedJson = JsonPath.parse(responseAsString);
  assertThatJson(parsedJson).field("property1").isEqualTo("a");
'''</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_async_support">Async support</h4>
<div class="paragraph">
<p>If you&#8217;re using asynchronous communication on the server side (your controllers are returning
<code>Callable</code>, <code>DeferredResult</code> etc. then inside your contract you have to provide in the <code>response</code>
section a <code>async()</code> method. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method GET()
        url '/get'
    }
    response {
        status 200
        body 'Passed'
        async()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_working_with_context_paths">Working with Context Paths</h4>
<div class="paragraph">
<p>Spring Cloud Contract supports context paths.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
The only thing that changes in order to fully support context paths is the switch
on the <strong>PRODUCER</strong> side. The autogenerated tests need to be using the <strong>EXPLICIT</strong> mode.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The consumer side remains untouched, in order for the generated test to pass you have to switch the <strong>EXPLICIT</strong> mode.</p>
</div>
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
    &lt;configuration&gt;
        &lt;testMode&gt;EXPLICIT&lt;/testMode&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">contracts {
		testMode = 'EXPLICIT'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That way you&#8217;ll generate a test that <strong>DOES NOT</strong> use MockMvc. It means that you&#8217;re generating
real requests and you need to setup your generated test&#8217;s base class to work on a real socket.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s imagine the following contract:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'GET'
		url '/my-context-path/url'
	}
	response {
		status 200
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example of how to set up a base class and Rest Assured for everything to work correctly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import com.jayway.restassured.RestAssured;
import org.junit.Before;
import org.springframework.boot.context.embedded.LocalServerPort;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest(classes = ContextPathTestingBaseClass.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class ContextPathTestingBaseClass {

	@LocalServerPort int port;

	@Before
	public void setup() {
		RestAssured.baseURI = "http://localhost";
		RestAssured.port = this.port;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That way all:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>all your requests in the autogenerated tests will be sent to the real endpoint with your context path included (e.g. <code>/my-context-path/url</code>)</p>
</li>
<li>
<p>your contracts reflect that you have a context path, thus your generated stubs will also
have that information (e.g. in the stubs you&#8217;ll see that you have too call <code>/my-context-path/url</code>)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_messaging_top_level_elements">Messaging Top-Level Elements</h4>
<div class="paragraph">
<p>The DSL for messaging looks a little bit different than the one that focuses on HTTP.</p>
</div>
<div class="sect4">
<h5 id="_output_triggered_by_a_method">Output triggered by a method</h5>
<div class="paragraph">
<p>The output message can be triggered by calling a method (e.g. a Scheduler was started and a message was sent)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">def dsl = Contract.make {
	// Human readable description
	description 'Some description'
	// Label by means of which the output message can be triggered
	label 'some_label'
	// input to the contract
	input {
		// the contract will be triggered by a method
		triggeredBy('bookReturnedTriggered()')
	}
	// output message of the contract
	outputMessage {
		// destination to which the output message will be sent
		sentTo('output')
		// the body of the output message
		body('''{ "bookName" : "foo" }''')
		// the headers of the output message
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the output message will be sent to <code>output</code> if a method called <code>bookReturnedTriggered</code> will be executed. In the message <strong>publisher&#8217;s</strong> side
we will generate a test that will call that method to trigger the message. On the <strong>consumer</strong> side you can use the <code>some_label</code> to trigger the message.</p>
</div>
</div>
<div class="sect4">
<h5 id="_output_triggered_by_a_message">Output triggered by a message</h5>
<div class="paragraph">
<p>The output message can be triggered by receiving a message.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">def dsl = Contract.make {
	description 'Some Description'
	label 'some_label'
	// input is a message
	input {
		// the message was received from this destination
		messageFrom('input')
		// has the following body
		messageBody([
		        bookName: 'foo'
		])
		// and the following headers
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('output')
		body([
		        bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the output message will be sent to <code>output</code> if a proper message will be received on the <code>input</code> destination. In the message <strong>publisher&#8217;s</strong> side
we will generate a test that will send the input message to the defined destination. On the <strong>consumer</strong> side you can either send a message to the input
destination or use the <code>some_label</code> to trigger the message.</p>
</div>
</div>
<div class="sect4">
<h5 id="_consumer_producer">Consumer / Producer</h5>
<div class="paragraph">
<p>In HTTP you have a notion of <code>client</code>/<code>stub and `server</code>/<code>test</code> notation. You can use them also in messaging but we&#8217;re providing also the <code>consumer</code> and <code>produer</code> methods
as presented below (note you can use either <code>$</code> or <code>value</code> methods to provide <code>consumer</code> and <code>producer</code> parts)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'some_label'
	input {
		messageFrom value(consumer('jms:output'), producer('jms:input'))
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo $(consumer('jms:input'), producer('jms:output'))
		body([
				bookName: 'foo'
		])
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_contracts_in_one_file">Multiple contracts in one file</h4>
<div class="paragraph">
<p>It&#8217;s possible to define multiple contracts in one file. An example of such a contract can look like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import org.springframework.cloud.contract.spec.Contract

[
        Contract.make {
            name("should post a user")
            request {
                method 'POST'
                url('/users/1')
            }
            response {
                status 200
            }
        },
        Contract.make {
            request {
                method 'POST'
                url('/users/2')
            }
            response {
                status 200
            }
        }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example one contract has the <code>name</code> field and the other doesn&#8217;t. This will lead to generation of
two tests that will look more or less like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package org.springframework.cloud.contract.verifier.tests.com.hello;

import com.example.TestBase;
import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import com.jayway.restassured.module.mockmvc.specification.MockMvcRequestSpecification;
import com.jayway.restassured.response.ResponseOptions;
import org.junit.Test;

import static com.jayway.restassured.module.mockmvc.RestAssuredMockMvc.*;
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson;
import static org.assertj.core.api.Assertions.assertThat;

public class V1Test extends TestBase {

	@Test
	public void validate_should_post_a_user() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.post("/users/1");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
	}

	@Test
	public void validate_withList_1() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.post("/users/2");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that for the contract that has the <code>name</code> field the generated test method is named
<code>validate_should_post_a_user</code>. For the one that doesn&#8217;t have the name it&#8217;s called
<code>validate_withList_1</code>. It corresponds to the name of the file <code>WithList.groovy</code> and the
index of the contract in the list.</p>
</div>
<div class="paragraph">
<p>The generated stubs will look like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>should post a user.json
1_WithList.json</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see the first file got the <code>name</code> parameter from the contract. The second
got the name of the contract file <code>WithList.groovy</code> prefixed with the index (in this case
contract had index <code>1</code> in the list of contracts in the file).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
As you can see it&#8217;s much better if you name your contracts since then your tests
 are far more meaningful.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_customization">Customization</h3>
<div class="sect3">
<h4 id="_extending_the_dsl">Extending the DSL</h4>
<div class="paragraph">
<p>It is possible to provide your own functions to the DSL. The key requirement for this
feature was to maintain the static compatibility. Below you will be able to see an example
of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>creation of a JAR with reusable classes</p>
</li>
<li>
<p>referencing of these classes in the DSLs</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The full example can be found <a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples">here</a>.</p>
</div>
<div class="sect4">
<h5 id="_common_jar">Common JAR</h5>
<div class="paragraph">
<p>Below you can find three classes that we will reuse in the DSLs.</p>
</div>
<div class="paragraph">
<p><strong>PatternUtils</strong> contains functions used by both the <strong>consumer</strong> and the <strong>producer</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.example;

import java.util.regex.Pattern;

/**
 * If you want to use {@link Pattern} directly in your tests
 * then you can create a class resembling this one. It can
 * contain all the {@link Pattern} you want to use in the DSL.
 *
 * &lt;pre&gt;
 * {@code
 * request {
 *     body(
 *         [ age: $(c(PatternUtils.oldEnough()))]
 *     )
 * }
 * &lt;/pre&gt;
 *
 * Notice that we're using both {@code $()} for dynamic values
 * and {@code c()} for the consumer side.
 *
 * @author Marcin Grzejszczak
 */
public class PatternUtils {
	public static String tooYoung() {
		return "[0-1][0-9]";
	}

	public static Pattern oldEnough() {
		return Pattern.compile("[2-9][0-9]");
	}

	public static Pattern anyName() {
		return Pattern.compile("[a-zA-Z]+");
	}

	/**
	 * Makes little sense but it's just an example ;)
	 */
	public static Pattern ok() {
		return Pattern.compile("OK");
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>ConsumerUtils</strong> contains functions used by the <strong>consumer</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.example;

import org.springframework.cloud.contract.spec.internal.ClientDslProperty;
import org.springframework.cloud.contract.spec.internal.DslProperty;

/**
 * DSL Properties passed to the DSL from the consumer's perspective.
 * That means that on the input side {@code Request} for HTTP
 * or {@code Input} for messaging you can have a regular expression.
 * On the {@code Response} for HTTP or {@code Output} for messaging
 * you have to have a concrete value.
 *
 * @author Marcin Grzejszczak
 */
public class ConsumerUtils {
	/**
	 * Consumer side property. By using the {@link ClientDslProperty}
	 * you can omit most of boilerplate code from the perspective
	 * of dynamic values. Example
	 *
	 * &lt;pre&gt;
	 * {@code
	 * request {
	 *     body(
	 *         [ age: $(ConsumerUtils.oldEnough())]
	 *     )
	 * }
	 * &lt;/pre&gt;
	 *
	 * That way the consumer side value of age field will be
	 * a regular expression and the producer side will be generated.
	 *
	 * @author Marcin Grzejszczak
	 */
	public static ClientDslProperty oldEnough() {
		return new ClientDslProperty(PatternUtils.oldEnough());
	}

	/**
	 * Consumer side property. By using the {@link ClientDslProperty}
	 * you can omit most of boilerplate code from the perspective
	 * of dynamic values. Example
	 *
	 * &lt;pre&gt;
	 * {@code
	 * request {
	 *     body(
	 *         [ name: $(ConsumerUtils.anyName())]
	 *     )
	 * }
	 * &lt;/pre&gt;
	 *
	 * That way the consumer will be a regular expression and the
	 * producer side value will be equal to {@code marcin}
	 */
	public static DslProperty anyName() {
		return new DslProperty&lt;&gt;(PatternUtils.anyName(), "marcin");
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>ProducerUtils</strong> contains functions used by the <strong>producer</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.example;

import org.springframework.cloud.contract.spec.internal.ServerDslProperty;

/**
 * DSL Properties passed to the DSL from the producer's perspective.
 * That means that on the input side {@code Request} for HTTP
 * or {@code Input} for messaging you have to have a concrete value.
 * On the {@code Response} for HTTP or {@code Output} for messaging
 * you can have a regular expression.
 *
 * @author Marcin Grzejszczak
 */
public class ProducerUtils {

	/**
	 * Producer side property. By using the {@link ProducerUtils}
	 * you can omit most of boilerplate code from the perspective
	 * of dynamic values. Example
	 *
	 * &lt;pre&gt;
	 * {@code
	 * response {
	 *     body(
	 *         [ status: $(ProducerUtils.ok())]
	 *     )
	 * }
	 * &lt;/pre&gt;
	 *
	 * That way the producer side value of age field will be
	 * a regular expression and the consumer side will be generated.
	 */
	public static ServerDslProperty ok() {
		return new ServerDslProperty(PatternUtils.ok());
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_adding_the_dependency_to_project">Adding the dependency to project</h5>
<div class="paragraph">
<p>In order for the plugins and IDE to be able to reference the common JAR classes you need
to pass the dependency to your project.</p>
</div>
<div class="sect5">
<h6 id="_test_dependency_in_project_s_dependencies">Test dependency in project&#8217;s dependencies</h6>
<div class="paragraph">
<p>First add the common jar dependency as a test dependency. That way since your
contracts files are available at test resources path, automatically the
common jar classes will be visible in your Groovy files.</p>
</div>
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;com.example&lt;/groupId&gt;
	&lt;artifactId&gt;beer-common&lt;/artifactId&gt;
	&lt;version&gt;${project.version}&lt;/version&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">testCompile("com.example:beer-common:0.0.1-SNAPSHOT")</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_test_dependency_in_plugin_s_dependencies">Test dependency in plugin&#8217;s dependencies</h6>
<div class="paragraph">
<p>Now you have to add the dependency for the plugin to reuse at runtime.</p>
</div>
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-contract-verifier&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.example&lt;/groupId&gt;
			&lt;artifactId&gt;beer-common&lt;/artifactId&gt;
			&lt;version&gt;${project.version}&lt;/version&gt;
			&lt;scope&gt;compile&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">classpath "com.example:beer-common:0.0.1-SNAPSHOT"</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_referencing_classes_in_dsls">Referencing classes in DSLs</h6>
<div class="paragraph">
<p>Now you can reference your classes in your DSL. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package contracts.beer.rest

import org.springframework.cloud.contract.spec.Contract

import static com.example.ConsumerUtils.oldEnough
import static com.example.ProducerUtils.ok

Contract.make {
	request {
		description("""
Represents a successful scenario of getting a beer

given:
	client is old enough
when:
	he applies for a beer
then:
	we'll grant him the beer
""")
		method 'POST'
		url '/check'
		body(
				age: $(oldEnough())
		)
		headers {
			contentType(applicationJson())
		}
	}
	response {
		status 200
		body("""
			{
				"status": "${value(ok())}"
			}
			""")
		headers {
			contentType(applicationJson())
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pluggable_architecture">Pluggable architecture</h3>
<div class="paragraph">
<p>There are cases where you have your contracts defined in other formats
like YAML, RAML or PACT. On the other hand you&#8217;d like to profit from
the test and stubs generation. It&#8217;s really easy to add your own implementation
of either of those. Also you can customize the way tests are generated (for example you can generate
tests for other languages) and you can do the same for stubs generation (you can generate
stubs for other stub http server implementations).</p>
</div>
<div class="sect3">
<h4 id="_custom_contract_converter">Custom contract converter</h4>
<div class="paragraph">
<p>Let&#8217;s assume that your contract is written in a YAML file like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">request:
  url: /foo
  method: PUT
  headers:
    foo: bar
  body:
    foo: bar
response:
  status: 200
  headers:
    foo2: bar
  body:
    foo2: bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thanks to the interface</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.spec

/**
 * Converter to be used to convert FROM {@link File} TO {@link Contract}
 * and from {@link Contract} to {@code T}
 *
 * @param &lt;T&gt; - type to which we want to convert the contract
 *
 * @author Marcin Grzejszczak
 * @since 1.1.0
 */
interface ContractConverter&lt;T&gt; {

	/**
	 * Should this file be accepted by the converter. Can use the file extension
	 * to check if the conversion is possible.
	 *
	 * @param file - file to be considered for conversion
	 * @return - {@code true} if the given implementation can convert the file
	 */
	boolean isAccepted(File file)

	/**
	 * Converts the given {@link File} to its {@link Contract} representation
	 *
	 * @param file - file to convert
	 * @return - {@link Contract} representation of the file
	 */
	Collection&lt;Contract&gt; convertFrom(File file)

	/**
	 * Converts the given {@link Contract} to a {@link T} representation
	 *
	 * @param contract - the parsed contract
	 * @return - {@link T} the type to which we do the conversion
	 */
	T convertTo(Collection&lt;Contract&gt; contract)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>you can register your own implementation of a contract structure converter.
Your implementation needs to state the condition on which it should start the
conversion. Also you have to define how to perform that conversion in both ways.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Once you create your implementation you have to create a <code>/META-INF/spring.factories</code>
file in which you provide the fully qualified name of your implementation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Example of a <code>spring.factories</code> file</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># Converters
org.springframework.cloud.contract.spec.ContractConverter=\
org.springframework.cloud.contract.verifier.converter.YamlContractConverter</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the YAML implementation</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.verifier.converter

import groovy.transform.CompileStatic
import org.springframework.cloud.contract.spec.Contract
import org.springframework.cloud.contract.spec.ContractConverter
import org.springframework.cloud.contract.spec.internal.Headers
import org.yaml.snakeyaml.Yaml

/**
 * Simple converter from and to a {@link YamlContract} to a collection of {@link Contract}
 */
@CompileStatic
class YamlContractConverter implements ContractConverter&lt;List&lt;YamlContract&gt;&gt; {

	@Override
	public boolean isAccepted(File file) {
		String name = file.getName()
		return name.endsWith(".yml") || name.endsWith(".yaml")
	}

	@Override
	public Collection&lt;Contract&gt; convertFrom(File file) {
		try {
			YamlContract yamlContract = new Yaml().loadAs(new FileInputStream(file), YamlContract.class)
			return [Contract.make {
				request {
					method(yamlContract?.request?.method)
					url(yamlContract?.request?.url)
					headers {
						yamlContract?.request?.headers?.each { String key, Object value -&gt;
							header(key, value)
						}
					}
					body(yamlContract?.request?.body)
				}
				response {
					status(yamlContract?.response?.status)
					headers {
						yamlContract?.response?.headers?.each { String key, Object value -&gt;
							header(key, value)
						}
					}
					body(yamlContract?.response?.body)
				}
			}]
		}
		catch (FileNotFoundException e) {
			throw new IllegalStateException(e)
		}
	}

	@Override
	public List&lt;YamlContract&gt; convertTo(Collection&lt;Contract&gt; contracts) {
		return contracts.collect { Contract contract -&gt;
			YamlContract yamlContract = new YamlContract()
			yamlContract.request.with {
				method = contract?.request?.method?.clientValue
				url = contract?.request?.url?.clientValue
				headers = (contract?.request?.headers as Headers)?.asStubSideMap()
				body = contract?.request?.body?.clientValue as Map
			}
			yamlContract.response.with {
				status = contract?.response?.status?.clientValue as Integer
				headers = (contract?.response?.headers as Headers)?.asStubSideMap()
				body = contract?.response?.body?.clientValue as Map
			}
			return yamlContract
		}
	}
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_pact_converter">Pact converter</h5>
<div class="paragraph">
<p>Spring Cloud Contract comes with an out of the box support for <a href="https://docs.pact.io/">Pact</a> representation of contracts.
In other words instead of using the Groovy DSL you can use Pact files. In this section
we will present how to add such a support for your project.</p>
</div>
<div class="sect5">
<h6 id="_pact_contract">Pact contract</h6>
<div class="paragraph">
<p>We will be working on the following example of a Pact contract. We&#8217;ve placed this file under
the <code>src/test/resources/contracts</code> folder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "provider": {
    "name": "Provider"
  },
  "consumer": {
    "name": "Consumer"
  },
  "interactions": [
    {
      "description": "",
      "request": {
        "method": "PUT",
        "path": "/fraudcheck",
        "headers": {
          "Content-Type": "application/vnd.fraud.v1+json"
        },
        "body": {
          "clientId": "1234567890",
          "loanAmount": 99999
        },
        "matchingRules": {
          "$.body.clientId": {
            "match": "regex",
            "regex": "[0-9]{10}"
          }
        }
      },
      "response": {
        "status": 200,
        "headers": {
          "Content-Type": "application/vnd.fraud.v1+json;charset=UTF-8"
        },
        "body": {
          "fraudCheckStatus": "FRAUD",
          "rejectionReason": "Amount too high"
        },
        "matchingRules": {
          "$.body.fraudCheckStatus": {
            "match": "regex",
            "regex": "FRAUD"
          }
        }
      }
    }
  ],
  "metadata": {
    "pact-specification": {
      "version": "2.0.0"
    },
    "pact-jvm": {
      "version": "2.4.18"
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_pact_for_producers">Pact for producers</h6>
<div class="paragraph">
<p>On the producer side you have add to your plugin configuration two additional dependencies.
One is the Spring Cloud Contract Pact support and the other represents the current
Pact version that you&#8217;re using.</p>
</div>
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-contract-spec-pact&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;au.com.dius&lt;/groupId&gt;
			&lt;artifactId&gt;pact-jvm-model&lt;/artifactId&gt;
			&lt;version&gt;2.4.18&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">classpath "org.springframework.cloud:spring-cloud-contract-spec-pact:${findProperty('verifierVersion') ?: verifierVersion}"
classpath 'au.com.dius:pact-jvm-model:2.4.18'</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you execute the build of your application a test, looking more or less like this, will be generated</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void validate_shouldMarkClientAsFraud() throws Exception {
	// given:
		MockMvcRequestSpecification request = given()
				.header("Content-Type", "application/vnd.fraud.v1+json")
				.body("{\"clientId\":\"1234567890\",\"loanAmount\":99999}");

	// when:
		ResponseOptions response = given().spec(request)
				.put("/fraudcheck");

	// then:
		assertThat(response.statusCode()).isEqualTo(200);
		assertThat(response.header("Content-Type")).isEqualTo("application/vnd.fraud.v1+json;charset=UTF-8");
	// and:
		DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
		assertThatJson(parsedJson).field("rejectionReason").isEqualTo("Amount too high");
	// and:
		assertThat(parsedJson.read("$.fraudCheckStatus", String.class)).matches("FRAUD");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the stub looking like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "uuid" : "996ae5ae-6834-4db6-8fac-358ca187ab62",
  "request" : {
    "url" : "/fraudcheck",
    "method" : "PUT",
    "headers" : {
      "Content-Type" : {
        "equalTo" : "application/vnd.fraud.v1+json"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.loanAmount == 99999)]"
    }, {
      "matchesJsonPath" : "$[?(@.clientId =~ /([0-9]{10})/)]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\"fraudCheckStatus\":\"FRAUD\",\"rejectionReason\":\"Amount too high\"}",
    "headers" : {
      "Content-Type" : "application/vnd.fraud.v1+json;charset=UTF-8"
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_pact_for_consumers">Pact for consumers</h6>
<div class="paragraph">
<p>On the producer side you have add to your project dependencies two additional dependencies.
One is the Spring Cloud Contract Pact support and the other represents the current
Pact version that you&#8217;re using.</p>
</div>
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-spec-pact&lt;/artifactId&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;au.com.dius&lt;/groupId&gt;
	&lt;artifactId&gt;pact-jvm-model&lt;/artifactId&gt;
	&lt;version&gt;2.4.18&lt;/version&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">testCompile "org.springframework.cloud:spring-cloud-contract-spec-pact"
testCompile 'au.com.dius:pact-jvm-model:2.4.18'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_test_generator">Custom test generator</h4>
<div class="paragraph">
<p>If you want to generate tests for different languages than Java or you&#8217;re
not happy with the way we&#8217;re building Java tests for you then you can register
your own implementation to do that.</p>
</div>
<div class="paragraph">
<p>Thanks to the interface</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.verifier.builder

import groovy.transform.CompileStatic
import org.springframework.cloud.contract.verifier.config.ContractVerifierConfigProperties
import org.springframework.cloud.contract.verifier.file.ContractMetadata

/**
 * Builds a single test.
 *
 * @since 1.1.0
 */
@CompileStatic
interface SingleTestGenerator {

	/**
	 * Creates contents of a single test class in which all test scenarios from
	 * the contract metadata should be placed.
	 *
	 * @param properties - properties passed to the plugin
	 * @param listOfFiles - list of parsed contracts with additional metadata
	 * @param className - the name of the generated test class
	 * @param classPackage - the name of the package in which the test class should be stored
	 * @param includedDirectoryRelativePath - relative path to the included directory
	 * @return contents of a single test class
	 */
	String buildClass(ContractVerifierConfigProperties properties, Collection&lt;ContractMetadata&gt; listOfFiles,
					  String className, String classPackage, String includedDirectoryRelativePath)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>you can register your own implementation that generates a test. Again, it&#8217;s enough to provide
a proper <code>spring.factories</code> file. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>org.springframework.cloud.contract.verifier.builder.SingleTestGenerator=/
com.example.MyGenerator</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_stub_generator">Custom stub generator</h4>
<div class="paragraph">
<p>If you want to generate stubs for other stub server than WireMock it&#8217;s enough to
 plug in your own implementation of this interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.verifier.converter

import groovy.transform.CompileStatic
import org.springframework.cloud.contract.spec.Contract
import org.springframework.cloud.contract.verifier.file.ContractMetadata

/**
 * Converts contracts into their stub representation.
 *
 * @since 1.1.0
 */
@CompileStatic
interface StubGenerator {

	/**
	 * Returns {@code true} if the converter can handle the file to convert it into a stub.
	 */
	boolean canHandleFileName(String fileName)

	/**
	 * Returns the collection of converted contracts into stubs. One contract can
	 * result in multiple stubs.
	 */
	Map&lt;Contract, String&gt; convertContents(String rootName, ContractMetadata content)

	/**
	 * Returns the name of the converted stub file. If you have multiple contracts
	 * in a single file then a prefix will be added to the generated file. If you
	 * provide the {@link Contract#name} field then that field will override the
	 * generated file name.
	 *
	 * Example: name of file with 2 contracts is {@code foo.groovy}, it will be
	 * converted by the implementation to {@code foo.json}. The recursive file
	 * converter will create two files {@code 0_foo.json} and {@code 1_foo.json}
	 */
	String generateOutputFileNameForInput(String inputFileName)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>you can register your own implementation that generate Stubs. Again, it&#8217;s enough to provide
a proper <code>spring.factories</code> file. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># Stub converters
org.springframework.cloud.contract.verifier.converter.StubGenerator=\
org.springframework.cloud.contract.verifier.wiremock.DslToWireMockClientConverter</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default implementation is the WireMock stub generation.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
You can provide multiple stub generator implementations. That way for example from a single
DSL as input you can e.g. produce WireMock stubs and Pact files too!
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_custom_stub_runner">Custom Stub Runner</h4>
<div class="paragraph">
<p>If you decide to have a custom stub generation you also need a custom way of running
stubs with your different stub provider.</p>
</div>
<div class="paragraph">
<p>Let us assume that you&#8217;re using <a href="https://github.com/dreamhead/moco">Moco</a> to build your stubs.
You wrote a proper stub generator and your stubs got placed in a JAR file.</p>
</div>
<div class="paragraph">
<p>In order for Stub Runner to know how to run your stubs you have to define a custom
 HTTP Stub server implementation. It can look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.stubrunner.provider.moco

import com.github.dreamhead.moco.bootstrap.arg.HttpArgs
import com.github.dreamhead.moco.runner.JsonRunner
import org.springframework.cloud.contract.stubrunner.HttpServerStub
import org.springframework.util.SocketUtils

class MocoHttpServerStub implements HttpServerStub {

	private boolean started
	private JsonRunner runner
	private int port

	@Override
	int port() {
		if (!isRunning()) {
			return -1
		}
		return port
	}

	@Override
	boolean isRunning() {
		return started
	}

	@Override
	HttpServerStub start() {
		return start(SocketUtils.findAvailableTcpPort())
	}

	@Override
	HttpServerStub start(int port) {
		this.port = port
		return this
	}

	@Override
	HttpServerStub stop() {
		if (!isRunning()) {
			return this
		}
		this.runner.stop()
		return this
	}

	@Override
	HttpServerStub registerMappings(Collection&lt;File&gt; stubFiles) {
		List&lt;InputStream&gt; streams = stubFiles.collect { it.newInputStream() }
		this.runner = JsonRunner.newJsonRunnerWithStreams(streams,
				HttpArgs.httpArgs().withPort(this.port).build())
		this.runner.run()
		this.started = true
		return this
	}

	@Override
	boolean isAccepted(File file) {
		return file.name.endsWith(".json")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and just register it in your <code>spring.factories</code> file</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># Example of a custom HTTP Server Stub
org.springframework.cloud.contract.stubrunner.HttpServerStub=\
org.springframework.cloud.contract.stubrunner.provider.moco.MocoHttpServerStub</code></pre>
</div>
</div>
<div class="paragraph">
<p>that way you&#8217;ll be able to run stubs using Moco.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
If you don&#8217;t provide any implementation then the default one - WireMock based
will be picked. If you provide more than one then the first one on the list will be picked.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_custom_stub_downloader">Custom Stub Downloader</h4>
<div class="paragraph">
<p>You can customize the way your stubs are downloaded. If you don&#8217;t want to download the JARs
from Nexus / Artifactory in the way we do by default you can set your own implementation.
Below you can find an example of a Stub Downloader Provider that takes <code>json</code> files from the test resources
from classpath, copies them to a temp file and then passes that temporary folder
 as a root for the stubs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package org.springframework.cloud.contract.stubrunner.provider.moco

import org.springframework.cloud.contract.stubrunner.StubConfiguration
import org.springframework.cloud.contract.stubrunner.StubDownloader
import org.springframework.cloud.contract.stubrunner.StubDownloaderBuilder
import org.springframework.cloud.contract.stubrunner.StubRunnerOptions
import org.springframework.core.io.DefaultResourceLoader
import org.springframework.core.io.Resource
import org.springframework.core.io.support.PathMatchingResourcePatternResolver

import java.nio.file.Files

/**
 * Poor man's version of taking stubs from classpath. It needs much more
 * love and attention to go to the main sources.
 *
 * @author Marcin Grzejszczak
 */
class ClasspathStubProvider implements StubDownloaderBuilder {

	private static final int TEMP_DIR_ATTEMPTS = 10000

	@Override
	public StubDownloader build(StubRunnerOptions stubRunnerOptions) {
		final StubConfiguration configuration = stubRunnerOptions.getDependencies().first()
		PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(
				new DefaultResourceLoader())
		try {
			String rootFolder = repoRoot(stubRunnerOptions) ?: "**/" + separatedArtifact(configuration) + "/**/*.json"
			Resource[] resources = resolver.getResources(rootFolder)
			final File tmp = createTempDir()
			tmp.deleteOnExit()
			// you'd have to write an impl to maintain the folder structure
			// this is just for demo
			resources.each { Resource resource -&gt;
				Files.copy(resource.getInputStream(), new File(tmp, resource.getFile().getName()).toPath())
			}
			return new StubDownloader() {
				@Override
				public Map.Entry&lt;StubConfiguration, File&gt; downloadAndUnpackStubJar(
						StubConfiguration stubConfiguration) {
					return new AbstractMap.SimpleEntry(configuration, tmp)
				}
			}
		} catch (IOException e) {
			throw new IllegalStateException(e)
		}
	}

	private String repoRoot(StubRunnerOptions stubRunnerOptions) {
		switch (stubRunnerOptions.stubRepositoryRoot) {
			case { !it }:
				return ""
			case { String root -&gt; root.endsWith("**/*.json") }:
				return stubRunnerOptions.stubRepositoryRoot
			default:
				return stubRunnerOptions.stubRepositoryRoot + "/**/*.json"
		}
	}

	private String separatedArtifact(StubConfiguration configuration) {
		return configuration.getGroupId().replace(".", File.separator) +
				File.separator + configuration.getArtifactId()
	}

	// Taken from Guava
	private File createTempDir() {
		File baseDir = new File(System.getProperty("java.io.tmpdir"))
		String baseName = System.currentTimeMillis() + "-"
		for (int counter = 0; counter &lt; TEMP_DIR_ATTEMPTS; counter++) {
			File tempDir = new File(baseDir, baseName + counter)
			if (tempDir.mkdir()) {
				return tempDir
			}
		}
		throw new IllegalStateException(
				"Failed to create directory within " + TEMP_DIR_ATTEMPTS + " attempts (tried " + baseName + "0 to " + baseName + (
						TEMP_DIR_ATTEMPTS - 1) + ")")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and just register it in your <code>spring.factories</code> file</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># Example of a custom Stub Downloader Provider
org.springframework.cloud.contract.stubrunner.StubDownloaderBuilder=\
org.springframework.cloud.contract.stubrunner.provider.moco.ClasspathStubProvider</code></pre>
</div>
</div>
<div class="paragraph">
<p>that way you&#8217;ll be able to pick a folder with the source of your stubs.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
If you don&#8217;t provide any implementation then the default one - Aether based that will download stubs from a remote repo
will be picked. If you provide more than one then the first one on the list will be picked.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_links">Links</h3>
<div class="paragraph">
<p>Here you can find interesting links related to Spring Cloud Contract Verifier:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-cloud/spring-cloud-contract/">Spring Cloud Contract Github Repository</a></p>
</li>
<li>
<p><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/">Spring Cloud Contract Samples</a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html">Spring Cloud Contract Documentation</a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html/deprecated">Accurest Legacy Documentation</a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html/#spring-cloud-contract-stub-runner">Spring Cloud Contract Stub Runner Documentation</a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html/#stub-runner-for-messaging">Spring Cloud Contract Stub Runner Messaging Documentation</a></p>
</li>
<li>
<p><a href="https://gitter.im/spring-cloud/spring-cloud-contract">Spring Cloud Contract Gitter</a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/">Spring Cloud Contract Maven Plugin</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</body>
</html>