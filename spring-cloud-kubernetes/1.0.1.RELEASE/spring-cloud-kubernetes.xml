<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Spring Cloud Kubernetes</title>
<date>2019-03-05</date>
</info>
<preface>
<title></title>
<simpara>This reference guide covers how to use Spring Cloud Kubernetes.</simpara>
</preface>
<chapter xml:id="_why_do_you_need_spring_cloud_kubernetes">
<title>Why do you need Spring Cloud Kubernetes?</title>
<simpara>Spring Cloud Kubernetes provide Spring Cloud common interface implementations that consume Kubernetes native services.
The main objective of the projects provided in this repository is to facilitate the integration of Spring Cloud and Spring Boot applications running inside Kubernetes.</simpara>
</chapter>
<chapter xml:id="_starters">
<title>Starters</title>
<simpara>Starters are convenient dependency descriptors you can include in your
application. Include a starter to get the dependencies and Spring Boot
auto-configuration for a feature set.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Starter</entry>
<entry align="left" valign="top">Features</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-kubernetes&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting></entry>
<entry align="left" valign="top"><simpara><link linkend="_discoveryclient_for_kubernetes">Discovery Client</link> implementation that
resolves service names to Kubernetes Services.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-kubernetes-config&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting></entry>
<entry align="left" valign="top"><simpara>Load application properties from Kubernetes
<link linkend="ConfigMap PropertySource">ConfigMaps</link> and <link linkend="_secrets_propertysource">Secrets</link>.
<link linkend="PropertySource Reload">Reload</link> application properties when a ConfigMap or
Secret changes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-kubernetes-ribbon&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting></entry>
<entry align="left" valign="top"><simpara><link linkend="Ribbon discovery in Kubernetes">Ribbon</link> client-side load balancer with
server list obtained from Kubernetes Endpoints.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-kubernetes-all&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting></entry>
<entry align="left" valign="top"><simpara>All Spring Cloud Kubernetes features.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</chapter>
<chapter xml:id="_discoveryclient_for_kubernetes">
<title>DiscoveryClient for Kubernetes</title>
<simpara>This project provides an implementation of <link xl:href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/discovery/DiscoveryClient.java">Discovery Client</link>
for <link xl:href="https://kubernetes.io">Kubernetes</link>.
This client lets you query Kubernetes endpoints (see <link xl:href="https://kubernetes.io/docs/user-guide/services/">services</link>) by name.
A service is typically exposed by the Kubernetes API server as a collection of endpoints that represent <literal>http</literal> and <literal>https</literal> addresses and that a client can
access from a Spring Boot application running as a pod. This discovery feature is also used by the Spring Cloud Kubernetes Ribbon project
to fetch the list of the endpoints defined for an application to be load balanced.</simpara>
<simpara>This is something that you get for free by adding the following dependency inside your project:</simpara>
<informalexample>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-kubernetes&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting>
</informalexample>
<simpara>To enable loading of the <literal>DiscoveryClient</literal>, add <literal>@EnableDiscoveryClient</literal> to the according configuration or application class, as the following example shows:</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableDiscoveryClient
public class Application {
  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }
}</programlisting>
</informalexample>
<simpara>Then you can inject the client in your code simply by autowiring it, as the following example shows:</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@Autowired
private DiscoveryClient discoveryClient;</programlisting>
</informalexample>
<simpara>If, for any reason, you need to disable the <literal>DiscoveryClient</literal>, you can set the following property in <literal>application.properties</literal>:</simpara>
<informalexample>
<screen>spring.cloud.kubernetes.discovery.enabled=false</screen>
</informalexample>
<simpara>Some Spring Cloud components use the <literal>DiscoveryClient</literal> in order to obtain information about the local service instance. For
this to work, you need to align the Kubernetes service name with the <literal>spring.application.name</literal> property.</simpara>
</chapter>
<chapter xml:id="_kubernetes_native_service_discovery">
<title>Kubernetes native service discovery</title>
<simpara>Kubernetes itself is capable of (server side) service discovery (see: <link xl:href="https://kubernetes.io/docs/concepts/services-networking/service/#discovering-services">https://kubernetes.io/docs/concepts/services-networking/service/#discovering-services</link>).
Using native kubernetes service discovery ensures compatibility with additional tooling, such as Istio (<link xl:href="https://istio.io">https://istio.io</link>), a service mesh that is capable of load balancing, ribbon, circuit breaker, failover, and much more.</simpara>
<simpara>The caller service then need only refer to names resolvable in a particular Kubernetes cluster. A simple implementation might use a spring <literal>RestTemplate</literal> that refers to a fully qualified domain name (FQDN), such as <literal><link xl:href="https://{service-name}.{namespace}.svc.{cluster}.local:{service-port}">https://{service-name}.{namespace}.svc.{cluster}.local:{service-port}</link></literal>.</simpara>
<simpara>Additionally, you can use Hystrix for:</simpara>
<itemizedlist>
<listitem>
<simpara>Circuit breaker implementation on the caller side, by annotating the spring boot application class with <literal>@EnableCircuitBreaker</literal></simpara>
</listitem>
<listitem>
<simpara>Fallback functionality, by annotating the respective method with <literal>@HystrixCommand(fallbackMethod=</literal></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="_kubernetes_propertysource_implementations">
<title>Kubernetes PropertySource implementations</title>
<simpara>The most common approach to configuring your Spring Boot application is to create an <literal>application.properties</literal> or <literal>applicaiton.yaml</literal> or
an <literal>application-profile.properties</literal> or <literal>application-profile.yaml</literal> file that contains key-value pairs that provide customization values to your
application or Spring Boot starters. You can override these properties by specifying system properties or environment
variables.</simpara>
<section xml:id="configmap-propertysource">
<title>Using a <literal>ConfigMap</literal> <literal>PropertySource</literal></title>
<simpara>Kubernetes provides a resource named <link xl:href="https://kubernetes.io/docs/user-guide/configmap/"><literal>ConfigMap</literal></link> to externalize the
parameters to pass to your application in the form of key-value pairs or embedded <literal>application.properties</literal> or <literal>application.yaml</literal> files.
The <link xl:href="./spring-cloud-kubernetes-config">Spring Cloud Kubernetes Config</link> project makes Kubernetes <literal>ConfigMap</literal> instances available
during application bootstrapping and triggers hot reloading of beans or Spring context when changes are detected on
observed <literal>ConfigMap</literal> instances.</simpara>
<simpara>The default behavior is to create a <literal>ConfigMapPropertySource</literal> based on a Kubernetes <literal>ConfigMap</literal> that has a <literal>metadata.name</literal> value of either the name of
your Spring application (as defined by its <literal>spring.application.name</literal> property) or a custom name defined within the
<literal>bootstrap.properties</literal> file under the following key: <literal>spring.cloud.kubernetes.config.name</literal>.</simpara>
<simpara>However, more advanced configuration is possible where you can use multiple <literal>ConfigMap</literal> instances.
The <literal>spring.cloud.kubernetes.config.sources</literal> list makes this possible.
For example, you could define the following <literal>ConfigMap</literal> instances:</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  application:
    name: cloud-k8s-app
  cloud:
    kubernetes:
      config:
        name: default-name
        namespace: default-namespace
        sources:
         # Spring Cloud Kubernetes looks up a ConfigMap named c1 in namespace default-namespace
         - name: c1
         # Spring Cloud Kubernetes looks up a ConfigMap named default-name in whatever namespace n2
         - namespace: n2
         # Spring Cloud Kubernetes looks up a ConfigMap named c3 in namespace n3
         - namespace: n3
           name: c3</programlisting>
</informalexample>
<simpara>In the preceding example, if <literal>spring.cloud.kubernetes.config.namespace</literal> had not been set,
the <literal>ConfigMap</literal> named <literal>c1</literal> would be looked up in the namespace that the application runs.</simpara>
<simpara>Any matching <literal>ConfigMap</literal> that is found is processed as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>Apply individual configuration properties.</simpara>
</listitem>
<listitem>
<simpara>Apply as <literal>yaml</literal> the content of any property named <literal>application.yaml</literal>.</simpara>
</listitem>
<listitem>
<simpara>Apply as a properties file the content of any property named <literal>application.properties</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The single exception to the aforementioned flow is when the <literal>ConfigMap</literal> contains a <emphasis role="strong">single</emphasis> key that indicates
the file is a YAML or properties file. In that case, the name of the key does NOT have to be <literal>application.yaml</literal> or
<literal>application.properties</literal> (it can be anything) and the value of the property is treated correctly.
This features facilitates the use case where the <literal>ConfigMap</literal> was created by using something like the following:</simpara>
<informalexample>
<screen>kubectl create configmap game-config --from-file=/path/to/app-config.yaml</screen>
</informalexample>
<simpara>Assume that we have a Spring Boot application named <literal>demo</literal> that uses the following properties to read its thread pool
configuration.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>pool.size.core</literal></simpara>
</listitem>
<listitem>
<simpara><literal>pool.size.maximum</literal></simpara>
</listitem>
</itemizedlist>
<simpara>This can be externalized to config map in <literal>yaml</literal> format as follows:</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  pool.size.core: 1
  pool.size.max: 16</programlisting>
</informalexample>
<simpara>Individual properties work fine for most cases. However, sometimes, embedded <literal>yaml</literal> is more convenient. In this case, we
use a single property named <literal>application.yaml</literal> to embed our <literal>yaml</literal>, as follows:</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  application.yaml: |-
    pool:
      size:
        core: 1
        max:16</programlisting>
</informalexample>
<simpara>The following example also works:</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  custom-name.yaml: |-
    pool:
      size:
        core: 1
        max:16</programlisting>
</informalexample>
<simpara>You can also configure Spring Boot applications differently depending on active profiles that are merged together
when the <literal>ConfigMap</literal> is read. You can provide different property values for different profiles by using an
<literal>application.properties</literal> or <literal>application.yaml</literal> property, specifying profile-specific values, each in their own document
(indicated by the <literal>---</literal> sequence), as follows:</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  application.yml: |-
    greeting:
      message: Say Hello to the World
    farewell:
      message: Say Goodbye
    ---
    spring:
      profiles: development
    greeting:
      message: Say Hello to the Developers
    farewell:
      message: Say Goodbye to the Developers
    ---
    spring:
      profiles: production
    greeting:
      message: Say Hello to the Ops</programlisting>
</informalexample>
<simpara>In the preceding case, the configuration loaded into your Spring Application with the <literal>development</literal> profile is as follows:</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">  greeting:
    message: Say Hello to the Developers
  farewell:
    message: Say Goodbye to the Developers</programlisting>
</informalexample>
<simpara>However, if the <literal>production</literal> profile is active, the configuration becomes:</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">  greeting:
    message: Say Hello to the Ops
  farewell:
    message: Say Goodbye</programlisting>
</informalexample>
<simpara>If both profiles are active, the property that appears last within the <literal>ConfigMap</literal> overwrites any preceding values.</simpara>
<simpara>To tell Spring Boot which <literal>profile</literal> should be enabled at bootstrap, you can pass a system property to the Java
command. To do so, you can launch your Spring Boot application with an environment variable that you can define with the OpenShift
<literal>DeploymentConfig</literal> or Kubernetes <literal>ReplicationConfig</literal> resource file, as follows:</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: DeploymentConfig
spec:
  replicas: 1
  ...
    spec:
      containers:
      - env:
        - name: JAVA_APP_DIR
          value: /deployments
        - name: JAVA_OPTIONS
          value: -Dspring.profiles.active=developer</programlisting>
</informalexample>
<note>
<simpara>You should check the security configuration section. To access config maps from inside a pod you need to have the correct
Kubernetes service accounts, roles and role bindings.</simpara>
</note>
<simpara>Another option for using <literal>ConfigMap</literal> instances is to mount them into the Pod by running the Spring Cloud Kubernetes application
and having Spring Cloud Kubernetes read them from the file system.
This behavior is controlled by the <literal>spring.cloud.kubernetes.config.paths</literal> property. You can use it in
addition to or instead of the mechanism described earlier.
You can specify multiple (exact) file paths in <literal>spring.cloud.kubernetes.config.paths</literal> by using the <literal>,</literal> delimiter.</simpara>
<note>
<simpara>You have to provide the full exact path to each property file, because directories are not being recursively parsed.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>Properties:</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.config.enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boolean</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enable Secrets <literal>PropertySource</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.config.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>${spring.application.name}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the name of <literal>ConfigMap</literal> to look up</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.config.namespace</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Client namespace</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the Kubernetes namespace where to lookup</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.config.paths</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>List</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>null</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the paths where <literal>ConfigMap</literal> instances are mounted</simpara></entry>
</row>
</tbody>
<tfoot>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.config.enableApi</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boolean</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enable or disable consuming <literal>ConfigMap</literal> instances through APIs</simpara></entry>
</row>
</tfoot>
</tgroup>
</table>
</section>
<section xml:id="_secrets_propertysource">
<title>Secrets PropertySource</title>
<simpara>Kubernetes has the notion of <link xl:href="https://kubernetes.io/docs/concepts/configuration/secret/">Secrets</link> for storing
sensitive data such as passwords, OAuth tokens, and so on. This project provides integration with <literal>Secrets</literal> to make secrets
accessible by Spring Boot applications. You can explicitly enable or disable This feature by setting the <literal>spring.cloud.kubernetes.secrets.enabled</literal> property.</simpara>
<simpara>When enabled, the <literal>SecretsPropertySource</literal> looks up Kubernetes for <literal>Secrets</literal> from the following sources:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Reading recursively from secrets mounts</simpara>
</listitem>
<listitem>
<simpara>Named after the application (as defined by <literal>spring.application.name</literal>)</simpara>
</listitem>
<listitem>
<simpara>Matching some labels</simpara>
</listitem>
</orderedlist>
<simpara>Note that, by default, consuming Secrets through the API (points 2 and 3 above) <emphasis role="strong">is not enabled</emphasis> for security reasons.
Further, we recommend that containers share secrets through mounted volumes.
If you enable consuming Secrets through the API, we recommend that you limit access to Secrets by using an
[authorization policy, such as RBAC](<link xl:href="https://kubernetes.io/docs/concepts/configuration/secret/#best-practices">https://kubernetes.io/docs/concepts/configuration/secret/#best-practices</link>).</simpara>
<simpara>If the secrets are found, their data is made available to the application.</simpara>
<simpara>Assume that we have a spring boot application named <literal>demo</literal> that uses properties to read its database
configuration. We can create a Kubernetes secret by using the following command:</simpara>
<informalexample>
<screen>oc create secret generic db-secret --from-literal=username=user --from-literal=password=p455w0rd</screen>
</informalexample>
<simpara>The preceding command would create the following secret (which you can see by using <literal>oc get secrets db-secret -o yaml</literal>):</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
data:
  password: cDQ1NXcwcmQ=
  username: dXNlcg==
kind: Secret
metadata:
  creationTimestamp: 2017-07-04T09:15:57Z
  name: db-secret
  namespace: default
  resourceVersion: "357496"
  selfLink: /api/v1/namespaces/default/secrets/db-secret
  uid: 63c89263-6099-11e7-b3da-76d6186905a8
type: Opaque</programlisting>
</informalexample>
<simpara>Note that the data contains Base64-encoded versions of the literal provided by the <literal>create</literal> command.</simpara>
<simpara>Your application can then use this secret&#8201;&#8212;&#8201;for example, by exporting the secret&#8217;s value as environment variables:</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Deployment
metadata:
  name: ${project.artifactId}
spec:
   template:
     spec:
       containers:
         - env:
            - name: DB_USERNAME
              valueFrom:
                 secretKeyRef:
                   name: db-secret
                   key: username
            - name: DB_PASSWORD
              valueFrom:
                 secretKeyRef:
                   name: db-secret
                   key: password</programlisting>
</informalexample>
<simpara>You can select the Secrets to consume in a number of ways:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>By listing the directories where secrets are mapped:</simpara>
<informalexample>
<programlisting language="bash" linenumbering="unnumbered">-Dspring.cloud.kubernetes.secrets.paths=/etc/secrets/db-secret,etc/secrets/postgresql</programlisting>
</informalexample>
<simpara>If you have all the secrets mapped to a common root, you can set them like:</simpara>
<informalexample>
<programlisting language="bash" linenumbering="unnumbered">-Dspring.cloud.kubernetes.secrets.paths=/etc/secrets</programlisting>
</informalexample>
</listitem>
<listitem>
<simpara>By setting a named secret:</simpara>
<informalexample>
<programlisting language="bash" linenumbering="unnumbered">-Dspring.cloud.kubernetes.secrets.name=db-secret</programlisting>
</informalexample>
</listitem>
<listitem>
<simpara>By defining a list of labels:</simpara>
<informalexample>
<programlisting language="bash" linenumbering="unnumbered">-Dspring.cloud.kubernetes.secrets.labels.broker=activemq
-Dspring.cloud.kubernetes.secrets.labels.db=postgresql</programlisting>
</informalexample>
</listitem>
</orderedlist>
<table frame="all" rowsep="1" colsep="1">
<title>Properties:</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.secrets.enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boolean</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enable Secrets <literal>PropertySource</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.secrets.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>${spring.application.name}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the name of the secret to look up</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.secrets.namespace</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Client namespace</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the Kubernetes namespace where to look up</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.secrets.labels</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Map</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>null</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the labels used to lookup secrets</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.secrets.paths</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>List</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>null</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the paths where secrets are mounted (example 1)</simpara></entry>
</row>
</tbody>
<tfoot>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.secrets.enableApi</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boolean</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enables or disables consuming secrets through APIs (examples 2 and 3)</simpara></entry>
</row>
</tfoot>
</tgroup>
</table>
<simpara>Notes:
* The <literal>spring.cloud.kubernetes.secrets.labels</literal> property behaves as defined by
<link xl:href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Configuration-Binding#map-based-binding">Map-based binding</link>.
* The <literal>spring.cloud.kubernetes.secrets.paths</literal> property behaves as defined by
<link xl:href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Configuration-Binding#collection-based-binding">Collection-based binding</link>.
* Access to secrets through the API may be restricted for security reasons. The preferred way is to mount secrets to the Pod.</simpara>
<simpara>You can find an example of an application that uses secrets (though it has not been updated to use the new <literal>spring-cloud-kubernetes</literal> project) at
<link xl:href="https://github.com/fabric8-quickstarts/spring-boot-camel-config">spring-boot-camel-config</link></simpara>
</section>
<section xml:id="_propertysource_reload">
<title><literal>PropertySource</literal> Reload</title>
<simpara>Some applications may need to detect changes on external property sources and update their internal status to reflect the new configuration.
The reload feature of Spring Cloud Kubernetes is able to trigger an application reload when a related <literal>ConfigMap</literal> or
<literal>Secret</literal> changes.</simpara>
<simpara>By default, this feature is disabled. You can enable it by using the <literal>spring.cloud.kubernetes.reload.enabled=true</literal> configuration property (for example, in the <literal>application.properties</literal> file).</simpara>
<simpara>The following levels of reload are supported (by setting the <literal>spring.cloud.kubernetes.reload.strategy</literal> property):
* <literal>refresh</literal> (default): Only configuration beans annotated with <literal>@ConfigurationProperties</literal> or <literal>@RefreshScope</literal> are reloaded.
This reload level leverages the refresh feature of Spring Cloud Context.
* <literal>restart_context</literal>: the whole Spring <literal>ApplicationContext</literal> is gracefully restarted. Beans are recreated with the new configuration.
* <literal>shutdown</literal>: the Spring <literal>ApplicationContext</literal> is shut down to activate a restart of the container.
 When you use this level, make sure that the lifecycle of all non-daemon threads is bound to the <literal>ApplicationContext</literal>
and that a replication controller or replica set is configured to restart the pod.</simpara>
<simpara>Assuming that the reload feature is enabled with default settings (<literal>refresh</literal> mode), the following bean is refreshed when the config map changes:</simpara>
<informalexample>
<screen>@Configuration
@ConfigurationProperties(prefix = "bean")
public class MyConfig {

    private String message = "a message that can be changed live";

    // getter and setters

}</screen>
</informalexample>
<simpara>To see that changes effectively happen, you can create another bean that prints the message periodically, as follows</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@Component
public class MyBean {

    @Autowired
    private MyConfig config;

    @Scheduled(fixedDelay = 5000)
    public void hello() {
        System.out.println("The message is: " + config.getMessage());
    }
}</programlisting>
</informalexample>
<simpara>You can change the message printed by the application by using a <literal>ConfigMap</literal>, as follows:</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: reload-example
data:
  application.properties: |-
    bean.message=Hello World!</programlisting>
</informalexample>
<simpara>Any change to the property named <literal>bean.message</literal> in the <literal>ConfigMap</literal> associated with the pod is reflected in the
output. More generally speaking, changes associated to properties prefixed with the value defined by the <literal>prefix</literal>
field of the <literal>@ConfigurationProperties</literal> annotation are detected and reflected in the application.
<link linkend="configmap-propertysource">Associating a <literal>ConfigMap</literal> with a pod</link> is explained earlier in this chapter.</simpara>
<simpara>The full example is available in <link xl:href="https://github.com/fabric8io/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-examples/kubernetes-reload-example"><literal>spring-cloud-kubernetes-reload-example</literal></link>.</simpara>
<simpara>The reload feature supports two operating modes:
* Event (default): Watches for changes in config maps or secrets by using the Kubernetes API (web socket).
Any event produces a re-check on the configuration and, in case of changes, a reload.
The <literal>view</literal> role on the service account is required in order to listen for config map changes. A higher level role (such as <literal>edit</literal>) is required for secrets
(by default, secrets are not monitored).
* Polling: Oeriodically re-creates the configuration from config maps and secrets to see if it has changed.
You can configure the polling period by using the <literal>spring.cloud.kubernetes.reload.period</literal> property and defaults to 15 seconds.
It requires the same role as the monitored property source.
This means, for example, that using polling on file-mounted secret sources does not require particular privileges.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Properties:</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.reload.enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boolean</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enables monitoring of property sources and configuration reload</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.reload.monitoring-config-maps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boolean</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allow monitoring changes in config maps</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.reload.monitoring-secrets</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Boolean</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allow monitoring changes in secrets</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>`spring.cloud.kubernetes.reload.strategy `</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Enum</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>refresh</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The strategy to use when firing a reload (<literal>refresh</literal>, <literal>restart_context</literal>, or <literal>shutdown</literal>)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.reload.mode</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Enum</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>event</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies how to listen for changes in property sources (<literal>event</literal> or <literal>polling</literal>)</simpara></entry>
</row>
</tbody>
<tfoot>
<row>
<entry align="left" valign="top"><simpara><literal>spring.cloud.kubernetes.reload.period</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Duration</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>15s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The period for verifying changes when using the <literal>polling</literal> strategy</simpara></entry>
</row>
</tfoot>
</tgroup>
</table>
<simpara>Notes:
* You should not use properties under <literal>spring.cloud.kubernetes.reload</literal> in config maps or secrets. Changing such properties at runtime may lead to unexpected results.
* Deleting a property or the whole config map does not restore the original state of the beans when you use the <literal>refresh</literal> level.</simpara>
</section>
</chapter>
<chapter xml:id="_ribbon_discovery_in_kubernetes">
<title>Ribbon Discovery in Kubernetes</title>
<simpara>Spring Cloud client applications that call a microservice should be interested on relying on a client load-balancing
feature in order to automatically discover at which endpoint(s) it can reach a given service. This mechanism has been
implemented within the <link xl:href="https://github.com/spring-cloud/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-ribbon">spring-cloud-kubernetes-ribbon</link> project, where a
Kubernetes client populates a <link xl:href="https://github.com/Netflix/ribbon">Ribbon</link> <literal>ServerList</literal> that contains information
about such endpoints.</simpara>
<simpara>The implementation is part of the following starter that you can use by adding its dependency to your pom file:</simpara>
<informalexample>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-kubernetes-ribbon&lt;/artifactId&gt;
    &lt;version&gt;${latest.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
</informalexample>
<simpara>When the list of the endpoints is populated, the Kubernetes client searches the registered endpoints that live in
the current namespace or project by matching the service name defined in the Ribbon Client annotation, as follows:</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@RibbonClient(name = "name-service")</programlisting>
</informalexample>
<simpara>You can configure Ribbon&#8217;s behavior by providing properties in your <literal>application.properties</literal> (through your application&#8217;s
dedicated <literal>ConfigMap</literal>) by using the following format: <literal>&lt;name of your service&gt;.ribbon.&lt;Ribbon configuration key&gt;</literal>, where:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>&lt;name of your service&gt;</literal> corresponds to the service name you access over Ribbon, as configured by using the
<literal>@RibbonClient</literal> annotation (such as <literal>name-service</literal> in the preceding example).</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;Ribbon configuration key&gt;</literal> is one of the Ribbon configuration keys defined by
<link xl:href="https://github.com/Netflix/ribbon/blob/master/ribbon-core/src/main/java/com/netflix/client/config/CommonClientConfigKey.java">Ribbon&#8217;s <literal>CommonClientConfigKey</literal> class</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>Additionally, the <literal>spring-cloud-kubernetes-ribbon</literal> project defines two additional configuration keys to further
control how Ribbon interacts with Kubernetes. In particular, if an endpoint defines multiple ports, the default
behavior is to use the first one found. To select more specifically which port to use in a multi-port service, you can use
the <literal>PortName</literal> key. If you want to specify in which Kubernetes namespace the target service should be looked up, you can use
the <literal>KubernetesNamespace</literal> key, remembering in both instances to prefix these keys with your service name and
<literal>ribbon</literal> prefix, as specified earlier.</simpara>
<simpara>The following examples use this module for ribbon discovery:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="./spring-cloud-kubernetes-examples/kubernetes-circuitbreaker-ribbon-example">Spring Cloud Circuitbreaker and Ribbon</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/fabric8-quickstarts/spring-boot-ribbon">fabric8-quickstarts - Spring Boot - Ribbon</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/fabric8io/kubeflix/tree/master/examples/loanbroker/bank">Kubeflix - LoanBroker - Bank</link></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>You can disable the Ribbon discovery client by setting the <literal>spring.cloud.kubernetes.ribbon.enabled=false</literal> key within the application properties file.</simpara>
</note>
</chapter>
<chapter xml:id="_kubernetes_ecosystem_awareness">
<title>Kubernetes Ecosystem Awareness</title>
<simpara>All of the features described earlier in this guide work equally well, regardless of whether your application is running inside
Kubernetes. This is really helpful for development and troubleshooting.
From a development point of view, this lets you start your Spring Boot application and debug one
of the modules that is part of this project. You need not deploy it in Kubernetes,
as the code of the project relies on the
<link xl:href="https://github.com/fabric8io/kubernetes-client">Fabric8 Kubernetes Java client</link>, which is a fluent DSL that can
communicate by using <literal>http</literal> protocol to the REST API of the Kubernetes Server.</simpara>
<section xml:id="_kubernetes_profile_autoconfiguration">
<title>Kubernetes Profile Autoconfiguration</title>
<simpara>When the application runs as a pod inside Kubernetes, a Spring profile named <literal>kubernetes</literal> automatically gets activated.
This lets you customize the configuration, to define beans that are applied when the Spring Boot application is deployed
within the Kubernetes platform (for example, different development and production configuration).</simpara>
</section>
<section xml:id="_istio_awareness">
<title>Istio Awareness</title>
<simpara>When you include the <literal>spring-cloud-kubernetes-istio</literal> module in the application classpath, a new profile is added to the application,
provided the application is running inside a Kubernetes Cluster with <link xl:href="https://istio.io">Istio</link> installed. You can then use
spring <literal>@Profile("istio")</literal> annotations in your Beans and <literal>@Configuration</literal> classes.</simpara>
<simpara>The Istio awareness module uses  <literal>me.snowdrop:istio-client</literal> to interact with Istio APIs, letting us discover traffic rules, circuit breakers, and so on,
making it easy for our Spring Boot applications to consume this data to dynamically configure themselves according to the environment.</simpara>
</section>
</chapter>
<chapter xml:id="_pod_health_indicator">
<title>Pod Health Indicator</title>
<simpara>Spring Boot uses <link xl:href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthEndpoint.java"><literal>HealthIndicator</literal></link> to expose info about the health of an application.
That makes it really useful for exposing health-related information to the user and makes it a good fit for use as <link xl:href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">readiness probes</link>.</simpara>
<simpara>The Kubernetes health indicator (which is part of the core module) exposes the following info:</simpara>
<itemizedlist>
<listitem>
<simpara>Pod name, IP address, namespace, service account, node name, and its IP address</simpara>
</listitem>
<listitem>
<simpara>A flag that indicates whether the Spring Boot application is internal or external to Kubernetes</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="_leader_election">
<title>Leader Election</title>
<simpara>&lt;TBD&gt;</simpara>
</chapter>
<chapter xml:id="_security_configurations_inside_kubernetes">
<title>Security Configurations Inside Kubernetes</title>
<section xml:id="_namespace">
<title>Namespace</title>
<simpara>Most of the components provided in this project need to know the namespace. For Kubernetes (1.3+), the namespace is made available to the pod as part of the service account secret and is automatically detected by the client.
For earlier versions, it needs to be specified as an environment variable to the pod. A quick way to do this is as follows:</simpara>
<informalexample>
<screen>      env:
      - name: "KUBERNETES_NAMESPACE"
        valueFrom:
          fieldRef:
            fieldPath: "metadata.namespace"</screen>
</informalexample>
</section>
<section xml:id="_service_account">
<title>Service Account</title>
<simpara>For distributions of Kubernetes that support more fine-grained role-based access within the cluster, you need to make sure a pod that runs with <literal>spring-cloud-kubernetes</literal> has access to the Kubernetes API.
For any service accounts you assign to a deployment or pod, you need to make sure they have the correct roles. For example, you can add <literal>cluster-reader</literal> permissions to your <literal>default</literal> service account, depending on the project you&#8217;re in.</simpara>
</section>
</chapter>
<chapter xml:id="_examples">
<title>Examples</title>
<simpara>Spring Cloud Kubernetes tries to make it transparent for your applications to consume Kubernetes Native Services by
following the Spring Cloud interfaces.</simpara>
<simpara>In your applications, you need to add the <literal>spring-cloud-kubernetes-discovery</literal> dependency to your classpath and remove any other dependency that contains a <literal>DiscoveryClient</literal> implementation (that is, a Eureka discovery client).
The same applies for <literal>PropertySourceLocator</literal>, where you need to add to the classpath the <literal>spring-cloud-kubernetes-config</literal> and remove any other dependency that contains a <literal>PropertySourceLocator</literal> implementation (that is, a configuration server client).</simpara>
<simpara>The following projects highlight the usage of these dependencies and demonstrate how you can use these libraries from any Spring Boot application:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/spring-cloud/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-examples">Spring Cloud Kubernetes Examples</link>: the ones located inside this repository.</simpara>
</listitem>
<listitem>
<simpara>Spring Cloud Kubernetes Full Example: Minions and Boss</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/salaboy/spring-cloud-k8s-minion">Minion</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/salaboy/spring-cloud-k8s-boss">Boss</link></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Spring Cloud Kubernetes Full Example: <link xl:href="https://github.com/salaboy/s1p_docs">SpringOne Platform Tickets Service</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/salaboy/s1p_gateway">Spring Cloud Gateway with Spring Cloud Kubernetes Discovery and Config</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/salaboy/showcase-admin-tool">Spring Boot Admin with Spring Cloud Kubernetes Discovery and Config</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="_other_resources">
<title>Other Resources</title>
<simpara>This section lists other resources, such as presentations (slides) and videos about Spring Cloud Kubernetes.</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://salaboy.com/2018/09/27/the-s1p-experience/">S1P Spring Cloud on PKS</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://salaboy.com/2018/07/18/ljc-july-18-spring-cloud-docker-k8s/">Spring Cloud, Docker, Kubernetes &#8594; London Java Community July 2018</link></simpara>
</listitem>
</itemizedlist>
<simpara>Please feel free to submit other resources through pull requests to <link xl:href="https://github.com/spring-cloud/spring-cloud-kubernetes">this repository</link>.</simpara>
</chapter>
<chapter xml:id="_building">
<title>Building</title>
<section xml:id="_basic_compile_and_test">
<title>Basic Compile and Test</title>
<simpara>To build the source you will need to install JDK 1.7.</simpara>
<simpara>Spring Cloud uses Maven for most build-related activities, and you
should be able to get off the ground quite quickly by cloning the
project you are interested in and typing</simpara>
<screen>$ ./mvnw install</screen>
<note>
<simpara>You can also install Maven (&gt;=3.3.3) yourself and run the <literal>mvn</literal> command
in place of <literal>./mvnw</literal> in the examples below. If you do that you also
might need to add <literal>-P spring</literal> if your local Maven settings do not
contain repository declarations for spring pre-release artifacts.</simpara>
</note>
<note>
<simpara>Be aware that you might need to increase the amount of memory
available to Maven by setting a <literal>MAVEN_OPTS</literal> environment variable with
a value like <literal>-Xmx512m -XX:MaxPermSize=128m</literal>. We try to cover this in
the <literal>.mvn</literal> configuration, so if you find you have to do it to make a
build succeed, please raise a ticket to get the settings added to
source control.</simpara>
</note>
<simpara>For hints on how to build the project look in <literal>.travis.yml</literal> if there
is one. There should be a "script" and maybe "install" command. Also
look at the "services" section to see if any services need to be
running locally (e.g. mongo or rabbit).  Ignore the git-related bits
that you might find in "before_install" since they&#8217;re related to setting git
credentials and you already have those.</simpara>
<simpara>The projects that require middleware generally include a
<literal>docker-compose.yml</literal>, so consider using
<link xl:href="https://compose.docker.io/">Docker Compose</link> to run the middeware servers
in Docker containers. See the README in the
<link xl:href="https://github.com/spring-cloud-samples/scripts">scripts demo
repository</link> for specific instructions about the common cases of mongo,
rabbit and redis.</simpara>
<note>
<simpara>If all else fails, build with the command from <literal>.travis.yml</literal> (usually
<literal>./mvnw install</literal>).</simpara>
</note>
</section>
<section xml:id="_documentation">
<title>Documentation</title>
<simpara>The spring-cloud-build module has a "docs" profile, and if you switch
that on it will try to build asciidoc sources from
<literal>src/main/asciidoc</literal>. As part of that process it will look for a
<literal>README.adoc</literal> and process it by loading all the includes, but not
parsing or rendering it, just copying it to <literal>${main.basedir}</literal>
(defaults to <literal>${basedir}</literal>, i.e. the root of the project). If there are
any changes in the README it will then show up after a Maven build as
a modified file in the correct place. Just commit it and push the change.</simpara>
</section>
<section xml:id="_working_with_the_code">
<title>Working with the code</title>
<simpara>If you don&#8217;t have an IDE preference we would recommend that you use
<link xl:href="https://www.springsource.com/developer/sts">Spring Tools Suite</link> or
<link xl:href="https://eclipse.org">Eclipse</link> when working with the code. We use the
<link xl:href="https://eclipse.org/m2e/">m2eclipse</link> eclipse plugin for maven support. Other IDEs and tools
should also work without issue as long as they use Maven 3.3.3 or better.</simpara>
<section xml:id="_importing_into_eclipse_with_m2eclipse">
<title>Importing into eclipse with m2eclipse</title>
<simpara>We recommend the <link xl:href="https://eclipse.org/m2e/">m2eclipse</link> eclipse plugin when working with
eclipse. If you don&#8217;t already have m2eclipse installed it is available from the "eclipse
marketplace".</simpara>
<note>
<simpara>Older versions of m2e do not support Maven 3.3, so once the
projects are imported into Eclipse you will also need to tell
m2eclipse to use the right profile for the projects.  If you
see many different errors related to the POMs in the projects, check
that you have an up to date installation.  If you can&#8217;t upgrade m2e,
add the "spring" profile to your <literal>settings.xml</literal>. Alternatively you can
copy the repository settings from the "spring" profile of the parent
pom into your <literal>settings.xml</literal>.</simpara>
</note>
</section>
<section xml:id="_importing_into_eclipse_without_m2eclipse">
<title>Importing into eclipse without m2eclipse</title>
<simpara>If you prefer not to use m2eclipse you can generate eclipse project metadata using the
following command:</simpara>
<screen>$ ./mvnw eclipse:eclipse</screen>
<simpara>The generated eclipse projects can be imported by selecting <literal>import existing projects</literal>
from the <literal>file</literal> menu.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="_contributing">
<title>Contributing</title>
<simpara>Spring Cloud is released under the non-restrictive Apache 2.0 license,
and follows a very standard Github development process, using Github
tracker for issues and merging pull requests into master. If you want
to contribute even something trivial please do not hesitate, but
follow the guidelines below.</simpara>
<section xml:id="_sign_the_contributor_license_agreement">
<title>Sign the Contributor License Agreement</title>
<simpara>Before we accept a non-trivial patch or pull request we will need you to sign the
<link xl:href="https://cla.pivotal.io/sign/spring">Contributor License Agreement</link>.
Signing the contributor&#8217;s agreement does not grant anyone commit rights to the main
repository, but it does mean that we can accept your contributions, and you will get an
author credit if we do.  Active contributors might be asked to join the core team, and
given the ability to merge pull requests.</simpara>
</section>
<section xml:id="_code_of_conduct">
<title>Code of Conduct</title>
<simpara>This project adheres to the Contributor Covenant <link xl:href="https://github.com/spring-cloud/spring-cloud-build/blob/master/docs/src/main/asciidoc/code-of-conduct.adoc">code of
conduct</link>. By participating, you  are expected to uphold this code. Please report
unacceptable behavior to <link xl:href="mailto:spring-code-of-conduct@pivotal.io">spring-code-of-conduct@pivotal.io</link>.</simpara>
</section>
<section xml:id="_code_conventions_and_housekeeping">
<title>Code Conventions and Housekeeping</title>
<simpara>None of these is essential for a pull request, but they will all help.  They can also be
added after the original pull request but before a merge.</simpara>
<itemizedlist>
<listitem>
<simpara>Use the Spring Framework code format conventions. If you use Eclipse
you can import formatter settings using the
<literal>eclipse-code-formatter.xml</literal> file from the
<link xl:href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-dependencies-parent/eclipse-code-formatter.xml">Spring
Cloud Build</link> project. If using IntelliJ, you can use the
<link xl:href="https://plugins.jetbrains.com/plugin/6546">Eclipse Code Formatter
Plugin</link> to import the same file.</simpara>
</listitem>
<listitem>
<simpara>Make sure all new <literal>.java</literal> files to have a simple Javadoc class comment with at least an
<literal>@author</literal> tag identifying you, and preferably at least a paragraph on what the class is
for.</simpara>
</listitem>
<listitem>
<simpara>Add the ASF license header comment to all new <literal>.java</literal> files (copy from existing files
in the project)</simpara>
</listitem>
<listitem>
<simpara>Add yourself as an <literal>@author</literal> to the .java files that you modify substantially (more
than cosmetic changes).</simpara>
</listitem>
<listitem>
<simpara>Add some Javadocs and, if you change the namespace, some XSD doc elements.</simpara>
</listitem>
<listitem>
<simpara>A few unit tests would help a lot as well&#8201;&#8212;&#8201;someone has to do it.</simpara>
</listitem>
<listitem>
<simpara>If no-one else is using your branch, please rebase it against the current master (or
other target branch in the main project).</simpara>
</listitem>
<listitem>
<simpara>When writing a commit message please follow <link xl:href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">these conventions</link>,
if you are fixing an existing issue please add <literal>Fixes gh-XXXX</literal> at the end of the commit
message (where XXXX is the issue number).</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_checkstyle">
<title>Checkstyle</title>
<simpara>Spring Cloud Build comes with a set of checkstyle rules. You can find them in the <literal>spring-cloud-build-tools</literal> module. The most notable files under the module are:</simpara>
<formalpara>
<title>spring-cloud-build-tools/</title>
<para>
<screen>└── src
    ├── checkstyle
    │   └── checkstyle-suppressions.xml <co xml:id="CO1-1"/>
    └── main
        └── resources
            ├── checkstyle-header.txt <co xml:id="CO1-2"/>
            └── checkstyle.xml <co xml:id="CO1-3"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-3">
<para>Default Checkstyle rules</para>
</callout>
<callout arearefs="CO1-2">
<para>File header setup</para>
</callout>
<callout arearefs="CO1-1">
<para>Default suppression rules</para>
</callout>
</calloutlist>
<section xml:id="_checkstyle_configuration">
<title>Checkstyle configuration</title>
<simpara>Checkstyle rules are <emphasis role="strong">disabled by default</emphasis>. To add checkstyle to your project just define the following properties and plugins.</simpara>
<formalpara>
<title>pom.xml</title>
<para>
<screen>&lt;properties&gt;
&lt;maven-checkstyle-plugin.failsOnError&gt;true&lt;/maven-checkstyle-plugin.failsOnError&gt; <co xml:id="CO2-1"/>
        &lt;maven-checkstyle-plugin.failsOnViolation&gt;true
        &lt;/maven-checkstyle-plugin.failsOnViolation&gt; <co xml:id="CO2-2"/>
        &lt;maven-checkstyle-plugin.includeTestSourceDirectory&gt;true
        &lt;/maven-checkstyle-plugin.includeTestSourceDirectory&gt; <co xml:id="CO2-3"/>
&lt;/properties&gt;

&lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt; <co xml:id="CO2-4"/>
                &lt;groupId&gt;io.spring.javaformat&lt;/groupId&gt;
                &lt;artifactId&gt;spring-javaformat-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt; <co xml:id="CO2-5"/>
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;

    &lt;reporting&gt;
        &lt;plugins&gt;
            &lt;plugin&gt; <co xml:id="CO2-6"/>
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/reporting&gt;
&lt;/build&gt;</screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO2-1">
<para>Fails the build upon Checkstyle errors</para>
</callout>
<callout arearefs="CO2-2">
<para>Fails the build upon Checkstyle violations</para>
</callout>
<callout arearefs="CO2-3">
<para>Checkstyle analyzes also the test sources</para>
</callout>
<callout arearefs="CO2-4">
<para>Add the Spring Java Format plugin that will reformat your code to pass most of the Checkstyle formatting rules</para>
</callout>
<callout arearefs="CO2-5 CO2-6">
<para>Add checkstyle plugin to your build and reporting phases</para>
</callout>
</calloutlist>
<simpara>If you need to suppress some rules (e.g. line length needs to be longer), then it&#8217;s enough for you to define a file under <literal>${project.root}/src/checkstyle/checkstyle-suppressions.xml</literal> with your suppressions. Example:</simpara>
<formalpara>
<title>projectRoot/src/checkstyle/checkstyle-suppresions.xml</title>
<para>
<screen>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE suppressions PUBLIC
		"-//Puppy Crawl//DTD Suppressions 1.1//EN"
		"https://www.puppycrawl.com/dtds/suppressions_1_1.dtd"&gt;
&lt;suppressions&gt;
	&lt;suppress files=".*ConfigServerApplication\.java" checks="HideUtilityClassConstructor"/&gt;
	&lt;suppress files=".*ConfigClientWatch\.java" checks="LineLengthCheck"/&gt;
&lt;/suppressions&gt;</screen>
</para>
</formalpara>
<simpara>It&#8217;s advisable to copy the <literal>${spring-cloud-build.rootFolder}/.editorconfig</literal> and <literal>${spring-cloud-build.rootFolder}/.springformat</literal> to your project. That way, some default formatting rules will be applied. You can do so by running this script:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ curl https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/.editorconfig -o .editorconfig
$ touch .springformat</programlisting>
</section>
</section>
<section xml:id="_ide_setup">
<title>IDE setup</title>
<section xml:id="_intellij_idea">
<title>Intellij IDEA</title>
<simpara>In order to setup Intellij you should import our coding conventions, inspection profiles and set up the checkstyle plugin.</simpara>
<formalpara>
<title>spring-cloud-build-tools/</title>
<para>
<screen>└── src
    ├── checkstyle
    │   └── checkstyle-suppressions.xml <co xml:id="CO3-1"/>
    └── main
        └── resources
            ├── checkstyle-header.txt <co xml:id="CO3-2"/>
            ├── checkstyle.xml <co xml:id="CO3-3"/>
            └── intellij
                ├── Intellij_Project_Defaults.xml <co xml:id="CO3-4"/>
                └── Intellij_Spring_Boot_Java_Conventions.xml <co xml:id="CO3-5"/></screen>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-3">
<para>Default Checkstyle rules</para>
</callout>
<callout arearefs="CO3-2">
<para>File header setup</para>
</callout>
<callout arearefs="CO3-1">
<para>Default suppression rules</para>
</callout>
<callout arearefs="CO3-4">
<para>Project defaults for Intellij that apply most of Checkstyle rules</para>
</callout>
<callout arearefs="CO3-5">
<para>Project style conventions for Intellij that apply most of Checkstyle rules</para>
</callout>
</calloutlist>
<figure>
<title>Code style</title>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-code-style.png"/>
</imageobject>
<textobject><phrase>Code style</phrase></textobject>
</mediaobject>
</figure>
<simpara>Go to <literal>File</literal> &#8594; <literal>Settings</literal> &#8594; <literal>Editor</literal> &#8594; <literal>Code style</literal>. There click on the icon next to the <literal>Scheme</literal> section. There, click on the <literal>Import Scheme</literal> value and pick the <literal>Intellij IDEA code style XML</literal> option. Import the <literal>spring-cloud-build-tools/src/main/resources/intellij/Intellij_Spring_Boot_Java_Conventions.xml</literal> file.</simpara>
<figure>
<title>Inspection profiles</title>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-inspections.png"/>
</imageobject>
<textobject><phrase>Code style</phrase></textobject>
</mediaobject>
</figure>
<simpara>Go to <literal>File</literal> &#8594; <literal>Settings</literal> &#8594; <literal>Editor</literal> &#8594; <literal>Inspections</literal>. There click on the icon next to the <literal>Profile</literal> section. There, click on the <literal>Import Profile</literal> and import the <literal>spring-cloud-build-tools/src/main/resources/intellij/Intellij_Project_Defaults.xml</literal> file.</simpara>
<formalpara>
<title>Checkstyle</title>
<para>To have Intellij work with Checkstyle, you have to install the <literal>Checkstyle</literal> plugin. It&#8217;s advisable to also install the <literal>Assertions2Assertj</literal> to automatically convert the JUnit assertions</para>
</formalpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-checkstyle.png"/>
</imageobject>
<textobject><phrase>Checkstyle</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Go to <literal>File</literal> &#8594; <literal>Settings</literal> &#8594; <literal>Other settings</literal> &#8594; <literal>Checkstyle</literal>. There click on the <literal>+</literal> icon in the <literal>Configuration file</literal> section. There, you&#8217;ll have to define where the checkstyle rules should be picked from. In the image above, we&#8217;ve picked the rules from the cloned Spring Cloud Build repository. However, you can point to the Spring Cloud Build&#8217;s GitHub repository (e.g. for the <literal>checkstyle.xml</literal> : <literal><link xl:href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle.xml">https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle.xml</link></literal>). We need to provide the following variables:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>checkstyle.header.file</literal> - please point it to the Spring Cloud Build&#8217;s, <literal>spring-cloud-build-tools/src/main/resources/checkstyle/checkstyle-header.txt</literal> file either in your cloned repo or via the <literal><link xl:href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle-header.txt">https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle-header.txt</link></literal> URL.</simpara>
</listitem>
<listitem>
<simpara><literal>checkstyle.suppressions.file</literal> - default suppressions. Please point it to the Spring Cloud Build&#8217;s, <literal>spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml</literal> file either in your cloned repo or via the <literal><link xl:href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml">https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml</link></literal> URL.</simpara>
</listitem>
<listitem>
<simpara><literal>checkstyle.additional.suppressions.file</literal> - this variable corresponds to suppressions in your local project. E.g. you&#8217;re working on <literal>spring-cloud-contract</literal>. Then point to the <literal>project-root/src/checkstyle/checkstyle-suppressions.xml</literal> folder. Example for <literal>spring-cloud-contract</literal> would be: <literal>/home/username/spring-cloud-contract/src/checkstyle/checkstyle-suppressions.xml</literal>.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Remember to set the <literal>Scan Scope</literal> to <literal>All sources</literal> since we apply checkstyle rules for production and test sources.</simpara>
</important>
</section>
</section>
</chapter>
</book>