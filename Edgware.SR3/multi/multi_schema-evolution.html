<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>30.&nbsp;Schema evolution support</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="multi_spring-cloud.html" title="Spring Cloud"><link rel="up" href="multi__spring_cloud_stream.html" title="Part&nbsp;IV.&nbsp;Spring Cloud Stream"><link rel="prev" href="multi_contenttypemanagement.html" title="29.&nbsp;Content Type and Transformation"><link rel="next" href="multi__inter_application_communication.html" title="31.&nbsp;Inter-Application Communication"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">30.&nbsp;Schema evolution support</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="multi_contenttypemanagement.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;IV.&nbsp;Spring Cloud Stream</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="multi__inter_application_communication.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="schema-evolution" href="#schema-evolution"></a>30.&nbsp;Schema evolution support</h2></div></div></div><p>Spring Cloud Stream provides support for schema-based message converters through its <code class="literal">spring-cloud-stream-schema</code> module.
Currently, the only serialization format supported out of the box for schema-based message converters is Apache Avro, with more formats to be added in future versions.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_apache_avro_message_converters" href="#_apache_avro_message_converters"></a>30.1&nbsp;Apache Avro Message Converters</h2></div></div></div><p>The <code class="literal">spring-cloud-stream-schema</code> module contains two types of message converters that can be used for Apache Avro serialization:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">converters using the class information of the serialized/deserialized objects, or a schema with a location known at startup;</li><li class="listitem">converters using a schema registry - they locate the schemas at runtime, as well as dynamically registering new schemas as domain objects evolve.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_converters_with_schema_support" href="#_converters_with_schema_support"></a>30.2&nbsp;Converters with schema support</h2></div></div></div><p>The <code class="literal">AvroSchemaMessageConverter</code> supports serializing and deserializing messages either using a predefined schema or by using the schema information available in the class (either reflectively, or contained in the <code class="literal">SpecificRecord</code>).
If the target type of the conversion is a <code class="literal">GenericRecord</code>, then a schema must be set.</p><p>For using it, you can simply add it to the application context, optionally specifying one ore more <code class="literal">MimeTypes</code> to associate it with.
The default <code class="literal">MimeType</code> is <code class="literal">application/avro</code>.</p><p>Here is an example of configuring it in a sink application registering the Apache Avro <code class="literal">MessageConverter</code>, without a predefined schema:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SinkApplication {

  ...

  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageConverter userMessageConverter() {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> AvroSchemaMessageConverter(MimeType.valueOf(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"avro/bytes"</span>));
  }
}</pre><p>Conversely, here is an application that registers a converter with a predefined schema, to be found on the classpath:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SinkApplication {

  ...

  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageConverter userMessageConverter() {
      AvroSchemaMessageConverter converter = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> AvroSchemaMessageConverter(MimeType.valueOf(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"avro/bytes"</span>));
      converter.setSchemaLocation(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ClassPathResource(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"schemas/User.avro"</span>));
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> converter;
  }
}</pre><p>In order to understand the schema registry client converter, we will describe the schema registry support first.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_schema_registry_support" href="#_schema_registry_support"></a>30.3&nbsp;Schema Registry Support</h2></div></div></div><p>Most serialization models, especially the ones that aim for portability across different platforms and languages, rely on a schema that describes how the data is serialized in the binary payload.
In order to serialize the data and then to interpret it, both the sending and receiving sides must have access to a schema that describes the binary format.
In certain cases, the schema can be inferred from the payload type on serialization, or from the target type on deserialization, but in a lot of cases applications benefit from having access to an explicit schema that describes the binary data format.
A schema registry allows you to store schema information in a textual format (typically JSON) and makes that information accessible to various applications that need it to receive and send data in binary format.
A schema is referenceable as a tuple consisting of:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">a <span class="emphasis"><em>subject</em></span> that is the logical name of the schema;</li><li class="listitem">the schema <span class="emphasis"><em>version</em></span>;</li><li class="listitem">the schema <span class="emphasis"><em>format</em></span>  which describes the binary format of the data.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_schema_registry_server" href="#_schema_registry_server"></a>30.4&nbsp;Schema Registry Server</h2></div></div></div><p>Spring Cloud Stream provides a schema registry server implementation.
In order to use it, you can simply add the <code class="literal">spring-cloud-stream-schema-server</code> artifact to your project and use the <code class="literal">@EnableSchemaRegistryServer</code> annotation, adding the schema registry server REST controller to your application.
This annotation is intended to be used with Spring Boot web applications, and the listening port of the server is controlled by the <code class="literal">server.port</code> setting.
The <code class="literal">spring.cloud.stream.schema.server.path</code> setting can be used to control the root path of the schema server (especially when it is embedded in other applications).
The <code class="literal">spring.cloud.stream.schema.server.allowSchemaDeletion</code> boolean setting enables the deletion of schema. By default this is disabled.</p><p>The schema registry server uses a relational database to store the schemas.
 By default, it uses an embedded database.
You can customize the schema storage using the <a class="link" href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-sql" target="_top">Spring Boot SQL database and JDBC configuration options</a>.</p><p>A Spring Boot application enabling the schema registry looks as follows:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableSchemaRegistryServer</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SchemaRegistryServerApplication {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
		SpringApplication.run(SchemaRegistryServerApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
	}
}</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_schema_registry_server_api" href="#_schema_registry_server_api"></a>30.4.1&nbsp;Schema Registry Server API</h3></div></div></div><p>The Schema Registry Server API consists of the following operations:</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__literal_post_literal" href="#__literal_post_literal"></a><code class="literal">POST /</code></h4></div></div></div><p>Register a new schema.</p><p>Accepts JSON payload  with the following fields:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">subject</code> the schema subject;</li><li class="listitem"><code class="literal">format</code> the schema format;</li><li class="listitem"><code class="literal">definition</code> the schema definition.</li></ul></div><p>Response is a schema object in JSON format, with the following fields:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">id</code> the schema id;</li><li class="listitem"><code class="literal">subject</code> the schema subject;</li><li class="listitem"><code class="literal">format</code> the schema format;</li><li class="listitem"><code class="literal">version</code> the schema version;</li><li class="listitem"><code class="literal">definition</code> the schema definition.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__literal_get_subject_format_version_literal" href="#__literal_get_subject_format_version_literal"></a><code class="literal">GET /{subject}/{format}/{version}</code></h4></div></div></div><p>Retrieve an existing schema by its subject, format and version.</p><p>Response is a schema object in JSON format, with the following fields:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">id</code> the schema id;</li><li class="listitem"><code class="literal">subject</code> the schema subject;</li><li class="listitem"><code class="literal">format</code> the schema format;</li><li class="listitem"><code class="literal">version</code> the schema version;</li><li class="listitem"><code class="literal">definition</code> the schema definition.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__literal_get_subject_format_literal" href="#__literal_get_subject_format_literal"></a><code class="literal">GET /{subject}/{format}</code></h4></div></div></div><p>Retrieve a list of existing schema by its subject and format.</p><p>Response is a list of schemas with each schema object in JSON format, with the following fields:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">id</code> the schema id;</li><li class="listitem"><code class="literal">subject</code> the schema subject;</li><li class="listitem"><code class="literal">format</code> the schema format;</li><li class="listitem"><code class="literal">version</code> the schema version;</li><li class="listitem"><code class="literal">definition</code> the schema definition.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__literal_get_schemas_id_literal" href="#__literal_get_schemas_id_literal"></a><code class="literal">GET /schemas/{id}</code></h4></div></div></div><p>Retrieve an existing schema by its id.</p><p>Response is a schema object in JSON format, with the following fields:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">id</code> the schema id;</li><li class="listitem"><code class="literal">subject</code> the schema subject;</li><li class="listitem"><code class="literal">format</code> the schema format;</li><li class="listitem"><code class="literal">version</code> the schema version;</li><li class="listitem"><code class="literal">definition</code> the schema definition.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__literal_delete_subject_format_version_literal" href="#__literal_delete_subject_format_version_literal"></a><code class="literal">DELETE /{subject}/{format}/{version}</code></h4></div></div></div><p>Delete an existing schema by its subject, format and version.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__literal_delete_schemas_id_literal" href="#__literal_delete_schemas_id_literal"></a><code class="literal">DELETE /schemas/{id}</code></h4></div></div></div><p>Delete an existing schema by its id.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="__literal_delete_subject_literal" href="#__literal_delete_subject_literal"></a><code class="literal">DELETE /{subject}</code></h4></div></div></div><p>Delete existing schemas by their subject.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>This note applies to users of Spring Cloud Stream 1.1.0.RELEASE only.
Spring Cloud Stream 1.1.0.RELEASE used the table name <code class="literal">schema</code> for storing <code class="literal">Schema</code> objects, which is a keyword in a number of database implementations.
To avoid any conflicts in the future, starting with 1.1.1.RELEASE we have opted for the name <code class="literal">SCHEMA_REPOSITORY</code> for the storage table.
Any Spring Cloud Stream 1.1.0.RELEASE users that are upgrading are advised to migrate their existing schemas to the new table before upgrading.</p></td></tr></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_schema_registry_client" href="#_schema_registry_client"></a>30.5&nbsp;Schema Registry Client</h2></div></div></div><p>The client-side abstraction for interacting with schema registry servers is the <code class="literal">SchemaRegistryClient</code> interface, with the following structure:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> SchemaRegistryClient {

	SchemaRegistrationResponse register(String subject, String format, String schema);

	String fetch(SchemaReference schemaReference);

	String fetch(Integer id);

}</pre><p>Spring Cloud Stream provides out of the box implementations for interacting with its own schema server, as well as for interacting with the Confluent Schema Registry.</p><p>A client for the Spring Cloud Stream schema registry can be configured using the <code class="literal">@EnableSchemaRegistryClient</code> as follows:</p><pre class="programlisting">  <em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
  <em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
  <em><span class="hl-annotation" style="color: gray">@EnableSchemaRegistryClient</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> AvroSinkApplication {
    ...
  }</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The default converter is optimized to cache not only the schemas from the remote server but also the <code class="literal">parse()</code> and <code class="literal">toString()</code> methods that are quite expensive.
Because of this, it uses a <code class="literal">DefaultSchemaRegistryClient</code> that does not caches responses.
If you intend to use the client directly on your code, you can request a bean that also caches responses to be created.
To do that, just add the property <code class="literal">spring.cloud.stream.schemaRegistryClient.cached=true</code> to your application properties.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_confluent_s_schema_registry" href="#_using_confluent_s_schema_registry"></a>30.5.1&nbsp;Using Confluent&#8217;s Schema Registry</h3></div></div></div><p>The default configuration will create a <code class="literal">DefaultSchemaRegistryClient</code> bean.
If you want to use the Confluent schema registry, you need to create a bean of type <code class="literal">ConfluentSchemaRegistryClient</code>, which will supersede the one configured by default by the framework.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> SchemaRegistryClient schemaRegistryClient(<em><span class="hl-annotation" style="color: gray">@Value("${spring.cloud.stream.schemaRegistryClient.endpoint}")</span></em> String endpoint){
  ConfluentSchemaRegistryClient client = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ConfluentSchemaRegistryClient();
  client.setEndpoint(endpoint);
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> client;
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The ConfluentSchemaRegistryClient is tested against Confluent platform version 3.2.2.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_schema_registry_client_properties" href="#_schema_registry_client_properties"></a>30.5.2&nbsp;Schema Registry Client properties</h3></div></div></div><p>The Schema Registry Client supports the following properties:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">spring.cloud.stream.schemaRegistryClient.endpoint</span></dt><dd>The location of the schema-server.
Use a full URL when setting this, including protocol (<code class="literal">http</code> or <code class="literal">https</code>) , port and context path.</dd><dt><span class="term">Default</span></dt><dd><code class="literal"><a class="link" href="http://localhost:8990/" target="_top">http://localhost:8990/</a></code></dd><dt><span class="term">spring.cloud.stream.schemaRegistryClient.cached</span></dt><dd>Whether the client should cache schema server responses.
Normally set to <code class="literal">false</code>, as the caching happens in the message converter.
Clients using the schema registry client should set this to <code class="literal">true</code>.</dd><dt><span class="term">Default</span></dt><dd><code class="literal">true</code></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_avro_schema_registry_client_message_converters" href="#_avro_schema_registry_client_message_converters"></a>30.6&nbsp;Avro Schema Registry Client Message Converters</h2></div></div></div><p>For Spring Boot applications that have a <code class="literal">SchemaRegistryClient</code> bean registered with the application context, Spring Cloud Stream will auto-configure an Apache Avro message converter that uses the schema registry client for schema management.
This eases schema evolution, as applications that receive messages can get easy access to a writer schema that can be reconciled with their own reader schema.</p><p>For outbound messages, the <code class="literal">MessageConverter</code> will be activated if the content type of the channel is set to <code class="literal">application/*+avro</code>, e.g.:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.stream.bindings.output.contentType</span>=application/*+avro</pre><p>During the outbound conversion, the message converter will try to infer the schemas of the outbound messages based on their type and register them to a subject based on the payload type using the <code class="literal">SchemaRegistryClient</code>.
If an identical schema is already found, then a reference to it will be retrieved.
If not, the schema will be registered and a new version number will be provided.
The message will be sent with a <code class="literal">contentType</code> header using the scheme <code class="literal">application/[prefix].[subject].v[version]+avro</code>, where <code class="literal">prefix</code> is configurable and <code class="literal">subject</code> is deduced from the payload type.</p><p>For example, a message of the type <code class="literal">User</code> may be sent as a binary payload with a content type of <code class="literal">application/vnd.user.v2+avro</code>, where <code class="literal">user</code> is the subject and <code class="literal">2</code> is the version number.</p><p>When receiving messages, the converter will infer the schema reference from the header of the incoming message and will try to retrieve it. The schema will be used as the writer schema in the deserialization process.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_avro_schema_registry_message_converter_properties" href="#_avro_schema_registry_message_converter_properties"></a>30.6.1&nbsp;Avro Schema Registry Message Converter properties</h3></div></div></div><p>If you have enabled Avro based schema registry client by setting <code class="literal">spring.cloud.stream.bindings.output.contentType=application/*+avro</code> you can customize the behavior of the registration with the following properties.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</span></dt><dd>Enable if you want the converter to use reflection to infer a Schema from a POJO.</dd><dt><span class="term">Default</span></dt><dd><code class="literal">false</code></dd><dt><span class="term">spring.cloud.stream.schema.avro.readerSchema</span></dt><dd>Avro compares schema versions by looking at a writer schema (origin payload) and a reader schema (your application payload), check <a class="link" href="https://avro.apache.org/docs/1.7.6/spec.html" target="_top">Avro</a> documentation for more information. If set, this overrides any lookups at the schema server and uses the local schema as the reader schema.</dd><dt><span class="term">Default</span></dt><dd><code class="literal">null</code></dd><dt><span class="term">spring.cloud.stream.schema.avro.schemaLocations</span></dt><dd>Register any <code class="literal">.avsc</code> files listed in this property with the Schema Server.</dd><dt><span class="term">Default</span></dt><dd><code class="literal">empty</code></dd><dt><span class="term">spring.cloud.stream.schema.avro.prefix</span></dt><dd>The prefix to be used on the Content-Type header.</dd><dt><span class="term">Default</span></dt><dd><code class="literal">vnd</code></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_schema_registration_and_resolution" href="#_schema_registration_and_resolution"></a>30.7&nbsp;Schema Registration and Resolution</h2></div></div></div><p>To better understand how Spring Cloud Stream registers and resolves new schemas, as well as its use of Avro schema comparison features, we will provide two separate subsections below: one for the registration, and one for the resolution of schemas.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_schema_registration_process_serialization" href="#_schema_registration_process_serialization"></a>30.7.1&nbsp;Schema Registration Process (Serialization)</h3></div></div></div><p>The first part of the registration process is extracting a schema from the payload that is being sent over a channel.
Avro types such as <code class="literal">SpecificRecord</code> or <code class="literal">GenericRecord</code> already contain a schema, which can be retrieved immediately from the instance.
In the case of POJOs a schema will be inferred if the property <code class="literal">spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</code> is set to <code class="literal">true</code> (the default).</p><div class="figure"><a name="d0e8934" href="#d0e8934"></a><p class="title"><b>Figure&nbsp;30.1.&nbsp;Schema Writer Resolution Process</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/schema_resolution.png" align="middle" alt="schema resolution"></div></div></div><br class="figure-break"><p>Once a schema is obtained, the converter will then load its metadata (version) from the remote server.
First it queries a local cache, and if not found it then submits the data to the server that will reply with versioning information.
The converter will always cache the results to avoid the overhead of querying the Schema Server for every new message that needs to be serialized.</p><div class="figure"><a name="d0e8945" href="#d0e8945"></a><p class="title"><b>Figure&nbsp;30.2.&nbsp;Schema Registration Process</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/registration.png" align="middle" alt="registration"></div></div></div><br class="figure-break"><p>With the schema version information, the converter sets the <code class="literal">contentType</code> header of the message to carry the version information such as <code class="literal">application/vnd.user.v1+avro</code></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_schema_resolution_process_deserialization" href="#_schema_resolution_process_deserialization"></a>30.7.2&nbsp;Schema Resolution Process (Deserialization)</h3></div></div></div><p>When reading messages that contain version information (i.e. a <code class="literal">contentType</code> header with a scheme like above), the converter will query the Schema server to fetch the <span class="strong"><strong>writer</strong></span> schema of the message.
Once it has found the correct schema of the incoming message, it then retrieves the reader schema and using Avro&#8217;s schema resolution support reads it into the reader definition (setting defaults and missing properties).</p><div class="figure"><a name="d0e8972" href="#d0e8972"></a><p class="title"><b>Figure&nbsp;30.3.&nbsp;Schema Reading Resolution Process</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/schema_reading.png" align="middle" alt="schema reading"></div></div></div><br class="figure-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>It&#8217;s important to understand the difference between a writer schema (the application that wrote the message) and a reader schema (the receiving application).
Please take a moment to read <a class="link" href="https://avro.apache.org/docs/1.7.6/spec.html" target="_top">the Avro terminology</a> and understand the process.
Spring Cloud Stream will always fetch the writer schema to determine how to read a message. If you want to get Avro&#8217;s schema evolution support working you need to make sure that a readerSchema was properly set for your application.</p></td></tr></table></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="multi_contenttypemanagement.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="multi__spring_cloud_stream.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="multi__inter_application_communication.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">29.&nbsp;Content Type and Transformation&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="multi_spring-cloud.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;31.&nbsp;Inter-Application Communication</td></tr></table></div></body></html>