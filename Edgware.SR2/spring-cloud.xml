<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Spring Cloud</title>
<date>2018-02-09</date>
</info>
<preface>
<title></title>
<simpara>Spring Cloud provides tools for developers to quickly build some of
the common patterns in distributed systems (e.g. configuration
management, service discovery, circuit breakers, intelligent routing,
micro-proxy, control bus). Coordination of
distributed systems leads to boiler plate patterns, and using Spring
Cloud developers can quickly stand up services and applications that
implement those patterns. They will work well in any distributed
environment, including the developer&#8217;s own laptop, bare metal data
centres, and managed platforms such as Cloud Foundry.</simpara>
<simpara>Version: Edgware.SR2</simpara>
</preface>
<chapter xml:id="_features">
<title>Features</title>
<simpara>Spring Cloud focuses on providing good out of box experience for typical use cases
and extensibility mechanism to cover others.</simpara>
<itemizedlist>
<listitem>
<simpara>Distributed/versioned configuration</simpara>
</listitem>
<listitem>
<simpara>Service registration and discovery</simpara>
</listitem>
<listitem>
<simpara>Routing</simpara>
</listitem>
<listitem>
<simpara>Service-to-service calls</simpara>
</listitem>
<listitem>
<simpara>Load balancing</simpara>
</listitem>
<listitem>
<simpara>Circuit Breakers</simpara>
</listitem>
<listitem>
<simpara>Distributed messaging</simpara>
</listitem>
</itemizedlist>
</chapter>
<part xml:id="_cloud_native_applications">
<title>Cloud Native Applications</title>
<partintro>
<simpara><link xl:href="https://pivotal.io/platform-as-a-service/migrating-to-cloud-native-application-architectures-ebook">Cloud Native</link> is a style of application development that encourages easy adoption of best practices in the areas of continuous delivery and value-driven development. A related discipline is that of building <link xl:href="https://12factor.net/">12-factor Apps</link> in which development practices are aligned with delivery and operations goals, for instance by using declarative programming and management and monitoring. Spring Cloud facilitates these styles of development in a number of specific ways and the starting point is a set of features that all components in a distributed system either need or need easy access to when required.</simpara>
<simpara>Many of those features are covered by <link xl:href="https://projects.spring.io/spring-boot">Spring Boot</link>, which we build on in Spring Cloud. Some more are delivered by Spring Cloud as two libraries: Spring Cloud Context and Spring Cloud Commons. Spring Cloud Context provides utilities and special services for the <literal>ApplicationContext</literal> of a Spring Cloud application (bootstrap context, encryption, refresh scope and environment endpoints). Spring Cloud Commons is a set of abstractions and common classes used in different Spring Cloud implementations (eg. Spring Cloud Netflix vs. Spring Cloud Consul).</simpara>
<simpara>If you are getting an exception due to "Illegal key size" and you are using Sun&#8217;s JDK, you need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files. See the following links for more information:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html">Java 6 JCE</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">Java 7 JCE</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">Java 8 JCE</link></simpara>
</listitem>
</itemizedlist>
<simpara>Extract files into JDK/jre/lib/security folder (whichever version of JRE/JDK x64/x86 you are using).</simpara>
<note>
<simpara>Spring Cloud is released under the non-restrictive Apache 2.0 license. If you would like to contribute to this section of the documentation or if you find an error, please find the source code and issue trackers in the project at <link xl:href="https://github.com/spring-cloud/spring-cloud-commons/tree/master/docs/src/main/asciidoc">github</link>.</simpara>
</note>
</partintro>
<chapter xml:id="_spring_cloud_context_application_context_services">
<title>Spring Cloud Context: Application Context Services</title>
<simpara>Spring Boot has an opinionated view of how to build an application
with Spring: for instance it has conventional locations for common
configuration file, and endpoints for common management and monitoring
tasks. Spring Cloud builds on top of that and adds a few features that
probably all components in a system would use or occasionally need.</simpara>
<section xml:id="_the_bootstrap_application_context">
<title>The Bootstrap Application Context</title>
<simpara>A Spring Cloud application operates by creating a "bootstrap"
context, which is a parent context for the main application. Out of
the box it is responsible for loading configuration properties from
the external sources, and also decrypting properties in the local
external configuration files. The two contexts share an <literal>Environment</literal>
which is the source of external properties for any Spring
application. Bootstrap properties are added with high precedence, so
they cannot be overridden by local configuration, by default.</simpara>
<simpara>The bootstrap context uses a different convention for locating
external configuration than the main application context, so instead
of <literal>application.yml</literal> (or <literal>.properties</literal>) you use <literal>bootstrap.yml</literal>,
keeping the external configuration for bootstrap and main context
nicely separate. Example:</simpara>
<formalpara>
<title>bootstrap.yml</title>
<para>
<screen>spring:
  application:
    name: foo
  cloud:
    config:
      uri: ${SPRING_CONFIG_URI:http://localhost:8888}</screen>
</para>
</formalpara>
<simpara>It is a good idea to set the <literal>spring.application.name</literal> (in
<literal>bootstrap.yml</literal> or <literal>application.yml</literal>) if your application needs any
application-specific configuration from the server.</simpara>
<simpara>You can disable the bootstrap process completely by setting
<literal>spring.cloud.bootstrap.enabled=false</literal> (e.g. in System properties).</simpara>
</section>
<section xml:id="_application_context_hierarchies">
<title>Application Context Hierarchies</title>
<simpara>If you build an application context from <literal>SpringApplication</literal> or
<literal>SpringApplicationBuilder</literal>, then the Bootstrap context is added as a
parent to that context. It is a feature of Spring that child contexts
inherit property sources and profiles from their parent, so the "main"
application context will contain additional property sources, compared
to building the same context without Spring Cloud Config. The
additional property sources are:</simpara>
<itemizedlist>
<listitem>
<simpara>"bootstrap": an optional <literal>CompositePropertySource</literal> appears with high
priority if any <literal>PropertySourceLocators</literal> are found in the Bootstrap
context, and they have non-empty properties. An example would be
properties from the Spring Cloud Config Server. See
<link xl:href="#customizing-bootstrap-property-sources">below</link> for instructions
on how to customize the contents of this property source.</simpara>
</listitem>
<listitem>
<simpara>"applicationConfig: [classpath:bootstrap.yml]" (and friends if
Spring profiles are active). If you have a <literal>bootstrap.yml</literal> (or
properties) then those properties are used to configure the Bootstrap
context, and then they get added to the child context when its parent
is set. They have lower precedence than the <literal>application.yml</literal> (or
properties) and any other property sources that are added to the child
as a normal part of the process of creating a Spring Boot
application. See <link xl:href="#customizing-bootstrap-properties">below</link> for
instructions on how to customize the contents of these property
sources.</simpara>
</listitem>
</itemizedlist>
<simpara>Because of the ordering rules of property sources the "bootstrap"
entries take precedence, but note that these do not contain any data
from <literal>bootstrap.yml</literal>, which has very low precedence, but can be used
to set defaults.</simpara>
<simpara>You can extend the context hierarchy by simply setting the parent
context of any <literal>ApplicationContext</literal> you create, e.g. using its own
interface, or with the <literal>SpringApplicationBuilder</literal> convenience methods
(<literal>parent()</literal>, <literal>child()</literal> and <literal>sibling()</literal>). The bootstrap context will be
the parent of the most senior ancestor that you create yourself.
Every context in the hierarchy will have its own "bootstrap" property
source (possibly empty) to avoid promoting values inadvertently from
parents down to their descendants.  Every context in the hierarchy can
also (in principle) have a different <literal>spring.application.name</literal> and
hence a different remote property source if there is a Config
Server. Normal Spring application context behaviour rules apply to
property resolution: properties from a child context override those in
the parent, by name and also by property source name (if the child has
a property source with the same name as the parent, the one from the
parent is not included in the child).</simpara>
<simpara>Note that the <literal>SpringApplicationBuilder</literal> allows you to share an
<literal>Environment</literal> amongst the whole hierarchy, but that is not the
default. Thus, sibling contexts in particular do not need to have the
same profiles or property sources, even though they will share common
things with their parent.</simpara>
</section>
<section xml:id="customizing-bootstrap-properties">
<title>Changing the Location of Bootstrap Properties</title>
<simpara>The <literal>bootstrap.yml</literal> (or <literal>.properties</literal>) location can be specified using
<literal>spring.cloud.bootstrap.name</literal> (default "bootstrap") or
<literal>spring.cloud.bootstrap.location</literal> (default empty), e.g. in System
properties. Those properties behave like the <literal>spring.config.*</literal>
variants with the same name, in fact they are used to set up the
bootstrap <literal>ApplicationContext</literal> by setting those properties in its
<literal>Environment</literal>. If there is an active profile (from
<literal>spring.profiles.active</literal> or through the <literal>Environment</literal> API in the
context you are building) then properties in that profile will be
loaded as well, just like in a regular Spring Boot app, e.g. from
<literal>bootstrap-development.properties</literal> for a "development" profile.</simpara>
</section>
<section xml:id="overriding-bootstrap-properties">
<title>Overriding the Values of Remote Properties</title>
<simpara>The property sources that are added to you application by the
bootstrap context are often "remote" (e.g. from a Config Server), and
by default they cannot be overridden locally, except on the command
line. If you want to allow your applications to override the remote
properties with their own System properties or config files, the
remote property source has to grant it permission by setting
<literal>spring.cloud.config.allowOverride=true</literal> (it doesn&#8217;t work to set this
locally). Once that flag is set there are some finer grained settings
to control the location of the remote properties in relation to System
properties and the application&#8217;s local configuration:
<literal>spring.cloud.config.overrideNone=true</literal> to override with any local
property source, and
<literal>spring.cloud.config.overrideSystemProperties=false</literal> if only System
properties and env vars should override the remote settings, but not
the local config files.</simpara>
</section>
<section xml:id="_customizing_the_bootstrap_configuration">
<title>Customizing the Bootstrap Configuration</title>
<simpara>The bootstrap context can be trained to do anything you like by adding
entries to <literal>/META-INF/spring.factories</literal> under the key
<literal>org.springframework.cloud.bootstrap.BootstrapConfiguration</literal>. This is
a comma-separated list of Spring <literal>@Configuration</literal> classes which will
be used to create the context. Any beans that you want to be available
to the main application context for autowiring can be created here,
and also there is a special contract for <literal>@Beans</literal> of type
<literal>ApplicationContextInitializer</literal>. Classes can be marked with an <literal>@Order</literal>
if you want to control the startup sequence (the default order is
"last").</simpara>
<warning>
<simpara>Be careful when adding custom <literal>BootstrapConfiguration</literal> that the
classes you add are not <literal>@ComponentScanned</literal> by mistake into your
"main" application context, where they might not be needed.
Use a separate package name for boot configuration classes that is
not already covered by your <literal>@ComponentScan</literal> or <literal>@SpringBootApplication</literal>
annotated configuration classes.</simpara>
</warning>
<simpara>The bootstrap process ends by injecting initializers into the main
<literal>SpringApplication</literal> instance (i.e. the normal Spring Boot startup
sequence, whether it is running as a standalone app or deployed in an
application server). First a bootstrap context is created from the
classes found in <literal>spring.factories</literal> and then all <literal>@Beans</literal> of type
<literal>ApplicationContextInitializer</literal> are added to the main
<literal>SpringApplication</literal> before it is started.</simpara>
</section>
<section xml:id="customizing-bootstrap-property-sources">
<title>Customizing the Bootstrap Property Sources</title>
<simpara>The default property source for external configuration added by the
bootstrap process is the Config Server, but you can add additional
sources by adding beans of type <literal>PropertySourceLocator</literal> to the
bootstrap context (via <literal>spring.factories</literal>). You could use this to
insert additional properties from a different server, or from a
database, for instance.</simpara>
<simpara>As an example, consider the following trivial custom locator:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
public class CustomPropertySourceLocator implements PropertySourceLocator {

    @Override
    public PropertySource&lt;?&gt; locate(Environment environment) {
        return new MapPropertySource("customProperty",
                Collections.&lt;String, Object&gt;singletonMap("property.from.sample.custom.source", "worked as intended"));
    }

}</programlisting>
<simpara>The <literal>Environment</literal> that is passed in is the one for the
<literal>ApplicationContext</literal> about to be created, i.e. the one that we are
supplying additional property sources for. It will already have its
normal Spring Boot-provided property sources, so you can use those to
locate a property source specific to this <literal>Environment</literal> (e.g. by
keying it on the <literal>spring.application.name</literal>, as is done in the default
Config Server property source locator).</simpara>
<simpara>If you create a jar with this class in it and then add a
<literal>META-INF/spring.factories</literal> containing:</simpara>
<screen>org.springframework.cloud.bootstrap.BootstrapConfiguration=sample.custom.CustomPropertySourceLocator</screen>
<simpara>then the "customProperty" <literal>PropertySource</literal> will show up in any
application that includes that jar on its classpath.</simpara>
</section>
<section xml:id="_environment_changes">
<title>Environment Changes</title>
<simpara>The application will listen for an <literal>EnvironmentChangeEvent</literal> and react
to the change in a couple of standard ways (additional
<literal>ApplicationListeners</literal> can be added as <literal>@Beans</literal> by the user in the
normal way). When an <literal>EnvironmentChangeEvent</literal> is observed it will
have a list of key values that have changed, and the application will
use those to:</simpara>
<itemizedlist>
<listitem>
<simpara>Re-bind any <literal>@ConfigurationProperties</literal> beans in the context</simpara>
</listitem>
<listitem>
<simpara>Set the logger levels for any properties in <literal>logging.level.*</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Note that the Config Client does not by default poll for changes in
the <literal>Environment</literal>, and generally we would not recommend that approach
for detecting changes (although you could set it up with a
<literal>@Scheduled</literal> annotation). If you have a scaled-out client application
then it is better to broadcast the <literal>EnvironmentChangeEvent</literal> to all
the instances instead of having them polling for changes (e.g. using
the <link xl:href="https://github.com/spring-cloud/spring-cloud-bus">Spring Cloud
Bus</link>).</simpara>
<simpara>The <literal>EnvironmentChangeEvent</literal> covers a large class of refresh use
cases, as long as you can actually make a change to the <literal>Environment</literal>
and publish the event (those APIs are public and part of core
Spring). You can verify the changes are bound to
<literal>@ConfigurationProperties</literal> beans by visiting the <literal>/configprops</literal>
endpoint (normal Spring Boot Actuator feature). For instance a
<literal>DataSource</literal> can have its <literal>maxPoolSize</literal> changed at runtime (the
default <literal>DataSource</literal> created by Spring Boot is an
<literal>@ConfigurationProperties</literal> bean) and grow capacity
dynamically. Re-binding <literal>@ConfigurationProperties</literal> does not cover
another large class of use cases, where you need more control over the
refresh, and where you need a change to be atomic over the whole
<literal>ApplicationContext</literal>. To address those concerns we have
<literal>@RefreshScope</literal>.</simpara>
</section>
<section xml:id="_refresh_scope">
<title>Refresh Scope</title>
<simpara>A Spring <literal>@Bean</literal> that is marked as <literal>@RefreshScope</literal> will get special
treatment when there is a configuration change. This addresses the
problem of stateful beans that only get their configuration injected
when they are initialized. For instance if a <literal>DataSource</literal> has open
connections when the database URL is changed via the <literal>Environment</literal>, we
probably want the holders of those connections to be able to complete
what they are doing. Then the next time someone borrows a connection
from the pool he gets one with the new URL.</simpara>
<simpara>Refresh scope beans are lazy proxies that initialize when they are
used (i.e. when a method is called), and the scope acts as a cache of
initialized values. To force a bean to re-initialize on the next
method call you just need to invalidate its cache entry.</simpara>
<simpara>The <literal>RefreshScope</literal> is a bean in the context and it has a public method
<literal>refreshAll()</literal> to refresh all beans in the scope by clearing the
target cache. There is also a <literal>refresh(String)</literal> method to refresh an
individual bean by name. This functionality is exposed in the
<literal>/refresh</literal> endpoint (over HTTP or JMX).</simpara>
<note>
<simpara><literal>@RefreshScope</literal> works (technically) on an <literal>@Configuration</literal>
class, but it might lead to surprising behaviour: e.g. it does <emphasis role="strong">not</emphasis>
mean that all the <literal>@Beans</literal> defined in that class are themselves
<literal>@RefreshScope</literal>. Specifically, anything that depends on those beans
cannot rely on them being updated when a refresh is initiated, unless
it is itself in <literal>@RefreshScope</literal> (in which it will be rebuilt on a
refresh and its dependencies re-injected, at which point they will be
re-initialized from the refreshed <literal>@Configuration</literal>).</simpara>
</note>
</section>
<section xml:id="_encryption_and_decryption">
<title>Encryption and Decryption</title>
<simpara>Spring Cloud has an <literal>Environment</literal> pre-processor for decrypting
property values locally. It follows the same rules as the Config
Server, and has the same external configuration via <literal>encrypt.*</literal>. Thus
you can use encrypted values in the form <literal>{cipher}*</literal> and as long as
there is a valid key then they will be decrypted before the main
application context gets the <literal>Environment</literal>. To use the encryption
features in an application you need to include Spring Security RSA in
your classpath (Maven co-ordinates
"org.springframework.security:spring-security-rsa") and you also need
the full strength JCE extensions in your JVM.</simpara>
<simpara>If you are getting an exception due to "Illegal key size" and you are using Sun&#8217;s JDK, you need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files. See the following links for more information:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html">Java 6 JCE</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">Java 7 JCE</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">Java 8 JCE</link></simpara>
</listitem>
</itemizedlist>
<simpara>Extract files into JDK/jre/lib/security folder (whichever version of JRE/JDK x64/x86 you are using).</simpara>
</section>
<section xml:id="_endpoints">
<title>Endpoints</title>
<simpara>For a Spring Boot Actuator application there are some additional management endpoints:</simpara>
<itemizedlist>
<listitem>
<simpara>POST to <literal>/env</literal> to update the <literal>Environment</literal> and rebind <literal>@ConfigurationProperties</literal> and log levels</simpara>
</listitem>
<listitem>
<simpara><literal>/refresh</literal> for re-loading the boot strap context and refreshing the <literal>@RefreshScope</literal> beans</simpara>
</listitem>
<listitem>
<simpara><literal>/restart</literal> for closing the <literal>ApplicationContext</literal> and restarting it (disabled by default)</simpara>
</listitem>
<listitem>
<simpara><literal>/pause</literal> and <literal>/resume</literal> for calling the <literal>Lifecycle</literal> methods (<literal>stop()</literal> and <literal>start()</literal> on the <literal>ApplicationContext</literal>)</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="_spring_cloud_commons_common_abstractions">
<title>Spring Cloud Commons: Common Abstractions</title>
<simpara>Patterns such as service discovery, load balancing and circuit breakers lend themselves to a common abstraction layer that can be consumed by all Spring Cloud clients, independent of the implementation (e.g. discovery via Eureka or Consul).</simpara>
<section xml:id="__enablediscoveryclient">
<title>@EnableDiscoveryClient</title>
<simpara>Commons provides the <literal>@EnableDiscoveryClient</literal> annotation. This looks for implementations of the <literal>DiscoveryClient</literal> interface via <literal>META-INF/spring.factories</literal>. Implementations of Discovery Client will add a configuration class to <literal>spring.factories</literal> under the <literal>org.springframework.cloud.client.discovery.EnableDiscoveryClient</literal> key. Examples of <literal>DiscoveryClient</literal> implementations: are <link xl:href="https://cloud.spring.io/spring-cloud-netflix/">Spring Cloud Netflix Eureka</link>, <link xl:href="https://cloud.spring.io/spring-cloud-consul/">Spring Cloud Consul Discovery</link> and <link xl:href="https://cloud.spring.io/spring-cloud-zookeeper/">Spring Cloud Zookeeper Discovery</link>.</simpara>
<simpara>By default, implementations of <literal>DiscoveryClient</literal> will auto-register the local Spring Boot server with the remote discovery server. This can be disabled by setting <literal>autoRegister=false</literal> in <literal>@EnableDiscoveryClient</literal>.</simpara>
<note>
<simpara>The use of <literal>@EnableDiscoveryClient</literal> is no longer required.  It is enough to just have a <literal>DiscoveryClient</literal> implementation
on the classpath to cause the Spring Boot application to register with the service discovery server.</simpara>
</note>
<section xml:id="_health_indicator">
<title>Health Indicator</title>
<simpara>Commons creates a Spring Boot <literal>HealthIndicator</literal> that <literal>DiscoveryClient</literal> implementations can participate in by implementing <literal>DiscoveryHealthIndicator</literal>. To disable the composite <literal>HealthIndicator</literal> set <literal>spring.cloud.discovery.client.composite-indicator.enabled=false</literal>. A generic <literal>HealthIndicator</literal> based on <literal>DiscoveryClient</literal> is auto-configured (<literal>DiscoveryClientHealthIndicator). To disable it, set `spring.cloud.discovery.client.health-indicator.enabled=false</literal>. To disable the description field of the <literal>DiscoveryClientHealthIndicator</literal> set <literal>spring.cloud.discovery.client.health-indicator.include-description=false</literal>, otherwise it can bubble up as the <literal>description</literal> of the rolled up <literal>HealthIndicator</literal>.</simpara>
</section>
</section>
<section xml:id="_serviceregistry">
<title>ServiceRegistry</title>
<simpara>Commons now provides a <literal>ServiceRegistry</literal> interface which provides methods like <literal>register(Registration)</literal> and <literal>deregister(Registration)</literal> which allow you to provide custom registered services. <literal>Registration</literal> is a marker interface.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@EnableDiscoveryClient(autoRegister=false)
public class MyConfiguration {
    private ServiceRegistry registry;

    public MyConfiguration(ServiceRegistry registry) {
        this.registry = registry;
    }

    // called via some external process, such as an event or a custom actuator endpoint
    public void register() {
        Registration registration = constructRegistration();
        this.registry.register(registration);
    }
}</programlisting>
<simpara>Each <literal>ServiceRegistry</literal> implementation has its own <literal>Registry</literal> implementation.</simpara>
<section xml:id="_serviceregistry_auto_registration">
<title>ServiceRegistry Auto-Registration</title>
<simpara>By default, the <literal>ServiceRegistry</literal> implementation will auto-register the running service. To disable that behavior, there are two methods. You can set <literal>@EnableDiscoveryClient(autoRegister=false)</literal> to permanently disable auto-registration. You can also set <literal>spring.cloud.service-registry.auto-registration.enabled=false</literal> to disable the behavior via configuration.</simpara>
</section>
<section xml:id="_service_registry_actuator_endpoint">
<title>Service Registry Actuator Endpoint</title>
<simpara>A <literal>/service-registry</literal> actuator endpoint is provided by Commons. This endpoint relys on a <literal>Registration</literal> bean in the Spring Application Context. Calling <literal>/service-registry/instance-status</literal> via a GET will return the status of the <literal>Registration</literal>. A POST to the same endpoint with a <literal>String</literal> body will change the status of the current <literal>Registration</literal> to the new value. Please see the documentation of the <literal>ServiceRegistry</literal> implementation you are using for the allowed values for updating the status and the values retured for the status.</simpara>
</section>
</section>
<section xml:id="_spring_resttemplate_as_a_load_balancer_client">
<title>Spring RestTemplate as a Load Balancer Client</title>
<simpara><literal>RestTemplate</literal> can be automatically configured to use ribbon. To create a load balanced <literal>RestTemplate</literal> create a <literal>RestTemplate</literal> <literal>@Bean</literal> and use the <literal>@LoadBalanced</literal> qualifier.</simpara>
<warning>
<simpara>A <literal>RestTemplate</literal> bean is no longer created via auto configuration. It must be created by individual applications.</simpara>
</warning>
<programlisting language="java" linenumbering="unnumbered">@Configuration
public class MyConfiguration {

    @LoadBalanced
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

public class MyClass {
    @Autowired
    private RestTemplate restTemplate;

    public String doOtherStuff() {
        String results = restTemplate.getForObject("http://stores/stores", String.class);
        return results;
    }
}</programlisting>
<simpara>The URI needs to use a virtual host name (ie. service name, not a host name).
The Ribbon client is used to create a full physical address. See
<link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/ribbon/RibbonAutoConfiguration.java">RibbonAutoConfiguration</link>
for details of how the <literal>RestTemplate</literal> is set up.</simpara>
<section xml:id="_retrying_failed_requests">
<title>Retrying Failed Requests</title>
<simpara>A load balanced <literal>RestTemplate</literal> can be configured to retry failed requests.
By default this logic is disabled, you can enable it by adding <link xl:href="https://github.com/spring-projects/spring-retry">Spring Retry</link> to your application&#8217;s classpath.  The load balanced <literal>RestTemplate</literal> will
honor some of the Ribbon configuration values related to retrying failed requests.  If
you would like to disable the retry logic with Spring Retry on the classpath
you can set <literal>spring.cloud.loadbalancer.retry.enabled=false</literal>.
The properties you can use are <literal>client.ribbon.MaxAutoRetries</literal>,
<literal>client.ribbon.MaxAutoRetriesNextServer</literal>, and <literal>client.ribbon.OkToRetryOnAllOperations</literal>.
See the <link xl:href="https://github.com/Netflix/ribbon/wiki/Getting-Started#the-properties-file-sample-clientproperties">Ribbon documentation</link>
for a description of what there properties do.</simpara>
<simpara>If you would like to implement a <literal>BackOffPolicy</literal> in your retries you will need to
create a bean of type <literal>LoadBalancedBackOffPolicyFactory</literal>, and return the <literal>BackOffPolicy</literal>
you would like to use for a given service.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
public class MyConfiguration {
    @Bean
    LoadBalancedBackOffPolicyFactory backOffPolciyFactory() {
        return new LoadBalancedBackOffPolicyFactory() {
            @Override
            public BackOffPolicy createBackOffPolicy(String service) {
        		return new ExponentialBackOffPolicy();
        	}
        };
    }
}</programlisting>
<note>
<simpara><literal>client</literal> in the above examples should be replaced with your Ribbon client&#8217;s
name.</simpara>
</note>
<simpara>If you want to add one or more <literal>RetryListener</literal> to your retry you will need to
create a bean of type <literal>LoadBalancedRetryListenerFactory</literal> and return the <literal>RetryListener</literal> array
you would like to use for a given service.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
public class MyConfiguration {
    @Bean
    LoadBalancedRetryListenerFactory retryListenerFactory() {
        return new LoadBalancedRetryListenerFactory() {
            @Override
            public RetryListener[] createRetryListeners(String service) {
                return new RetryListener[]{new RetryListener() {
                    @Override
                    public &lt;T, E extends Throwable&gt; boolean open(RetryContext context, RetryCallback&lt;T, E&gt; callback) {
                        //TODO Do you business...
                        return true;
                    }

                    @Override
                     public &lt;T, E extends Throwable&gt; void close(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) {
                        //TODO Do you business...
                    }

                    @Override
                    public &lt;T, E extends Throwable&gt; void onError(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) {
                        //TODO Do you business...
                    }
                }};
            }
        };
    }
}</programlisting>
</section>
</section>
<section xml:id="_multiple_resttemplate_objects">
<title>Multiple RestTemplate objects</title>
<simpara>If you want a <literal>RestTemplate</literal> that is not load balanced, create a <literal>RestTemplate</literal>
bean and inject it as normal.  To access the load balanced <literal>RestTemplate</literal> use
the <literal>@LoadBalanced</literal> qualifier when you create your <literal>@Bean</literal>.</simpara>
<important>
<simpara>Notice the <literal>@Primary</literal> annotation on the plain <literal>RestTemplate</literal> declaration in the example below, to disambiguate the unqualified <literal>@Autowired</literal> injection.</simpara>
</important>
<programlisting language="java" linenumbering="unnumbered">@Configuration
public class MyConfiguration {

    @LoadBalanced
    @Bean
    RestTemplate loadBalanced() {
        return new RestTemplate();
    }

    @Primary
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

public class MyClass {
    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    @LoadBalanced
    private RestTemplate loadBalanced;

    public String doOtherStuff() {
        return loadBalanced.getForObject("http://stores/stores", String.class);
    }

    public String doStuff() {
        return restTemplate.getForObject("https://example.com", String.class);
    }
}</programlisting>
<tip>
<simpara>If you see errors like <literal>java.lang.IllegalArgumentException: Can not set org.springframework.web.client.RestTemplate field com.my.app.Foo.restTemplate to com.sun.proxy.$Proxy89</literal> try injecting <literal>RestOperations</literal> instead or setting <literal>spring.aop.proxyTargetClass=true</literal>.</simpara>
</tip>
</section>
<section xml:id="ignore-network-interfaces">
<title>Ignore Network Interfaces</title>
<simpara>Sometimes it is useful to ignore certain named network interfaces so they can be excluded from Service Discovery registration (eg. running in a Docker container). A list of regular expressions can be set that will cause the desired network interfaces to be ignored. The following configuration will ignore the "docker0" interface and all interfaces that start with "veth".</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>spring:
  cloud:
    inetutils:
      ignoredInterfaces:
        - docker0
        - veth.*</screen>
</para>
</formalpara>
<simpara>You can also force to use only specified network addresses using list of regular expressions:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>spring:
  cloud:
    inetutils:
      preferredNetworks:
        - 192.168
        - 10.0</screen>
</para>
</formalpara>
<simpara>You can also force to use only site local addresses. See <link xl:href="https://docs.oracle.com/javase/8/docs/api/java/net/Inet4Address.html#isSiteLocalAddress--">Inet4Address.html.isSiteLocalAddress()</link> for more details what is site local address.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>spring:
  cloud:
    inetutils:
      useOnlySiteLocalInterfaces: true</screen>
</para>
</formalpara>
</section>
<section xml:id="http-clients">
<title>HTTP Client Factories</title>
<simpara>Spring Cloud Commons provides beans for creating both Apache HTTP clients (<literal>ApacheHttpClientFactory</literal>)
as well as OK HTTP clients (<literal>OkHttpClientFactory</literal>).  The <literal>OkHttpClientFactory</literal> bean will only be created
if the OK HTTP jar is on the classpath.  In addition, Spring Cloud Commons provides beans for creating
the connection managers used by both clients, <literal>ApacheHttpClientConnectionManagerFactory</literal> for the Apache
HTTP client and <literal>OkHttpClientConnectionPoolFactory</literal> for the OK HTTP client.  You can provide
your own implementation of these beans if you would like to customize how the HTTP clients are created
in downstream projects.  You can also disable the creation of these beans by setting
<literal>spring.cloud.httpclientfactories.apache.enabled</literal> or <literal>spring.cloud.httpclientfactories.ok.enabled</literal> to
<literal>false</literal>.</simpara>
</section>
</chapter>
</part>
<part xml:id="_spring_cloud_config">
<title>Spring Cloud Config</title>
<partintro>
<simpara><emphasis role="strong">Edgware.SR2</emphasis></simpara>
<simpara>Spring Cloud Config provides server and client-side support for externalized configuration in a distributed system. With the Config Server you have a central place to manage external properties for applications across all environments. The concepts on both client and server map identically to the Spring <literal>Environment</literal> and <literal>PropertySource</literal> abstractions, so they fit very well with Spring applications, but can be used with any application running in any language. As an application moves through the deployment pipeline from dev to test and into production you can manage the configuration between those environments and be certain that applications have everything they need to run when they migrate. The default implementation of the server storage backend uses git so it easily supports labelled versions of configuration environments, as well as being accessible to a wide range of tooling for managing the content.  It is easy to add alternative implementations and plug them in with Spring configuration.</simpara>
</partintro>
<chapter xml:id="_quick_start">
<title>Quick Start</title>
<simpara>Start the server:</simpara>
<screen>$ cd spring-cloud-config-server
$ ../mvnw spring-boot:run</screen>
<simpara>The server is a Spring Boot application so you can run it from your
IDE instead if you prefer (the main class is
<literal>ConfigServerApplication</literal>). Then try out a client:</simpara>
<screen>$ curl localhost:8888/foo/development
{"name":"foo","label":"master","propertySources":[
  {"name":"https://github.com/scratches/config-repo/foo-development.properties","source":{"bar":"spam"}},
  {"name":"https://github.com/scratches/config-repo/foo.properties","source":{"foo":"bar"}}
]}</screen>
<simpara>The default strategy for locating property sources is to clone a git
repository (at <literal>spring.cloud.config.server.git.uri</literal>) and use it to
initialize a mini <literal>SpringApplication</literal>. The mini-application&#8217;s
<literal>Environment</literal> is used to enumerate property sources and publish them
via a JSON endpoint.</simpara>
<simpara>The HTTP service has resources in the form:</simpara>
<screen>/{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties</screen>
<simpara>where the "application" is injected as the <literal>spring.config.name</literal> in the
<literal>SpringApplication</literal> (i.e. what is normally "application" in a regular
Spring Boot app), "profile" is an active profile (or comma-separated
list of properties), and "label" is an optional git label (defaults to
"master".)</simpara>
<simpara>Spring Cloud Config Server pulls configuration for remote clients
from a git repository (which must be provided):</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo</programlisting>
<section xml:id="_client_side_usage">
<title>Client Side Usage</title>
<simpara>To use these features in an application, just build it as a Spring
Boot application that depends on spring-cloud-config-client (e.g. see
the test cases for the config-client, or the sample app). The most
convenient way to add the dependency is via a Spring Boot starter
<literal>org.springframework.cloud:spring-cloud-starter-config</literal>. There is also a
parent pom and BOM (<literal>spring-cloud-starter-parent</literal>) for Maven users and a
Spring IO version management properties file for Gradle and Spring CLI
users. Example Maven configuration:</simpara>
<formalpara>
<title>pom.xml</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">   &lt;parent&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
       &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
       &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;
   &lt;/parent&gt;

&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;Brixton.RELEASE&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
		&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
	&lt;plugins&gt;
           &lt;plugin&gt;
               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
               &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
           &lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;

   &lt;!-- repositories also needed for snapshots and milestones --&gt;</programlisting>
</para>
</formalpara>
<simpara>Then you can create a standard Spring Boot application, like this simple HTTP server:</simpara>
<screen>@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</screen>
<simpara>When it runs it will pick up the external configuration from the
default local config server on port 8888 if it is running. To modify
the startup behaviour you can change the location of the config server
using <literal>bootstrap.properties</literal> (like <literal>application.properties</literal> but for
the bootstrap phase of an application context), e.g.</simpara>
<screen>spring.cloud.config.uri: http://myconfigserver.com</screen>
<simpara>The bootstrap properties will show up in the <literal>/env</literal> endpoint as a
high-priority property source, e.g.</simpara>
<screen>$ curl localhost:8080/env
{
  "profiles":[],
  "configService:https://github.com/spring-cloud-samples/config-repo/bar.properties":{"foo":"bar"},
  "servletContextInitParams":{},
  "systemProperties":{...},
  ...
}</screen>
<simpara>(a property source called "configService:&lt;URL of remote
repository&gt;/&lt;file name&gt;" contains the property "foo" with value
"bar" and is highest priority).</simpara>
<note>
<simpara>the URL in the property source name is the git repository not
the config server URL.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="_spring_cloud_config_server">
<title>Spring Cloud Config Server</title>
<simpara>The Server provides an HTTP, resource-based API for external
configuration (name-value pairs, or equivalent YAML content).  The
server is easily embeddable in a Spring Boot application using the
<literal>@EnableConfigServer</literal> annotation. So this app is a config server:</simpara>
<formalpara>
<title>ConfigServer.java</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableConfigServer
public class ConfigServer {
  public static void main(String[] args) {
    SpringApplication.run(ConfigServer.class, args);
  }
}</programlisting>
</para>
</formalpara>
<simpara>Like all Spring Boot apps it runs on port 8080 by default, but you
can switch it to the conventional port 8888 in various ways. The
easiest, which also sets a default configuration repository,
is by launching it with <literal>spring.config.name=configserver</literal> (there
is a <literal>configserver.yml</literal> in the Config Server jar). Another is
to use your own <literal>application.properties</literal>, e.g.</simpara>
<formalpara>
<title>application.properties</title>
<para>
<programlisting language="properties" linenumbering="unnumbered">server.port: 8888
spring.cloud.config.server.git.uri: file://${user.home}/config-repo</programlisting>
</para>
</formalpara>
<simpara>where <literal>${user.home}/config-repo</literal> is a git repository containing
YAML and properties files.</simpara>
<note>
<simpara>in Windows you need an extra "/" in the file URL if it is
absolute with a drive prefix, e.g. <literal><link xl:href="file:///${user.home}/config-repo">file:///${user.home}/config-repo</link></literal>.</simpara>
</note>
<tip>
<simpara>Here&#8217;s a recipe for creating the git repository in the example
above:</simpara>
<screen>$ cd $HOME
$ mkdir config-repo
$ cd config-repo
$ git init .
$ echo info.foo: bar &gt; application.properties
$ git add -A .
$ git commit -m "Add application.properties"</screen>
</tip>
<warning>
<simpara>using the local filesystem for your git repository is
intended for testing only. Use a server to host your
configuration repositories in production.</simpara>
</warning>
<warning>
<simpara>the initial clone of your configuration repository will
be quick and efficient if you only keep text files in it. If you start
to store binary files, especially large ones, you may experience
delays on the first request for configuration and/or out of memory
errors in the server.</simpara>
</warning>
<section xml:id="_environment_repository">
<title>Environment Repository</title>
<simpara>Where do you want to store the configuration data for the Config
Server? The strategy that governs this behaviour is the
<literal>EnvironmentRepository</literal>, serving <literal>Environment</literal> objects. This
<literal>Environment</literal> is a shallow copy of the domain from the Spring
<literal>Environment</literal> (including <literal>propertySources</literal> as the main feature). The
<literal>Environment</literal> resources are parametrized by three variables:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>{application}</literal> maps to "spring.application.name" on the client side;</simpara>
</listitem>
<listitem>
<simpara><literal>{profile}</literal> maps to "spring.profiles.active" on the client (comma separated list); and</simpara>
</listitem>
<listitem>
<simpara><literal>{label}</literal> which is a server side feature labelling a "versioned" set of config files.</simpara>
</listitem>
</itemizedlist>
<simpara>Repository implementations generally behave just like a Spring Boot
application loading configuration files from a "spring.config.name"
equal to the <literal>{application}</literal> parameter, and "spring.profiles.active"
equal to the <literal>{profiles}</literal> parameter. Precedence rules for profiles are
also the same as in a regular Boot application: active profiles take
precedence over defaults, and if there are multiple profiles the last
one wins (like adding entries to a <literal>Map</literal>).</simpara>
<simpara>Example: a client application has this bootstrap configuration:</simpara>
<formalpara>
<title>bootstrap.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  application:
    name: foo
  profiles:
    active: dev,mysql</programlisting>
</para>
</formalpara>
<simpara>(as usual with a Spring Boot application, these properties could also
be set as environment variables or command line arguments).</simpara>
<simpara>If the repository is file-based, the server will create an
<literal>Environment</literal> from <literal>application.yml</literal> (shared between all clients), and
<literal>foo.yml</literal> (with <literal>foo.yml</literal> taking precedence). If the YAML files have
documents inside them that point to Spring profiles, those are applied
with higher precedence (in order of the profiles listed), and if
there are profile-specific YAML (or properties) files these are also
applied with higher precedence than the defaults. Higher precedence
translates to a <literal>PropertySource</literal> listed earlier in the
<literal>Environment</literal>. (These are the same rules as apply in a standalone
Spring Boot application.)</simpara>
<section xml:id="_git_backend">
<title>Git Backend</title>
<simpara>The default implementation of <literal>EnvironmentRepository</literal> uses a Git
backend, which is very convenient for managing upgrades and physical
environments, and also for auditing changes. To change the location of
the repository you can set the "spring.cloud.config.server.git.uri"
configuration property in the Config Server (e.g. in
<literal>application.yml</literal>). If you set it with a <literal>file:</literal> prefix it should work
from a local repository so you can get started quickly and easily
without a server, but in that case the server operates directly on the
local repository without cloning it (it doesn&#8217;t matter if it&#8217;s not
bare because the Config Server never makes changes to the "remote"
repository). To scale the Config Server up and make it highly
available, you would need to have all instances of the server pointing
to the same repository, so only a shared file system would work. Even
in that case it is better to use the <literal>ssh:</literal> protocol for a shared
filesystem repository, so that the server can clone it and use a local
working copy as a cache.</simpara>
<simpara>This repository implementation maps the <literal>{label}</literal> parameter of the
HTTP resource to a git label (commit id, branch name or tag). If the
git branch or tag name contains a slash ("/") then the label in the
HTTP URL should be specified with the special string "(_)" instead (to
avoid ambiguity with other URL paths).  For example, if the label is
<literal>foo/bar</literal>, replacing the slash would result in a label that looks like
<literal>foo(_)bar</literal>.  The inclusion of the special string "(_)" can also be
applied to the <literal>{application}</literal> parameter. Be careful with the brackets
in the URL if you are using a command line client like curl (e.g.
escape them from the shell with quotes '').</simpara>
<section xml:id="_placeholders_in_git_uri">
<title>Placeholders in Git URI</title>
<simpara>Spring Cloud Config Server supports a git repository URL with
placeholders for the <literal>{application}</literal> and <literal>{profile}</literal> (and <literal>{label}</literal> if
you need it, but remember that the label is applied as a git label
anyway). So you can easily support a "one repo per application" policy
using (for example):</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/myorg/{application}</programlisting>
<simpara>or a "one repo per profile" policy using a similar pattern but with
<literal>{profile}</literal>.</simpara>
<simpara>Additionally, using the special string "(_)" within your
<literal>{application}</literal> parameters can enable support for multiple
organizations (for example):</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/{application}</programlisting>
<simpara>where <literal>{application}</literal> is provided at request time in the format
"organization(_)application".</simpara>
</section>
<section xml:id="_pattern_matching_and_multiple_repositories">
<title>Pattern Matching and Multiple Repositories</title>
<simpara>There is also support for more complex requirements with pattern
matching on the application and profile name. The pattern format is a
comma-separated list of <literal>{application}/{profile}</literal> names with wildcards
(where a pattern beginning with a wildcard may need to be
quoted). Example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          repos:
            simple: https://github.com/simple/config-repo
            special:
              pattern: special*/dev*,*special*/dev*
              uri: https://github.com/special/config-repo
            local:
              pattern: local*
              uri: file:/home/configsvc/config-repo</programlisting>
<simpara>If <literal>{application}/{profile}</literal> does not match any of the patterns, it
will use the default uri defined under
"spring.cloud.config.server.git.uri". In the above example, for the
"simple" repository, the pattern is <literal>simple/*</literal> (i.e. it only matches
one application named "simple" in all profiles). The "local"
repository matches all application names beginning with "local" in all
profiles (the <literal>/*</literal> suffix is added automatically to any pattern that
doesn&#8217;t have a profile matcher).</simpara>
<note>
<simpara>the "one-liner" short cut used in the "simple" example above can
only be used if the only property to be set is the URI. If you need to
set anything else (credentials, pattern, etc.) you need to use the full
form.</simpara>
</note>
<simpara>The <literal>pattern</literal> property in the repo is actually an array, so you can
use a YAML array (or <literal>[0]</literal>, <literal>[1]</literal>, etc. suffixes in properties files)
to bind to multiple patterns. You may need to do this if you are going
to run apps with multiple profiles. Example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          repos:
            development:
              pattern:
                - '*/development'
                - '*/staging'
              uri: https://github.com/development/config-repo
            staging:
              pattern:
                - '*/qa'
                - '*/production'
              uri: https://github.com/staging/config-repo</programlisting>
<note>
<simpara>Spring Cloud will guess that a pattern containing a profile that
doesn&#8217;t end in <literal>*</literal> implies that you actually want to match a list of
profiles starting with this pattern (so <literal>*/staging</literal> is a shortcut for
<literal>["*/staging", "*/staging,*"]</literal>). This is common where you need to run
apps in the "development" profile locally but also the "cloud" profile
remotely, for instance.</simpara>
</note>
<simpara>Every repository can also optionally store config files in
sub-directories, and patterns to search for those directories can be
specified as <literal>searchPaths</literal>. For example at the top level:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          searchPaths: foo,bar*</programlisting>
<simpara>In this example the server searches for config files in the top level
and in the "foo/" sub-directory and also any sub-directory whose name
begins with "bar".</simpara>
<simpara>By default the server clones remote repositories when configuration
is first requested. The server can be configured to clone the repositories
at startup. For example at the top level:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        git:
          uri: https://git/common/config-repo.git
          repos:
            team-a:
                pattern: team-a-*
                cloneOnStart: true
                uri: https://git/team-a/config-repo.git
            team-b:
                pattern: team-b-*
                cloneOnStart: false
                uri: https://git/team-b/config-repo.git
            team-c:
                pattern: team-c-*
                uri: https://git/team-a/config-repo.git</programlisting>
<simpara>In this example the server clones team-a&#8217;s config-repo on startup before it
accepts any requests. All other repositories will not be cloned until
configuration from the repository is requested.</simpara>
<note>
<simpara>Setting a repository to be cloned when the Config Server starts up can
help to identify a misconfigured configuration source (e.g., an invalid
repository URI) quickly, while the Config Server is starting up. With
<literal>cloneOnStart</literal> not enabled for a configuration source, the Config Server may
start successfully with a misconfigured or invalid configuration source and
not detect an error until an application requests configuration from that
configuration source.</simpara>
</note>
</section>
<section xml:id="_authentication">
<title>Authentication</title>
<simpara>To use HTTP basic authentication on the remote repository add the
"username" and "password" properties separately (not in the URL),
e.g.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          username: trolley
          password: strongpassword</programlisting>
<simpara>If you don&#8217;t use HTTPS and user credentials, SSH should also work out
of the box when you store keys in the default directories (<literal>~/.ssh</literal>)
and the uri points to an SSH location,
e.g. "<link xl:href="mailto:git@github.com">git@github.com</link>:configuration/cloud-configuration". It is important that an entry for the Git server be present in the <literal>~/.ssh/known_hosts</literal> file and that it is in <literal>ssh-rsa</literal> format. Other formats (like <literal>ecdsa-sha2-nistp256</literal>) are not supported. To avoid surprises, you should ensure that only one entry is present in the <literal>known_hosts</literal> file for the Git server and that it is matching with the URL you provided to the config server. If you used a hostname in the URL, you want to have exactly that in the <literal>known_hosts</literal> file, not the IP.
The repository is accessed using JGit, so any documentation you find on
that should be applicable. HTTPS proxy settings can be set in
<literal>~/.git/config</literal> or in the same way as for any other JVM process via
system properties (<literal>-Dhttps.proxyHost</literal> and <literal>-Dhttps.proxyPort</literal>).</simpara>
<tip>
<simpara>If you don&#8217;t know where your <literal>~/.git</literal> directory is use <literal>git config
--global</literal> to manipulate the settings (e.g. <literal>git config --global
http.sslVerify false</literal>).</simpara>
</tip>
</section>
<section xml:id="_authentication_with_aws_codecommit">
<title>Authentication with AWS CodeCommit</title>
<simpara><link xl:href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit</link> authentication can also be
done. AWS CodeCommit uses an authentication helper when using Git from the command line. This helper is not
used with the JGit library, so a JGit CredentialProvider for AWS CodeCommit will be created if the Git
URI matches the AWS CodeCommit pattern. AWS CodeCommit URIs always look like
<link xl:href="https://git-codecommit.${AWS_REGION}.amazonaws.com/${repopath}">https://git-codecommit.${AWS_REGION}.amazonaws.com/${repopath}</link>.</simpara>
<simpara>If you provide a username and password with an AWS CodeCommit URI, then these must be
the <link xl:href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSGettingStartedGuide/AWSCredentials.html">AWS accessKeyId and secretAccessKey</link>
to be used to access the repository. If you do not specify a username and password,
then the accessKeyId and secretAccessKey will be retrieved using the
<link xl:href="https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html">AWS Default Credential Provider Chain</link>.</simpara>
<simpara>If your Git URI matches the CodeCommit URI pattern (above) then you must provide
valid AWS credentials in the username and password, or in one of the locations supported
by the default credential provider chain. AWS EC2 instances may use
<link xl:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html">IAM Roles for EC2 Instances</link>.</simpara>
<simpara>Note: The aws-java-sdk-core jar is an optional dependency. If the aws-java-sdk-core jar is not on your
classpath, then the AWS Code Commit credential provider will not be created regardless of the git server URI.</simpara>
</section>
<section xml:id="_git_ssh_configuration_using_properties">
<title>Git SSH configuration using properties</title>
<simpara>By default, the JGit library used by Spring Cloud Config Server uses SSH configuration files such as <literal>~/.ssh/known_hosts</literal> and <literal>/etc/ssh/ssh_config</literal> when connecting to Git repositories using an SSH URI.
In cloud environments such as Cloud Foundry, the local filesystem may be ephemeral or not easily accessible. For cases such as these, SSH configuration can be set using
Java properties. In order to activate property based SSH configuration, the property <literal>spring.cloud.config.server.git.ignoreLocalSshSettings</literal> must be set to <literal>true</literal>.
Example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  spring:
    cloud:
      config:
        server:
          git:
            uri: git@gitserver.com:team/repo1.git
            ignoreLocalSshSettings: true
            hostKey: someHostKey
            hostKeyAlgorithm: ssh-rsa
            privateKey: |
                         -----BEGIN RSA PRIVATE KEY-----
                         MIIEpgIBAAKCAQEAx4UbaDzY5xjW6hc9jwN0mX33XpTDVW9WqHp5AKaRbtAC3DqX
                         IXFMPgw3K45jxRb93f8tv9vL3rD9CUG1Gv4FM+o7ds7FRES5RTjv2RT/JVNJCoqF
                         ol8+ngLqRZCyBtQN7zYByWMRirPGoDUqdPYrj2yq+ObBBNhg5N+hOwKjjpzdj2Ud
                         1l7R+wxIqmJo1IYyy16xS8WsjyQuyC0lL456qkd5BDZ0Ag8j2X9H9D5220Ln7s9i
                         oezTipXipS7p7Jekf3Ywx6abJwOmB0rX79dV4qiNcGgzATnG1PkXxqt76VhcGa0W
                         DDVHEEYGbSQ6hIGSh0I7BQun0aLRZojfE3gqHQIDAQABAoIBAQCZmGrk8BK6tXCd
                         fY6yTiKxFzwb38IQP0ojIUWNrq0+9Xt+NsypviLHkXfXXCKKU4zUHeIGVRq5MN9b
                         BO56/RrcQHHOoJdUWuOV2qMqJvPUtC0CpGkD+valhfD75MxoXU7s3FK7yjxy3rsG
                         EmfA6tHV8/4a5umo5TqSd2YTm5B19AhRqiuUVI1wTB41DjULUGiMYrnYrhzQlVvj
                         5MjnKTlYu3V8PoYDfv1GmxPPh6vlpafXEeEYN8VB97e5x3DGHjZ5UrurAmTLTdO8
                         +AahyoKsIY612TkkQthJlt7FJAwnCGMgY6podzzvzICLFmmTXYiZ/28I4BX/mOSe
                         pZVnfRixAoGBAO6Uiwt40/PKs53mCEWngslSCsh9oGAaLTf/XdvMns5VmuyyAyKG
                         ti8Ol5wqBMi4GIUzjbgUvSUt+IowIrG3f5tN85wpjQ1UGVcpTnl5Qo9xaS1PFScQ
                         xrtWZ9eNj2TsIAMp/svJsyGG3OibxfnuAIpSXNQiJPwRlW3irzpGgVx/AoGBANYW
                         dnhshUcEHMJi3aXwR12OTDnaLoanVGLwLnkqLSYUZA7ZegpKq90UAuBdcEfgdpyi
                         PhKpeaeIiAaNnFo8m9aoTKr+7I6/uMTlwrVnfrsVTZv3orxjwQV20YIBCVRKD1uX
                         VhE0ozPZxwwKSPAFocpyWpGHGreGF1AIYBE9UBtjAoGBAI8bfPgJpyFyMiGBjO6z
                         FwlJc/xlFqDusrcHL7abW5qq0L4v3R+FrJw3ZYufzLTVcKfdj6GelwJJO+8wBm+R
                         gTKYJItEhT48duLIfTDyIpHGVm9+I1MGhh5zKuCqIhxIYr9jHloBB7kRm0rPvYY4
                         VAykcNgyDvtAVODP+4m6JvhjAoGBALbtTqErKN47V0+JJpapLnF0KxGrqeGIjIRV
                         cYA6V4WYGr7NeIfesecfOC356PyhgPfpcVyEztwlvwTKb3RzIT1TZN8fH4YBr6Ee
                         KTbTjefRFhVUjQqnucAvfGi29f+9oE3Ei9f7wA+H35ocF6JvTYUsHNMIO/3gZ38N
                         CPjyCMa9AoGBAMhsITNe3QcbsXAbdUR00dDsIFVROzyFJ2m40i4KCRM35bC/BIBs
                         q0TY3we+ERB40U8Z2BvU61QuwaunJ2+uGadHo58VSVdggqAo0BSkH58innKKt96J
                         69pcVH/4rmLbXdcmNYGm6iu+MlPQk4BUZknHSmVHIFdJ0EPupVaQ8RHT
                         -----END RSA PRIVATE KEY-----</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>SSH Configuration properties</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Property Name</entry>
<entry align="left" valign="top">Remarks</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">ignoreLocalSshSettings</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>If true, use property based SSH config instead of file based. Must be set at as <literal>spring.cloud.config.server.git.ignoreLocalSshSettings</literal>, <emphasis role="strong">not</emphasis> inside a repository definition.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">privateKey</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Valid SSH private key. Must be set if <literal>ignoreLocalSshSettings</literal> is true and Git URI is SSH format</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">hostKey</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Valid SSH host key. Must be set if <literal>hostKeyAlgorithm</literal> is also set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">hostKeyAlgorithm</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>One of <literal>ssh-dss, ssh-rsa, ecdsa-sha2-nistp256, ecdsa-sha2-nistp384 ,ecdsa-sha2-nistp521</literal>. Must be set if <literal>hostKey</literal> is also set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">strictHostKeyChecking</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal> or <literal>false</literal>. If false, ignore errors with host key</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">knownHostsFile</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Location of custom .known_hosts file</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">preferredAuthentications</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Override server authentication method order. This should allow evade login prompts if server has keyboard-interactive authentication before <literal>publickey</literal> method.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="_placeholders_in_git_search_paths">
<title>Placeholders in Git Search Paths</title>
<simpara>Spring Cloud Config Server also supports a search path with
placeholders for the <literal>{application}</literal> and <literal>{profile}</literal> (and <literal>{label}</literal> if
you need it). Example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          searchPaths: '{application}'</programlisting>
<simpara>searches the repository for files in the same name as the directory
(as well as the top level). Wildcards are also valid in a search
path with placeholders (any matching directory is included in the
search).</simpara>
</section>
<section xml:id="_force_pull_in_git_repositories">
<title>Force pull in Git Repositories</title>
<simpara>As mentioned before Spring Cloud Config Server makes a clone of the
remote git repository and if somehow the local copy gets dirty (e.g.
folder content changes by OS process) so Spring Cloud Config Server
cannot update the local copy from remote repository.</simpara>
<simpara>To solve this there is a <literal>force-pull</literal> property that will make Spring Cloud
Config Server force pull from remote repository if the local copy is dirty.
Example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          force-pull: true</programlisting>
<simpara>If you have a multiple repositories configuration you can configure the
<literal>force-pull</literal> property per repository. Example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        git:
          uri: https://git/common/config-repo.git
          force-pull: true
          repos:
            team-a:
                pattern: team-a-*
                uri: https://git/team-a/config-repo.git
                force-pull: true
            team-b:
                pattern: team-b-*
                uri: https://git/team-b/config-repo.git
                force-pull: true
            team-c:
                pattern: team-c-*
                uri: https://git/team-a/config-repo.git</programlisting>
<note>
<simpara>The default value for <literal>force-pull</literal> property is <literal>false</literal>.</simpara>
</note>
</section>
</section>
<section xml:id="_version_control_backend_filesystem_use">
<title>Version Control Backend Filesystem Use</title>
<warning>
<simpara>With VCS based backends (git, svn) files are checked out or cloned to the local filesystem. By default they are put in the system temporary directory with a prefix of <literal>config-repo-</literal>. On linux, for example it could be <literal>/tmp/config-repo-&lt;randomid&gt;</literal>. Some operating systems <link xl:href="https://serverfault.com/questions/377348/when-does-tmp-get-cleared/377349#377349">routinely clean out</link> temporary directories. This can lead to unexpected behaviour such as missing properties. To avoid this problem, change the directory Config Server uses, by setting <literal>spring.cloud.config.server.git.basedir</literal> or <literal>spring.cloud.config.server.svn.basedir</literal> to a directory that does not reside in the system temp structure.</simpara>
</warning>
</section>
<section xml:id="_file_system_backend">
<title>File System Backend</title>
<simpara>There is also a "native" profile in the Config Server that doesn&#8217;t use
Git, but just loads the config files from the local classpath or file
system (any static URL you want to point to with
"spring.cloud.config.server.native.searchLocations"). To use the
native profile just launch the Config Server with
"spring.profiles.active=native".</simpara>
<note>
<simpara>Remember to use the <literal>file:</literal> prefix for file resources (the
default without a prefix is usually the classpath). Just as with any
Spring Boot configuration you can embed <literal>${}</literal>-style environment
placeholders, but remember that absolute paths in Windows require an
extra "/", e.g. <literal><link xl:href="file:///${user.home}/config-repo">file:///${user.home}/config-repo</link></literal></simpara>
</note>
<warning>
<simpara>The default value of the <literal>searchLocations</literal> is identical to a
local Spring Boot application (so <literal>[classpath:/, classpath:/config,
file:./, file:./config]</literal>). This does not expose the
<literal>application.properties</literal> from the server to all clients because any
property sources present in the server are removed before being sent
to the client.</simpara>
</warning>
<tip>
<simpara>A filesystem backend is great for getting started quickly and
for testing. To use it in production you need to be sure that the
file system is reliable, and shared across all instances of the
Config Server.</simpara>
</tip>
<simpara>The search locations can contain placeholders for <literal>{application}</literal>,
<literal>{profile}</literal> and <literal>{label}</literal>. In this way you can segregate the
directories in the path, and choose a strategy that makes sense for
you (e.g. sub-directory per application, or sub-directory per
profile).</simpara>
<simpara>If you don&#8217;t use placeholders in the search locations, this repository
also appends the <literal>{label}</literal> parameter of the HTTP resource to a suffix
on the search path, so properties files are loaded from each search
location <emphasis role="strong">and</emphasis> a subdirectory with the same name as the label (the
labelled properties take precedence in the Spring Environment). Thus
the default behaviour with no placeholders is the same as adding a
search location ending with <literal>/{label}/</literal>. For example <literal>file:/tmp/config</literal>
is the same as <literal>file:/tmp/config,file:/tmp/config/{label}</literal>. This behavior can be
disabled by setting <literal>spring.cloud.config.server.native.addLabelLocations=false</literal>.</simpara>
</section>
<section xml:id="_vault_backend">
<title>Vault Backend</title>
<simpara>Spring Cloud Config Server also supports <link xl:href="https://www.vaultproject.io">Vault</link> as a backend.</simpara>
<sidebar>
<simpara>Vault is a tool for securely accessing secrets. A secret is anything
that you want to tightly control access to, such as API keys, passwords,
certificates, and more. Vault provides a unified interface to any secret,
while providing tight access control and recording a detailed audit log.</simpara>
</sidebar>
<simpara>For more information on Vault see the <link xl:href="https://www.vaultproject.io/intro/index.html">Vault quickstart guide</link>.</simpara>
<simpara>To enable the config server to use a Vault backend you can run your config server
with the <literal>vault</literal> profile.  For example in your config server&#8217;s <literal>application.properties</literal>
you can add <literal>spring.profiles.active=vault</literal>.</simpara>
<simpara>By default the config server will assume your Vault server is running at
<literal><link xl:href="http://127.0.0.1:8200">http://127.0.0.1:8200</link></literal>.  It also will assume that the name of backend
is <literal>secret</literal> and the key is <literal>application</literal>.  All of these defaults can be
configured in your config server&#8217;s <literal>application.properties</literal>.  Below is a
table of configurable Vault properties.  All properties are prefixed with
<literal>spring.cloud.config.server.vault</literal>.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Default Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>host</simpara></entry>
<entry align="left" valign="top"><simpara>127.0.0.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>port</simpara></entry>
<entry align="left" valign="top"><simpara>8200</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>scheme</simpara></entry>
<entry align="left" valign="top"><simpara>http</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>backend</simpara></entry>
<entry align="left" valign="top"><simpara>secret</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>defaultKey</simpara></entry>
<entry align="left" valign="top"><simpara>application</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>profileSeparator</simpara></entry>
<entry align="left" valign="top"><simpara>,</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>All configurable properties can be found in
<literal>org.springframework.cloud.config.server.environment.VaultEnvironmentRepository</literal>.</simpara>
<simpara>With your config server running you can make HTTP requests to the server to retrieve
values from the Vault backend.  To do this you will need a token for your Vault server.</simpara>
<simpara>First place some data in you Vault.  For example</simpara>
<programlisting language="sh" linenumbering="unnumbered">$ vault write secret/application foo=bar baz=bam
$ vault write secret/myapp foo=myappsbar</programlisting>
<simpara>Now make the HTTP request to your config server to retrieve the values.</simpara>
<simpara><literal>$ curl -X "GET" "http://localhost:8888/myapp/default" -H "X-Config-Token: yourtoken"</literal></simpara>
<simpara>You should see a response similar to this after making the above request.</simpara>
<programlisting language="json" linenumbering="unnumbered">{
   "name":"myapp",
   "profiles":[
      "default"
   ],
   "label":null,
   "version":null,
   "state":null,
   "propertySources":[
      {
         "name":"vault:myapp",
         "source":{
            "foo":"myappsbar"
         }
      },
      {
         "name":"vault:application",
         "source":{
            "baz":"bam",
            "foo":"bar"
         }
      }
   ]
}</programlisting>
<section xml:id="_multiple_properties_sources">
<title>Multiple Properties Sources</title>
<simpara>When using Vault you can provide your applications with multiple properties sources.
For example, assume you have written data to the following paths in Vault.</simpara>
<programlisting language="sh" linenumbering="unnumbered">secret/myApp,dev
secret/myApp
secret/application,dev
secret/application</programlisting>
<simpara>Properties written to <literal>secret/application</literal> are available to
<link linkend="_vault_server">all applications using the Config Server</link>.  An
application with the name <literal>myApp</literal> would have any properties
written to <literal>secret/myApp</literal> and <literal>secret/application</literal> available to it.
When <literal>myApp</literal> has the <literal>dev</literal> profile enabled then properties written to
all of the above paths would be available to it, with properties in
the first path in the list taking priority over the others.</simpara>
</section>
</section>
<section xml:id="_sharing_configuration_with_all_applications">
<title>Sharing Configuration With All Applications</title>
<section xml:id="_file_based_repositories">
<title>File Based Repositories</title>
<simpara>With file-based (i.e. git, svn and native) repositories, resources
with file names in <literal>application*</literal> are shared between all client
applications (so <literal>application.properties</literal>, <literal>application.yml</literal>,
<literal>application-*.properties</literal> etc.). You can use resources with these
file names to configure global defaults and have them overridden by
application-specific files as necessary.</simpara>
<simpara>The #_property_overrides[property overrides] feature can also be used
for setting global defaults, and with placeholders applications are
allowed to override them locally.</simpara>
<tip>
<simpara>With the "native" profile (local file system backend) it is
recommended that you use an explicit search location that isn&#8217;t part
of the server&#8217;s own configuration. Otherwise the <literal>application*</literal>
resources in the default search locations are removed because they are
part of the server.</simpara>
</tip>
</section>
<section xml:id="_vault_server">
<title>Vault Server</title>
<simpara>When using Vault as a backend you can share configuration with
all applications by placing configuration in
<literal>secret/application</literal>.  For example, if you run this Vault command</simpara>
<programlisting language="sh" linenumbering="unnumbered">$ vault write secret/application foo=bar baz=bam</programlisting>
<simpara>All applications using the config server will have the properties
<literal>foo</literal> and <literal>baz</literal> available to them.</simpara>
</section>
</section>
<section xml:id="_jdbc_backend">
<title>JDBC Backend</title>
<simpara>Spring Cloud Config Server supports JDBC (relation database) as a
backend for configuration properties. You can enable this feature by
adding <literal>spring-jdbc</literal> to the classpath, and using the "jdbc" profile,
or by adding a bean of type <literal>JdbcEnvironmentRepository</literal>. Spring Boot
will configure a data source if you include the right dependencies on
the classpath (see the user guide for more details on that).</simpara>
<simpara>The database needs to have a table called "PROPERTIES" with columns
"APPLICATION", "PROFILE", "LABEL" (with the usual <literal>Environment</literal>
meaning), plus "KEY" and "VALUE" for the key and value pairs in
<literal>Properties</literal> style. All fields are of type String in Java, so you can
make them <literal>VARCHAR</literal> of whatever length you need. Property values
behave in the same way as they would if they came from Spring Boot
properties files named <literal>{application}-{profile}.properties</literal>, including
all the encryption and decryption, which will be applied as
post-processing steps (i.e. not in the repository implementation
directly).</simpara>
</section>
<section xml:id="_composite_environment_repositories">
<title>Composite Environment Repositories</title>
<simpara>In some scenarios you may wish to pull configuration data from multiple
environment repositories.  To do this you can just enable
multiple profiles in your config server&#8217;s application properties or YAML file.
If, for example, you want to pull configuration data from a Git repository
as well as a SVN repository you would set the following properties for your
configuration server.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  profiles:
    active: git, svn
  cloud:
    config:
      server:
        svn:
          uri: file:///path/to/svn/repo
          order: 2
        git:
          uri: file:///path/to/git/repo
          order: 1</programlisting>
<simpara>In addition to each repo specifying a URI, you can also specify an <literal>order</literal> property.
The <literal>order</literal> property allows you to specify the priority order for all your repositories.
The lower the numerical value of the <literal>order</literal> property the higher priority it will have.
The priority order of a repository will help resolve any potential conflicts between
repositories that contain values for the same properties.</simpara>
<note>
<simpara>Any type of failure when retrieving values from an environment repositoy
will result in a failure for the entire composite environment.</simpara>
</note>
<note>
<simpara>When using a composite environment it is important that all repos contain
the same label(s).  If you have an environment similar to the one above and you request
configuration data with the label <literal>master</literal> but the SVN
repo does not contain a branch called <literal>master</literal> the entire request will fail.</simpara>
</note>
<section xml:id="_custom_composite_environment_repositories">
<title>Custom Composite Environment Repositories</title>
<simpara>It is also possible to provide your own <literal>EnvironmentRepository</literal> bean
to be included as part of a composite environment in addition to
using one of the environment repositories from Spring Cloud.  To do this your bean
must implement the <literal>EnvironmentRepository</literal> interface.  If you would like to control
the priority of you custom <literal>EnvironmentRepository</literal> within the composite
environment you should also implement the <literal>Ordered</literal> interface and override the
<literal>getOrdered</literal> method.  If you do not implement the <literal>Ordered</literal> interface then your
<literal>EnvironmentRepository</literal> will be given the lowest priority.</simpara>
</section>
</section>
<section xml:id="_property_overrides">
<title>Property Overrides</title>
<simpara>The Config Server has an "overrides" feature that allows the operator
to provide configuration properties to all applications that cannot be
accidentally changed by the application using the normal Spring Boot
hooks. To declare overrides just add a map of name-value pairs to
<literal>spring.cloud.config.server.overrides</literal>. For example</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        overrides:
          foo: bar</programlisting>
<simpara>will cause all applications that are config clients to read <literal>foo=bar</literal>
independent of their own configuration. (Of course an application can
use the data in the Config Server in any way it likes, so overrides
are not enforceable, but they do provide useful default behaviour if
they are Spring Cloud Config clients.)</simpara>
<tip>
<simpara>Normal, Spring environment placeholders with "${}" can be escaped
(and resolved on the client) by using backslash ("\") to escape the
"$" or the "{", e.g. <literal>\${app.foo:bar}</literal> resolves to "bar" unless the
app provides its own "app.foo". Note that in YAML you don&#8217;t need to
escape the backslash itself, but in properties files you do, when you
configure the overrides on the server.</simpara>
</tip>
<simpara>You can change the priority of all overrides in the client to be more
like default values, allowing applications to supply their own values
in environment variables or System properties, by setting the flag
<literal>spring.cloud.config.overrideNone=true</literal> (default is false) in the
remote repository.</simpara>
</section>
</section>
<section xml:id="_health_indicator_2">
<title>Health Indicator</title>
<simpara>Config Server comes with a Health Indicator that checks if the configured
<literal>EnvironmentRepository</literal> is working.  By default it asks the <literal>EnvironmentRepository</literal>
for an application named <literal>app</literal>, the <literal>default</literal> profile and the default
label provided by the <literal>EnvironmentRepository</literal> implementation.</simpara>
<simpara>You can configure the Health Indicator to check more applications
along with custom profiles and custom labels, e.g.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      server:
        health:
          repositories:
            myservice:
              label: mylabel
            myservice-dev:
              name: myservice
              profiles: development</programlisting>
<simpara>You can disable the Health Indicator by setting <literal>spring.cloud.config.server.health.enabled=false</literal>.</simpara>
</section>
<section xml:id="_security">
<title>Security</title>
<simpara>You are free to secure your Config Server in any way that makes sense
to you (from physical network security to OAuth2 bearer
tokens), and Spring Security and Spring Boot make it easy to do pretty
much anything.</simpara>
<simpara>To use the default Spring Boot configured HTTP Basic security, just
include Spring Security on the classpath (e.g. through
<literal>spring-boot-starter-security</literal>). The default is a username of "user"
and a randomly generated password, which isn&#8217;t going to be very useful
in practice, so we recommend you configure the password (via
<literal>security.user.password</literal>) and encrypt it (see below for instructions
on how to do that).</simpara>
</section>
<section xml:id="_encryption_and_decryption_2">
<title>Encryption and Decryption</title>
<important>
<simpara><emphasis role="strong">Prerequisites:</emphasis> to use the encryption and decryption features
you need the full-strength JCE installed in your JVM (it&#8217;s not there by default).
You can download the "Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files"
from Oracle, and follow instructions for installation (essentially replace the 2 policy files
in the JRE lib/security directory with the ones that you downloaded).</simpara>
</important>
<simpara>If the remote property sources contain encrypted content (values
starting with <literal>{cipher}</literal>) they will be decrypted before sending to
clients over HTTP. The main advantage of this set up is that the
property values don&#8217;t have to be in plain text when they are "at rest"
(e.g. in a git repository). If a value cannot be decrypted it is
removed from the property source and an additional property is added
with the same key, but prefixed with "invalid." and a value that means
"not applicable" (usually "&lt;n/a&gt;"). This is largely to prevent cipher
text being used as a password and accidentally leaking.</simpara>
<simpara>If you are setting up a remote config repository for config client
applications it might contain an <literal>application.yml</literal> like this, for
instance:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  datasource:
    username: dbuser
    password: '{cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ'</programlisting>
</para>
</formalpara>
<simpara>Encrypted values in a .properties file must not be wrapped in quotes, otherwise the value will not be decrypted:</simpara>
<formalpara>
<title>application.properties</title>
<para>
<screen>spring.datasource.username: dbuser
spring.datasource.password: {cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ</screen>
</para>
</formalpara>
<simpara>You can safely push this plain text to a shared git repository and the
secret password is protected.</simpara>
<simpara>The server also exposes <literal>/encrypt</literal> and <literal>/decrypt</literal> endpoints (on the
assumption that these will be secured and only accessed by authorized
agents). If you are editing a remote config file you can use the Config Server
to encrypt values by POSTing to the <literal>/encrypt</literal> endpoint, e.g.</simpara>
<screen>$ curl localhost:8888/encrypt -d mysecret
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda</screen>
<note>
<simpara>If the value you are encrypting has characters in it that need to be URL encoded you should use
the <literal>--data-urlencode</literal> option to <literal>curl</literal> to make sure they are encoded properly.</simpara>
</note>
<tip>
<simpara>Be sure not to include any of the curl command statistics in the encrypted value.
Outputting the value to a file can help avoid this problem.</simpara>
</tip>
<simpara>The inverse operation is also available via <literal>/decrypt</literal> (provided the server is
configured with a symmetric key or a full key pair):</simpara>
<screen>$ curl localhost:8888/decrypt -d 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</screen>
<tip>
<simpara>If you are testing like this with curl, then use
<literal>--data-urlencode</literal> (instead of <literal>-d</literal>) or set an explicit <literal>Content-Type:
text/plain</literal> to make sure curl encodes the data correctly when there
are special characters ('+' is particularly tricky).</simpara>
</tip>
<simpara>Take the encrypted value and add the <literal>{cipher}</literal> prefix before you put
it in the YAML or properties file, and before you commit and push it
to a remote, potentially insecure store.</simpara>
<simpara>The <literal>/encrypt</literal> and <literal>/decrypt</literal> endpoints also both accept paths of the
form <literal>/*/{name}/{profiles}</literal> which can be used to control cryptography
per application (name) and profile when clients call into the main
Environment resource.</simpara>
<note>
<simpara>to control the cryptography in this granular way you must also
provide a <literal>@Bean</literal> of type <literal>TextEncryptorLocator</literal> that creates a
different encryptor per name and profiles. The one that is provided
by default does not do this (so all encryptions use the same key).</simpara>
</note>
<simpara>The <literal>spring</literal> command line client (with Spring Cloud CLI extensions
installed) can also be used to encrypt and decrypt, e.g.</simpara>
<screen>$ spring encrypt mysecret --key foo
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
$ spring decrypt --key foo 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</screen>
<simpara>To use a key in a file (e.g. an RSA public key for encryption) prepend
the key value with "@" and provide the file path, e.g.</simpara>
<screen>$ spring encrypt mysecret --key @${HOME}/.ssh/id_rsa.pub
AQAjPgt3eFZQXwt8tsHAVv/QHiY5sI2dRcR+...</screen>
<simpara>The key argument is mandatory (despite having a <literal>--</literal> prefix).</simpara>
</section>
<section xml:id="_key_management">
<title>Key Management</title>
<simpara>The Config Server can use a symmetric (shared) key or an asymmetric
one (RSA key pair). The asymmetric choice is superior in terms of
security, but it is often more convenient to use a symmetric key since
it is just a single property value to configure in the <literal>bootstrap.properties</literal>.</simpara>
<simpara>To configure a symmetric key you just need to set <literal>encrypt.key</literal> to a
secret String (or use an enviroment variable <literal>ENCRYPT_KEY</literal> to keep it
out of plain text configuration files).</simpara>
<simpara>To configure an asymmetric key you can either set the key as a
PEM-encoded text value (in <literal>encrypt.key</literal>), or via a keystore (e.g. as
created by the <literal>keytool</literal> utility that comes with the JDK). The
keystore properties are <literal>encrypt.keyStore.*</literal> with <literal>*</literal> equal to</simpara>
<itemizedlist>
<listitem>
<simpara><literal>location</literal> (a <literal>Resource</literal> location),</simpara>
</listitem>
<listitem>
<simpara><literal>password</literal> (to unlock the keystore) and</simpara>
</listitem>
<listitem>
<simpara><literal>alias</literal> (to identify which key in the store is to be
used).</simpara>
</listitem>
</itemizedlist>
<simpara>The encryption is done with the public key, and a private key is
needed for decryption. Thus in principle you can configure only the
public key in the server if you only want to do encryption (and are
prepared to decrypt the values yourself locally with the private
key). In practice you might not want to do that because it spreads the
key management process around all the clients, instead of
concentrating it in the server. On the other hand it&#8217;s a useful option
if your config server really is relatively insecure and only a
handful of clients need the encrypted properties.</simpara>
</section>
<section xml:id="_creating_a_key_store_for_testing">
<title>Creating a Key Store for Testing</title>
<simpara>To create a keystore for testing you can do something like this:</simpara>
<screen>$ keytool -genkeypair -alias mytestkey -keyalg RSA \
  -dname "CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US" \
  -keypass changeme -keystore server.jks -storepass letmein</screen>
<simpara>Put the <literal>server.jks</literal> file in the classpath (for instance) and then in
your <literal>bootstrap.yml</literal> for the Config Server:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">encrypt:
  keyStore:
    location: classpath:/server.jks
    password: letmein
    alias: mytestkey
    secret: changeme</programlisting>
</section>
<section xml:id="_using_multiple_keys_and_key_rotation">
<title>Using Multiple Keys and Key Rotation</title>
<simpara>In addition to the <literal>{cipher}</literal> prefix in encrypted property values, the
Config Server looks for <literal>{name:value}</literal> prefixes (zero or many) before
the start of the (Base64 encoded) cipher text. The keys are passed to
a <literal>TextEncryptorLocator</literal> which can do whatever logic it needs to
locate a <literal>TextEncryptor</literal> for the cipher. If you have configured a
keystore (<literal>encrypt.keystore.location</literal>) the default locator will look
for keys in the store with aliases as supplied by the "key" prefix,
i.e. with a cipher text like this:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">foo:
  bar: `{cipher}{key:testkey}...`</programlisting>
<simpara>the locator will look for a key named "testkey". A secret can also be
supplied via a <literal>{secret:&#8230;&#8203;}</literal> value in the prefix, but if it is not
the default is to use the keystore password (which is what you get
when you build a keytore and don&#8217;t specify a secret). If you <emphasis role="strong">do</emphasis>
supply a secret it is recommended that you also encrypt the secrets
using a custom <literal>SecretLocator</literal>.</simpara>
<simpara>Key rotation is hardly ever necessary on cryptographic grounds if the
keys are only being used to encrypt a few bytes of configuration data
(i.e. they are not being used elsewhere), but occasionally you might
need to change the keys if there is a security breach for instance. In
that case all the clients would need to change their source config
files (e.g. in git) and use a new <literal>{key:&#8230;&#8203;}</literal> prefix in all the
ciphers, checking beforehand of course that the key alias is available
in the Config Server keystore.</simpara>
<tip>
<simpara>the <literal>{name:value}</literal> prefixes can also be added to plaintext posted
to the <literal>/encrypt</literal> endpoint, if you want to let the Config Server
handle all encryption as well as decryption.</simpara>
</tip>
</section>
<section xml:id="_serving_encrypted_properties">
<title>Serving Encrypted Properties</title>
<simpara>Sometimes you want the clients to decrypt the configuration locally,
instead of doing it in the server. In that case you can still have
/encrypt and /decrypt endpoints (if you provide the <literal>encrypt.*</literal>
configuration to locate a key), but you need to explicitly switch off
the decryption of outgoing properties using
<literal>spring.cloud.config.server.encrypt.enabled=false</literal>. If you don&#8217;t care
about the endpoints, then it should work if you configure neither the
key nor the enabled flag.</simpara>
</section>
</chapter>
<chapter xml:id="_serving_alternative_formats">
<title>Serving Alternative Formats</title>
<simpara>The default JSON format from the environment endpoints is perfect for
consumption by Spring applications because it maps directly onto the
<literal>Environment</literal> abstraction. If you prefer you can consume the same data
as YAML or Java properties by adding a suffix to the resource path
(".yml", ".yaml" or ".properties"). This can be useful for consumption
by applications that do not care about the structure of the JSON
endpoints, or the extra metadata they provide, for example an
application that is not using Spring might benefit from the simplicity
of this approach.</simpara>
<simpara>The YAML and properties representations have an additional flag
(provided as a boolean query parameter <literal>resolvePlaceholders</literal>) to
signal that placeholders in the source documents, in the standard
Spring <literal>${&#8230;&#8203;}</literal> form, should be resolved in the output where possible
before rendering. This is a useful feature for consumers that don&#8217;t
know about the Spring placeholder conventions.</simpara>
<note>
<simpara>there are limitations in using the YAML or properties formats,
mainly in relation to the loss of metadata. The JSON is structured as
an ordered list of property sources, for example, with names that
correlate with the source. The YAML and properties forms are coalesced
into a single map, even if the origin of the values has multiple
sources, and the names of the original source files are lost. The YAML
representation is not necessarily a faithful representation of the
YAML source in a backing repository either: it is constructed from a
list of flat property sources, and assumptions have to be made about
the form of the keys.</simpara>
</note>
</chapter>
<chapter xml:id="_serving_plain_text">
<title>Serving Plain Text</title>
<simpara>Instead of using the <literal>Environment</literal> abstraction (or one of the
alternative representations of it in YAML or properties format) your
applications might need generic plain text configuration files,
tailored to their environment. The Config Server provides these
through an additional endpoint at <literal>/{name}/{profile}/{label}/{path}</literal>
where "name", "profile" and "label" have the same meaning as the
regular environment endpoint, but "path" is a file name
(e.g. <literal>log.xml</literal>). The source files for this endpoint are located in
the same way as for the environment endpoints: the same search path is
used as for properties or YAML files, but instead of aggregating all
matching resources, only the first one to match is returned.</simpara>
<simpara>After a resource is located, placeholders in the normal format
(<literal>${&#8230;&#8203;}</literal>) are resolved using the effective <literal>Environment</literal> for the
application name, profile and label supplied. In this way the resource
endpoint is tightly integrated with the environment
endpoints. Example, if you have this layout for a GIT (or SVN)
repository:</simpara>
<screen>application.yml
nginx.conf</screen>
<simpara>where <literal>nginx.conf</literal> looks like this:</simpara>
<screen>server {
    listen              80;
    server_name         ${nginx.server.name};
}</screen>
<simpara>and <literal>application.yml</literal> like this:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">nginx:
  server:
    name: example.com
---
spring:
  profiles: development
nginx:
  server:
    name: develop.com</programlisting>
<simpara>then the <literal>/foo/default/master/nginx.conf</literal> resource looks like this:</simpara>
<screen>server {
    listen              80;
    server_name         example.com;
}</screen>
<simpara>and <literal>/foo/development/master/nginx.conf</literal> like this:</simpara>
<screen>server {
    listen              80;
    server_name         develop.com;
}</screen>
<note>
<simpara>Just like the source files for environment configuration, the
"profile" is used to resolve the file name, so if you want a
profile-specific file then <literal>/*/development/*/logback.xml</literal> will be
resolved by a file called <literal>logback-development.xml</literal> (in preference
to <literal>logback.xml</literal>).</simpara>
</note>
<note>
<simpara>If you do not want to supply the <literal>label</literal> and let the server use the default label, you can supply a <literal>useDefaultLabel</literal> request parameter. So, the above example for the <literal>default</literal> profile could look like <literal>/foo/default/nginx.conf?useDefaultLabel</literal>.</simpara>
</note>
</chapter>
<chapter xml:id="_embedding_the_config_server">
<title>Embedding the Config Server</title>
<simpara>The Config Server runs best as a standalone application, but if you
need to you can embed it in another application. Just use the
<literal>@EnableConfigServer</literal> annotation. An optional property that can be
useful in this case is <literal>spring.cloud.config.server.bootstrap</literal> which is
a flag to indicate that the server should configure itself from its
own remote repository. The flag is off by default because it can delay
startup, but when embedded in another application it makes sense to
initialize the same way as any other application.</simpara>
<note>
<simpara>It should be obvious, but remember that if you use the bootstrap
flag the config server will need to have its name and repository URI
configured in <literal>bootstrap.yml</literal>.</simpara>
</note>
<simpara>To change the location of the server endpoints you can (optionally)
set <literal>spring.cloud.config.server.prefix</literal>, e.g. "/config", to serve the
resources under a prefix. The prefix should start but not end with a
"/". It is applied to the <literal>@RequestMappings</literal> in the Config Server
(i.e. underneath the Spring Boot prefixes <literal>server.servletPath</literal> and
<literal>server.contextPath</literal>).</simpara>
<simpara>If you want to read the configuration for an application directly from
the backend repository (instead of from the config server) that&#8217;s
basically an embedded config server with no endpoints. You can switch
off the endpoints entirely if you don&#8217;t use the <literal>@EnableConfigServer</literal>
annotation (just set <literal>spring.cloud.config.server.bootstrap=true</literal>).</simpara>
</chapter>
<chapter xml:id="_push_notifications_and_spring_cloud_bus">
<title>Push Notifications and Spring Cloud Bus</title>
<simpara>Many source code repository providers (like Github, Gitlab or Bitbucket
for instance) will notify you of changes in a repository through a
webhook. You can configure the webhook via the provider&#8217;s user
interface as a URL and a set of events in which you are
interested. For instance
<link xl:href="https://developer.github.com/v3/activity/events/types/#pushevent">Github</link>
will POST to the webhook with a JSON body containing a list of
commits, and a header "X-Github-Event" equal to "push". If you add a
dependency on the <literal>spring-cloud-config-monitor</literal> library and activate
the Spring Cloud Bus in your Config Server, then a "/monitor" endpoint
is enabled.</simpara>
<simpara>When the webhook is activated the Config Server will send a
<literal>RefreshRemoteApplicationEvent</literal> targeted at the applications it thinks
might have changed. The change detection can be strategized, but by
default it just looks for changes in files that match the application
name (e.g. "foo.properties" is targeted at the "foo" application, and
"application.properties" is targeted at all applications). The strategy
if you want to override the behaviour is <literal>PropertyPathNotificationExtractor</literal>
which accepts the request headers and body as parameters and returns a list
of file paths that changed.</simpara>
<simpara>The default configuration works out of the box with Github, Gitlab or
Bitbucket. In addition to the JSON notifications from Github, Gitlab
or Bitbucket you can trigger a change notification by POSTing to
"/monitor" with a form-encoded body parameters <literal>path={name}</literal>. This will
broadcast to applications matching the "{name}" pattern (can contain
wildcards).</simpara>
<note>
<simpara>the <literal>RefreshRemoteApplicationEvent</literal> will only be transmitted if
the <literal>spring-cloud-bus</literal> is activated in the Config Server and in the
client application.</simpara>
</note>
<note>
<simpara>the default configuration also detects filesystem changes in
local git repositories (the webhook is not used in that case but as
soon as you edit a config file a refresh will be broadcast).</simpara>
</note>
</chapter>
<chapter xml:id="_spring_cloud_config_client">
<title>Spring Cloud Config Client</title>
<simpara>A Spring Boot application can take immediate advantage of the Spring
Config Server (or other external property sources provided by the
application developer), and it will also pick up some additional
useful features related to <literal>Environment</literal> change events.</simpara>
<section xml:id="config-first-bootstrap">
<title>Config First Bootstrap</title>
<simpara>This is the default behaviour for any application which has the Spring
Cloud Config Client on the classpath. When a config client starts up
it binds to the Config Server (via the bootstrap configuration
property <literal>spring.cloud.config.uri</literal>) and initializes Spring
<literal>Environment</literal> with remote property sources.</simpara>
<simpara>The net result of this is that all client apps that want to consume
the Config Server need a <literal>bootstrap.yml</literal> (or an environment variable)
with the server address in <literal>spring.cloud.config.uri</literal> (defaults to
"http://localhost:8888").</simpara>
</section>
<section xml:id="discovery-first-bootstrap">
<title>Discovery First Bootstrap</title>
<simpara>If you are using a `DiscoveryClient implementation, such as Spring Cloud Netflix
and Eureka Service Discovery or Spring Cloud Consul (Spring Cloud Zookeeper does
not support this yet), then you can have the Config Server register with the
Discovery Service if you want to, but in the default "Config First" mode,
clients won&#8217;t be able to take advantage of the registration.</simpara>
<simpara>If you prefer to use <literal>DiscoveryClient</literal> to locate the Config Server, you can do
that by setting <literal>spring.cloud.config.discovery.enabled=true</literal> (default
"false"). The net result of that is that client apps all need a
<literal>bootstrap.yml</literal> (or an environment variable) with the appropriate discovery
configuration. For example, with Spring Cloud Netflix, you need to define the
Eureka server address, e.g. in <literal>eureka.client.serviceUrl.defaultZone</literal>.  The
price for using this option is an extra network round trip on start up to
locate the service registration. The benefit is that the Config Server
can change its co-ordinates, as long as the Discovery Service is a fixed point. The
default service id is "configserver" but you can change that on the
client with <literal>spring.cloud.config.discovery.serviceId</literal> (and on the server
in the usual way for a service, e.g. by setting <literal>spring.application.name</literal>).</simpara>
<simpara>The discovery client implementations all support some kind of metadata
map (e.g. for Eureka we have <literal>eureka.instance.metadataMap</literal>). Some
additional properties of the Config Server may need to be configured
in its service registration metadata so that clients can connect
correctly. If the Config Server is secured with HTTP Basic you can
configure the credentials as "username" and "password". And if the
Config Server has a context path you can set "configPath". Example,
for a Config Server that is a Eureka client:</simpara>
<formalpara>
<title>bootstrap.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">eureka:
  instance:
    ...
    metadataMap:
      user: osufhalskjrtl
      password: lviuhlszvaorhvlo5847
      configPath: /config</programlisting>
</para>
</formalpara>
</section>
<section xml:id="config-client-fail-fast">
<title>Config Client Fail Fast</title>
<simpara>In some cases, it may be desirable to fail startup of a service if
it cannot connect to the Config Server.  If this is the desired
behavior, set the bootstrap configuration property
<literal>spring.cloud.config.failFast=true</literal> and the client will halt with
an Exception.</simpara>
</section>
<section xml:id="config-client-retry">
<title>Config Client Retry</title>
<simpara>If you expect that the config server may occasionally be unavailable when
your app starts, you can ask it to keep trying after a failure. First you need
to set <literal>spring.cloud.config.failFast=true</literal>, and then you need to add
<literal>spring-retry</literal> and <literal>spring-boot-starter-aop</literal> to your classpath. The default
behaviour is to retry 6 times with an initial backoff interval of 1000ms and an
exponential multiplier of 1.1 for subsequent backoffs. You can configure these
properties (and others) using <literal>spring.cloud.config.retry.*</literal> configuration properties.</simpara>
<tip>
<simpara>To take full control of the retry add a <literal>@Bean</literal> of type
<literal>RetryOperationsInterceptor</literal> with id "configServerRetryInterceptor". Spring
Retry has a <literal>RetryInterceptorBuilder</literal> that makes it easy to create one.</simpara>
</tip>
</section>
<section xml:id="_locating_remote_configuration_resources">
<title>Locating Remote Configuration Resources</title>
<simpara>The Config Service serves property sources from <literal>/{name}/{profile}/{label}</literal>, where the default bindings in the client app are</simpara>
<itemizedlist>
<listitem>
<simpara>"name" = <literal>${spring.application.name}</literal></simpara>
</listitem>
<listitem>
<simpara>"profile" = <literal>${spring.profiles.active}</literal> (actually <literal>Environment.getActiveProfiles()</literal>)</simpara>
</listitem>
<listitem>
<simpara>"label" = "master"</simpara>
</listitem>
</itemizedlist>
<simpara>All of them can be overridden by setting <literal>spring.cloud.config.*</literal>
(where <literal>*</literal> is "name", "profile" or "label"). The "label" is useful for
rolling back to previous versions of configuration; with the default
Config Server implementation it can be a git label, branch name or
commit id. Label can also be provided as a comma-separated list, in
which case the items in the list are tried on-by-one until one succeeds.
This can be useful when working on a feature branch, for instance,
when you might want to align the config label with your branch, but
make it optional (e.g. <literal>spring.cloud.config.label=myfeature,develop</literal>).</simpara>
</section>
<section xml:id="_security_2">
<title>Security</title>
<simpara>If you use HTTP Basic security on the server then clients just need to
know the password (and username if it isn&#8217;t the default). You can do
that via the config server URI, or via separate username and password
properties, e.g.</simpara>
<formalpara>
<title>bootstrap.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
     uri: https://user:secret@myconfig.mycompany.com</programlisting>
</para>
</formalpara>
<simpara>or</simpara>
<formalpara>
<title>bootstrap.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
     uri: https://myconfig.mycompany.com
     username: user
     password: secret</programlisting>
</para>
</formalpara>
<simpara>The <literal>spring.cloud.config.password</literal> and <literal>spring.cloud.config.username</literal>
values override anything that is provided in the URI.</simpara>
<simpara>If you deploy your apps on Cloud Foundry then the best way to provide
the password is through service credentials, e.g. in the URI, since
then it doesn&#8217;t even need to be in a config file. An example which
works locally and for a user-provided service on Cloud Foundry named
"configserver":</simpara>
<formalpara>
<title>bootstrap.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
     uri: ${vcap.services.configserver.credentials.uri:http://user:password@localhost:8888}</programlisting>
</para>
</formalpara>
<simpara>If you use another form of security you might need to <link linkend="custom-rest-template">provide a
<literal>RestTemplate</literal></link> to the <literal>ConfigServicePropertySourceLocator</literal> (e.g. by
grabbing it in the bootstrap context and injecting one).</simpara>
<section xml:id="_health_indicator_3">
<title>Health Indicator</title>
<simpara>The Config Client supplies a Spring Boot Health Indicator that attempts to load configuration from Config Server. The health indicator can be disabled by setting <literal>health.config.enabled=false</literal>. The response is also cached for performance reasons. The default cache time to live is 5 minutes. To change that value set the <literal>health.config.time-to-live</literal> property (in milliseconds).</simpara>
</section>
<section xml:id="custom-rest-template">
<title>Providing A Custom RestTemplate</title>
<simpara>In some cases you might need to customize the requests made to the config server from
the client.  Typically this involves passing special <literal>Authorization</literal> headers to
authenticate requests to the server.  To provide a custom <literal>RestTemplate</literal> follow the
steps below.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a new configuration bean with an implementation of <literal>PropertySourceLocator</literal>.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>CustomConfigServiceBootstrapConfiguration.java</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@Configuration
public class CustomConfigServiceBootstrapConfiguration {
    @Bean
    public ConfigServicePropertySourceLocator configServicePropertySourceLocator() {
        ConfigClientProperties clientProperties = configClientProperties();
       ConfigServicePropertySourceLocator configServicePropertySourceLocator =  new ConfigServicePropertySourceLocator(clientProperties);
        configServicePropertySourceLocator.setRestTemplate(customRestTemplate(clientProperties));
        return configServicePropertySourceLocator;
    }
}</programlisting>
</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In <literal>resources/META-INF</literal> create a file called
<literal>spring.factories</literal> and specify your custom configuration.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>spring.factories</title>
<para>
<programlisting language="properties" linenumbering="unnumbered">org.springframework.cloud.bootstrap.BootstrapConfiguration = com.my.config.client.CustomConfigServiceBootstrapConfiguration</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_vault">
<title>Vault</title>
<simpara>When using Vault as a backend to your config server the client will need to
supply a token for the server to retrieve values from Vault.  This token
can be provided within the client by setting <literal>spring.cloud.config.token</literal>
in <literal>bootstrap.yml</literal>.</simpara>
<formalpara>
<title>bootstrap.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  cloud:
    config:
      token: YourVaultToken</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_vault_2">
<title>Vault</title>
<section xml:id="_nested_keys_in_vault">
<title>Nested Keys In Vault</title>
<simpara>Vault supports the ability to nest keys in a value stored in Vault.  For example</simpara>
<simpara><literal>echo -n '{"appA": {"secret": "appAsecret"}, "bar": "baz"}' | vault write secret/myapp -</literal></simpara>
<simpara>This command will write a JSON object to your Vault.  To access these values in Spring
you would use the traditional dot(.) annotation.  For example</simpara>
<programlisting language="java" linenumbering="unnumbered">@Value("${appA.secret}")
String name = "World";</programlisting>
<simpara>The above code would set the <literal>name</literal> variable to <literal>appAsecret</literal>.</simpara>
</section>
</section>
</chapter>
</part>
<part xml:id="_spring_cloud_netflix">
<title>Spring Cloud Netflix</title>
<partintro>
<simpara><emphasis role="strong">Edgware.SR2</emphasis></simpara>
<simpara>This project provides Netflix OSS integrations for Spring Boot apps through autoconfiguration
and binding to the Spring Environment and other Spring programming model idioms. With a few
simple annotations you can quickly enable and configure the common patterns inside your
application and build large distributed systems with battle-tested Netflix components. The
patterns provided include Service Discovery (Eureka), Circuit Breaker (Hystrix),
Intelligent Routing (Zuul) and Client Side Load Balancing (Ribbon).</simpara>
</partintro>
<chapter xml:id="_service_discovery_eureka_clients">
<title>Service Discovery: Eureka Clients</title>
<simpara>Service Discovery is one of the key tenets of a microservice based architecture. Trying to hand configure each client or some form of convention can be very difficult to do and can be very brittle.  Eureka is the Netflix Service Discovery Server and Client.  The server can be configured and deployed to be highly available, with each server replicating state about the registered services to the others.</simpara>
<section xml:id="netflix-eureka-client-starter">
<title>How to Include Eureka Client</title>
<simpara>To include Eureka Client in your project use the starter with group <literal>org.springframework.cloud</literal>
and artifact id <literal>spring-cloud-starter-netflix-eureka-client</literal>. See the <link xl:href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</link>
for details on setting up your build system with the current Spring Cloud Release Train.</simpara>
</section>
<section xml:id="_registering_with_eureka">
<title>Registering with Eureka</title>
<simpara>When a client registers with Eureka, it provides meta-data about itself
such as host and port, health indicator URL, home page etc.  Eureka
receives heartbeat messages from each instance belonging to a service.
If the heartbeat fails over a configurable timetable, the instance is
normally removed from the registry.</simpara>
<simpara>Example eureka client:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@ComponentScan
@EnableAutoConfiguration
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello world";
    }

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</programlisting>
<simpara>(i.e. utterly normal Spring Boot app). By having <literal>spring-cloud-starter-netflix-eureka-client</literal>
 on the classpath your application will automatically register with the Eureka Server.  Configuration is required to
locate the Eureka server. Example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/</screen>
</para>
</formalpara>
<simpara>where "defaultZone" is a magic string fallback value that provides the
service URL for any client that doesn&#8217;t express a preference
(i.e. it&#8217;s a useful default).</simpara>
<simpara>The default application name (service ID), virtual host and non-secure
port, taken from the <literal>Environment</literal>, are <literal>${spring.application.name}</literal>,
<literal>${spring.application.name}</literal> and <literal>${server.port}</literal> respectively.</simpara>
<simpara>Having <literal>spring-cloud-starter-netflix-eureka-client</literal> on the classpath
makes the app into both a Eureka "instance"
(i.e. it registers itself) and a "client" (i.e. it can query the
registry to locate other services). The instance behaviour is driven
by <literal>eureka.instance.*</literal> configuration keys, but the defaults will be
fine if you ensure that your application has a
<literal>spring.application.name</literal> (this is the default for the Eureka service
ID, or VIP).</simpara>
<simpara>See <link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java">EurekaInstanceConfigBean</link> and <link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java">EurekaClientConfigBean</link> for more details of the configurable options.</simpara>
<simpara>To disable the Eureka Discovery Client you can set <literal>eureka.client.enabled</literal> to <literal>false</literal>.</simpara>
</section>
<section xml:id="_authenticating_with_the_eureka_server">
<title>Authenticating with the Eureka Server</title>
<simpara>HTTP basic authentication will be automatically added to your eureka
client if one of the <literal>eureka.client.serviceUrl.defaultZone</literal> URLs has
credentials embedded in it (curl style, like
<literal><link xl:href="http://user:password@localhost:8761/eureka">http://user:password@localhost:8761/eureka</link></literal>). For more complex needs
you can create a <literal>@Bean</literal> of type <literal>DiscoveryClientOptionalArgs</literal> and
inject <literal>ClientFilter</literal> instances into it, all of which will be applied
to the calls from the client to the server.</simpara>
<note>
<simpara>Because of a limitation in Eureka it isn&#8217;t possible to support
per-server basic auth credentials, so only the first set that are
found will be used.</simpara>
</note>
</section>
<section xml:id="_status_page_and_health_indicator">
<title>Status Page and Health Indicator</title>
<simpara>The status page and health indicators for a Eureka instance default to
"/info" and "/health" respectively, which are the default locations of
useful endpoints in a Spring Boot Actuator application. You need to
change these, even for an Actuator application if you use a
non-default context path or servlet path
(e.g. <literal>server.servletPath=/foo</literal>) or management endpoint path
(e.g. <literal>management.contextPath=/admin</literal>). Example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>eureka:
  instance:
    statusPageUrlPath: ${management.context-path}/info
    healthCheckUrlPath: ${management.context-path}/health</screen>
</para>
</formalpara>
<simpara>These links show up in the metadata that is consumed by clients, and
used in some scenarios to decide whether to send requests to your
application, so it&#8217;s helpful if they are accurate.</simpara>
</section>
<section xml:id="_registering_a_secure_application">
<title>Registering a Secure Application</title>
<simpara>If your app wants to be contacted over HTTPS you can set two flags in
the <literal>EurekaInstanceConfig</literal>, <emphasis>viz</emphasis>
<literal>eureka.instance.[nonSecurePortEnabled,securePortEnabled]=[false,true]</literal>
respectively. This will make Eureka publish instance information
showing an explicit preference for secure communication. The Spring
Cloud <literal>DiscoveryClient</literal> will always return a URI starting with <literal>https</literal> for a
service configured this way, and the Eureka (native) instance
information will have a secure health check URL.</simpara>
<simpara>Because of the way
Eureka works internally, it will still publish a non-secure URL for
status and home page unless you also override those explicitly.
You can use placeholders to configure the eureka instance urls,
e.g.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>eureka:
  instance:
    statusPageUrl: https://${eureka.hostname}/info
    healthCheckUrl: https://${eureka.hostname}/health
    homePageUrl: https://${eureka.hostname}/</screen>
</para>
</formalpara>
<simpara>(Note that <literal>${eureka.hostname}</literal> is a native placeholder only available
in later versions of Eureka. You could achieve the same thing with
Spring placeholders as well, e.g. using <literal>${eureka.instance.hostName}</literal>.)</simpara>
<note>
<simpara>If your app is running behind a proxy, and the SSL termination
is in the proxy (e.g. if you run in Cloud Foundry or other platforms
as a service) then you will need to ensure that the proxy "forwarded"
headers are intercepted and handled by the application. An embedded
Tomcat container in a Spring Boot app does this automatically if it
has explicit configuration for the 'X-Forwarded-\*` headers. A sign
that you got this wrong will be that the links rendered by your app to
itself will be wrong (the wrong host, port or protocol).</simpara>
</note>
</section>
<section xml:id="_eureka_s_health_checks">
<title>Eureka&#8217;s Health Checks</title>
<simpara>By default, Eureka uses the client heartbeat to determine if a client is up.
Unless specified otherwise the Discovery Client will not propagate the
current health check status of the application per the Spring Boot Actuator.  Which means
that after successful registration Eureka will always announce that the
application is in 'UP' state. This behaviour can be altered by enabling
Eureka health checks, which results in propagating application status
to Eureka. As a consequence every other application won&#8217;t be sending
traffic to application in state other then 'UP'.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>eureka:
  client:
    healthcheck:
      enabled: true</screen>
</para>
</formalpara>
<warning>
<simpara><literal>eureka.client.healthcheck.enabled=true</literal> should only be set in <literal>application.yml</literal>. Setting the value in <literal>bootstrap.yml</literal> will cause undesirable side effects like registering in eureka with an <literal>UNKNOWN</literal> status.</simpara>
</warning>
<simpara>If you require more control over the health checks, you may consider
implementing your own <literal>com.netflix.appinfo.HealthCheckHandler</literal>.</simpara>
</section>
<section xml:id="_eureka_metadata_for_instances_and_clients">
<title>Eureka Metadata for Instances and Clients</title>
<simpara>It&#8217;s worth spending a bit of time understanding how the Eureka metadata works, so you can use it in a way that makes sense in your platform. There is standard metadata for things like hostname, IP address, port numbers, status page and health check. These are published in the service registry and used by clients to contact the services in a straightforward way. Additional metadata can be added to the instance registration in the <literal>eureka.instance.metadataMap</literal>, and this will be accessible in the remote clients, but in general will not change the behaviour of the client, unless it is made aware of the meaning of the metadata. There are a couple of special cases described below where Spring Cloud already assigns meaning to the metadata map.</simpara>
<section xml:id="_using_eureka_on_cloudfoundry">
<title>Using Eureka on Cloudfoundry</title>
<simpara>Cloudfoundry has a global router so that all instances of the same app have the same hostname (it&#8217;s the same in other PaaS solutions with a similar architecture). This isn&#8217;t necessarily a barrier to using Eureka, but if you use the router (recommended, or even mandatory depending on the way your platform was set up), you need to explicitly set the hostname and port numbers (secure or non-secure) so that they use the router. You might also want to use instance metadata so you can distinguish between the instances on the client (e.g. in a custom load balancer). By default, the <literal>eureka.instance.instanceId</literal> is <literal>vcap.application.instance_id</literal>. For example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>eureka:
  instance:
    hostname: ${vcap.application.uris[0]}
    nonSecurePort: 80</screen>
</para>
</formalpara>
<simpara>Depending on the way the security rules are set up in your Cloudfoundry instance, you might be able to register and use the IP address of the host VM for direct service-to-service calls. This feature is not (yet) available on Pivotal Web Services (<link xl:href="https://run.pivotal.io">PWS</link>).</simpara>
</section>
<section xml:id="_using_eureka_on_aws">
<title>Using Eureka on AWS</title>
<simpara>If the application is planned to be deployed to an AWS cloud, then the Eureka instance will have to be configured to be AWS aware and this can be done by customizing the <link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java">EurekaInstanceConfigBean</link> the following way:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bean
@Profile("!default")
public EurekaInstanceConfigBean eurekaInstanceConfig(InetUtils inetUtils) {
  EurekaInstanceConfigBean b = new EurekaInstanceConfigBean(inetUtils);
  AmazonInfo info = AmazonInfo.Builder.newBuilder().autoBuild("eureka");
  b.setDataCenterInfo(info);
  return b;
}</programlisting>
</section>
<section xml:id="_changing_the_eureka_instance_id">
<title>Changing the Eureka Instance ID</title>
<simpara>A vanilla Netflix Eureka instance is registered with an ID that is equal to its host name (i.e. only one service per host). Spring Cloud Eureka provides a sensible default that looks like this: <literal>${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}}</literal>. For example <literal>myhost:myappname:8080</literal>.</simpara>
<simpara>Using Spring Cloud you can override this by providing a unique identifier in <literal>eureka.instance.instanceId</literal>. For example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>eureka:
  instance:
    instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}</screen>
</para>
</formalpara>
<simpara>With this metadata, and multiple service instances deployed on
localhost, the random value will kick in there to make the instance
unique. In Cloudfoundry the <literal>vcap.application.instance_id</literal> will be
populated automatically in a Spring Boot application, so the
random value will not be needed.</simpara>
</section>
</section>
<section xml:id="_using_the_eurekaclient">
<title>Using the EurekaClient</title>
<simpara>Once you have an app that is a discovery client you can use it to
discover service instances from the <link linkend="spring-cloud-eureka-server">Eureka Server</link>. One way to do that is to use the native
<literal>com.netflix.discovery.EurekaClient</literal> (as opposed to the Spring
Cloud <literal>DiscoveryClient</literal>), e.g.</simpara>
<screen>@Autowired
private EurekaClient discoveryClient;

public String serviceUrl() {
    InstanceInfo instance = discoveryClient.getNextServerFromEureka("STORES", false);
    return instance.getHomePageUrl();
}</screen>
<tip>
<simpara>Don&#8217;t use the <literal>EurekaClient</literal> in <literal>@PostConstruct</literal> method or in a
<literal>@Scheduled</literal> method (or anywhere where the <literal>ApplicationContext</literal> might
not be started yet). It is initialized in a <literal>SmartLifecycle</literal> (with
<literal>phase=0</literal>) so the earliest you can rely on it being available is in
another <literal>SmartLifecycle</literal> with higher phase.</simpara>
</tip>
<section xml:id="_eurekaclient_without_jersey">
<title>EurekaClient without Jersey</title>
<simpara>By default, EurekaClient uses Jersey for HTTP communication. If you wish
to avoid dependencies from Jersey, you can exclude it from your dependencies.
Spring Cloud will auto configure a transport client based on Spring
<literal>RestTemplate</literal>.</simpara>
<screen>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;
            &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;
            &lt;artifactId&gt;jersey-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;com.sun.jersey.contribs&lt;/groupId&gt;
            &lt;artifactId&gt;jersey-apache-client4&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;</screen>
</section>
</section>
<section xml:id="_alternatives_to_the_native_netflix_eurekaclient">
<title>Alternatives to the native Netflix EurekaClient</title>
<simpara>You don&#8217;t have to use the raw Netflix <literal>EurekaClient</literal> and usually it
is more convenient to use it behind a wrapper of some sort. Spring
Cloud has support for <link linkend="spring-cloud-feign">Feign</link> (a REST client
builder) and also <link linkend="spring-cloud-ribbon">Spring <literal>RestTemplate</literal></link> using
the logical Eureka service identifiers (VIPs) instead of physical
URLs. To configure Ribbon with a fixed list of physical servers you
can simply set <literal>&lt;client&gt;.ribbon.listOfServers</literal> to a comma-separated
list of physical addresses (or hostnames), where <literal>&lt;client&gt;</literal> is the ID
of the client.</simpara>
<simpara>You can also use the <literal>org.springframework.cloud.client.discovery.DiscoveryClient</literal>
which provides a simple API for discovery clients that is not specific
to Netflix, e.g.</simpara>
<screen>@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances("STORES");
    if (list != null &amp;&amp; list.size() &gt; 0 ) {
        return list.get(0).getUri();
    }
    return null;
}</screen>
</section>
<section xml:id="_why_is_it_so_slow_to_register_a_service">
<title>Why is it so Slow to Register a Service?</title>
<simpara>Being an instance also involves a periodic heartbeat to the registry
(via the client&#8217;s <literal>serviceUrl</literal>) with default duration 30 seconds. A
service is not available for discovery by clients until the instance,
the server and the client all have the same metadata in their local
cache (so it could take 3 heartbeats). You can change the period using
<literal>eureka.instance.leaseRenewalIntervalInSeconds</literal> and this will speed up
the process of getting clients connected to other services. In
production it&#8217;s probably better to stick with the default because
there are some computations internally in the server that make
assumptions about the lease renewal period.</simpara>
</section>
<section xml:id="_zones">
<title>Zones</title>
<simpara>If you have deployed Eureka clients to multiple zones than you may prefer that
those clients leverage services within the same zone before trying services
in another zone.  To do this you need to configure your Eureka clients correctly.</simpara>
<simpara>First, you need to make sure you have Eureka servers deployed to each zone and that
they are peers of each other.  See the section on <link linkend="spring-cloud-eureka-server-zones-and-regions">zones and regions</link>
for more information.</simpara>
<simpara>Next you need to tell Eureka which zone your service is in.  You can do this using
the <literal>metadataMap</literal> property.  For example if <literal>service 1</literal> is deployed to both <literal>zone 1</literal>
and <literal>zone 2</literal> you would need to set the following Eureka properties in <literal>service 1</literal></simpara>
<simpara><emphasis role="strong">Service 1 in Zone 1</emphasis></simpara>
<screen>eureka.instance.metadataMap.zone = zone1
eureka.client.preferSameZoneEureka = true</screen>
<simpara><emphasis role="strong">Service 1 in Zone 2</emphasis></simpara>
<screen>eureka.instance.metadataMap.zone = zone2
eureka.client.preferSameZoneEureka = true</screen>
</section>
</chapter>
<chapter xml:id="spring-cloud-eureka-server">
<title>Service Discovery: Eureka Server</title>
<section xml:id="netflix-eureka-server-starter">
<title>How to Include Eureka Server</title>
<simpara>To include Eureka Server in your project use the starter with group <literal>org.springframework.cloud</literal>
and artifact id <literal>spring-cloud-starter-netflix-eureka-server</literal>. See the <link xl:href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</link>
for details on setting up your build system with the current Spring Cloud Release Train.</simpara>
</section>
<section xml:id="spring-cloud-running-eureka-server">
<title>How to Run a Eureka Server</title>
<simpara>Example eureka server;</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableEurekaServer
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</programlisting>
<simpara>The server has a home page with a UI, and HTTP API endpoints per the
normal Eureka functionality under <literal>/eureka/*</literal>.</simpara>
<simpara>Eureka background reading: see <link xl:href="https://github.com/cfregly/fluxcapacitor/wiki/NetflixOSS-FAQ#eureka-service-discovery-load-balancer">flux capacitor</link> and <link xl:href="https://groups.google.com/forum/?fromgroups#!topic/eureka_netflix/g3p2r7gHnN0">google group discussion</link>.</simpara>
<tip>
<simpara>Due to Gradle&#8217;s dependency resolution rules and the lack of a parent bom feature, simply depending on spring-cloud-starter-netflix-eureka-server can cause failures on application startup. To remedy this the Spring Boot Gradle plugin must be added and the Spring cloud starter parent bom must be imported like so:</simpara>
<formalpara>
<title>build.gradle</title>
<para>
<programlisting language="java" linenumbering="unnumbered">buildscript {
  dependencies {
    classpath("org.springframework.boot:spring-boot-gradle-plugin:1.3.5.RELEASE")
  }
}

apply plugin: "spring-boot"

dependencyManagement {
  imports {
    mavenBom "org.springframework.cloud:spring-cloud-dependencies:Brixton.RELEASE"
  }
}</programlisting>
</para>
</formalpara>
</tip>
</section>
<section xml:id="spring-cloud-eureka-server-zones-and-regions">
<title>High Availability, Zones and Regions</title>
<simpara>The Eureka server does not have a backend store, but the service
instances in the registry all have to send heartbeats to keep their
registrations up to date (so this can be done in memory). Clients also
have an in-memory cache of eureka registrations (so they don&#8217;t have to
go to the registry for every single request to a service).</simpara>
<simpara>By default every Eureka server is also a Eureka client and requires
(at least one) service URL to locate a peer. If you don&#8217;t provide it
the service will run and work, but it will shower your logs with a lot
of noise about not being able to register with the peer.</simpara>
<simpara>See also <link linkend="spring-cloud-ribbon">below for details of Ribbon
support</link> on the client side for Zones and Regions.</simpara>
</section>
<section xml:id="_standalone_mode">
<title>Standalone Mode</title>
<simpara>The combination of the two caches (client and server) and the
heartbeats make a standalone Eureka server fairly resilient to
failure, as long as there is some sort of monitor or elastic runtime
keeping it alive (e.g. Cloud Foundry). In standalone mode, you might
prefer to switch off the client side behaviour, so it doesn&#8217;t keep
trying and failing to reach its peers. Example:</simpara>
<formalpara>
<title>application.yml (Standalone Eureka Server)</title>
<para>
<screen>server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/</screen>
</para>
</formalpara>
<simpara>Notice that the <literal>serviceUrl</literal> is pointing to the same host as the local
instance.</simpara>
</section>
<section xml:id="_peer_awareness">
<title>Peer Awareness</title>
<simpara>Eureka can be made even more resilient and available by running
multiple instances and asking them to register with each other. In
fact, this is the default behaviour, so all you need to do to make it
work is add a valid <literal>serviceUrl</literal> to a peer, e.g.</simpara>
<formalpara>
<title>application.yml (Two Peer Aware Eureka Servers)</title>
<para>
<screen>---
spring:
  profiles: peer1
eureka:
  instance:
    hostname: peer1
  client:
    serviceUrl:
      defaultZone: http://peer2/eureka/

---
spring:
  profiles: peer2
eureka:
  instance:
    hostname: peer2
  client:
    serviceUrl:
      defaultZone: http://peer1/eureka/</screen>
</para>
</formalpara>
<simpara>In this example we have a YAML file that can be used to run the same
server on 2 hosts (peer1 and peer2), by running it in different
Spring profiles. You could use this configuration to test the peer
awareness on a single host (there&#8217;s not much value in doing that in
production) by manipulating <literal>/etc/hosts</literal> to resolve the host names. In
fact, the <literal>eureka.instance.hostname</literal> is not needed if you are running
on a machine that knows its own hostname (it is looked up using
<literal>java.net.InetAddress</literal> by default).</simpara>
<simpara>You can add multiple peers to a system, and as long as they are all
connected to each other by at least one edge, they will synchronize
the registrations amongst themselves. If the peers are physically
separated (inside a data centre or between multiple data centres) then
the system can in principle survive split-brain type failures.</simpara>
</section>
<section xml:id="_prefer_ip_address">
<title>Prefer IP Address</title>
<simpara>In some cases, it is preferable for Eureka to advertise the IP Adresses
of services rather than the hostname.  Set <literal>eureka.instance.preferIpAddress</literal>
to <literal>true</literal> and when the application registers with eureka, it will use its
IP Address rather than its hostname.</simpara>
<tip>
<simpara>If hostname can&#8217;t be determined by Java, then IP address is sent to Eureka.
Only explict way of setting hostname is by using <literal>eureka.instance.hostname</literal>.
You can set your hostname at the run time using environment variable, for
example <literal>eureka.instance.hostname=${HOST_NAME}</literal>.</simpara>
</tip>
</section>
</chapter>
<chapter xml:id="_circuit_breaker_hystrix_clients">
<title>Circuit Breaker: Hystrix Clients</title>
<simpara>Netflix has created a library called <link xl:href="https://github.com/Netflix/Hystrix">Hystrix</link> that implements the <link xl:href="https://martinfowler.com/bliki/CircuitBreaker.html">circuit breaker pattern</link>.  In a microservice architecture it is common to have multiple layers of service calls.</simpara>
<figure>
<title>Microservice Graph</title>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/1.4.x/docs/src/main/asciidoc/images/Hystrix.png"/>
</imageobject>
<textobject><phrase>Hystrix</phrase></textobject>
</mediaobject>
</figure>
<simpara>A service failure in the lower level of services can cause cascading failure all the way up to the user. When calls to a particular service is greater than <literal>circuitBreaker.requestVolumeThreshold</literal> (default: 20 requests) and failue percentage is greater than <literal>circuitBreaker.errorThresholdPercentage</literal> (default: &gt;50%) in a rolling window defined  by <literal>metrics.rollingStats.timeInMilliseconds</literal> (default: 10 seconds), the circuit opens and the call is not made.  In cases of error and an open circuit a fallback can be provided by the developer.</simpara>
<figure>
<title>Hystrix fallback prevents cascading failures</title>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/1.4.x/docs/src/main/asciidoc/images/HystrixFallback.png"/>
</imageobject>
<textobject><phrase>HystrixFallback</phrase></textobject>
</mediaobject>
</figure>
<simpara>Having an open circuit stops cascading failures and allows overwhelmed or failing services time to heal.  The fallback can be another Hystrix protected call, static data or a sane empty value.  Fallbacks may be chained so the first fallback makes some other business call which in turn falls back to static data.</simpara>
<section xml:id="netflix-hystrix-starter">
<title>How to Include Hystrix</title>
<simpara>To include Hystrix in your project use the starter with group <literal>org.springframework.cloud</literal>
and artifact id <literal>spring-cloud-starter-netflix-hystrix</literal>. See the <link xl:href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</link>
for details on setting up your build system with the current Spring Cloud Release Train.</simpara>
<simpara>Example boot app:</simpara>
<screen>@SpringBootApplication
@EnableCircuitBreaker
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}

@Component
public class StoreIntegration {

    @HystrixCommand(fallbackMethod = "defaultStores")
    public Object getStores(Map&lt;String, Object&gt; parameters) {
        //do stuff that might fail
    }

    public Object defaultStores(Map&lt;String, Object&gt; parameters) {
        return /* something useful */;
    }
}</screen>
<simpara>The <literal>@HystrixCommand</literal> is provided by a Netflix contrib library called
<link xl:href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica">"javanica"</link>.
Spring Cloud automatically wraps Spring beans with that
annotation in a proxy that is connected to the Hystrix circuit
breaker. The circuit breaker calculates when to open and close the
circuit, and what to do in case of a failure.</simpara>
<simpara>To configure the <literal>@HystrixCommand</literal> you can use the <literal>commandProperties</literal>
attribute with a list of <literal>@HystrixProperty</literal> annotations.  See
<link xl:href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration">here</link>
for more details.  See the <link xl:href="https://github.com/Netflix/Hystrix/wiki/Configuration">Hystrix wiki</link>
for details on the properties available.</simpara>
</section>
<section xml:id="_propagating_the_security_context_or_using_spring_scopes">
<title>Propagating the Security Context or using Spring Scopes</title>
<simpara>If you want some thread local context to propagate into a <literal>@HystrixCommand</literal> the default declaration will not work because it executes the command in a thread pool (in case of timeouts). You can switch Hystrix to use the same thread as the caller using some configuration, or directly in the annotation, by asking it to use a different "Isolation Strategy". For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@HystrixCommand(fallbackMethod = "stubMyService",
    commandProperties = {
      @HystrixProperty(name="execution.isolation.strategy", value="SEMAPHORE")
    }
)
...</programlisting>
<simpara>The same thing applies if you are using <literal>@SessionScope</literal> or <literal>@RequestScope</literal>. You will know when you need to do this because of a runtime exception that says it can&#8217;t find the scoped context.</simpara>
<simpara>You also have the option to set the <literal>hystrix.shareSecurityContext</literal> property to <literal>true</literal>. Doing so will auto configure an Hystrix concurrency strategy plugin hook who will transfer the <literal>SecurityContext</literal> from your main thread to the one used by the Hystrix command. Hystrix does not allow multiple hystrix concurrency strategy to be registered so an extension mechanism is available by declaring your own <literal>HystrixConcurrencyStrategy</literal> as a Spring bean. Spring Cloud will lookup for your implementation within the Spring context and wrap it inside its own plugin.</simpara>
</section>
<section xml:id="_health_indicator_4">
<title>Health Indicator</title>
<simpara>The state of the connected circuit breakers are also exposed in the
<literal>/health</literal> endpoint of the calling application.</simpara>
<programlisting language="json" linenumbering="unnumbered">{
    "hystrix": {
        "openCircuitBreakers": [
            "StoreIntegration::getStoresByLocationLink"
        ],
        "status": "CIRCUIT_OPEN"
    },
    "status": "UP"
}</programlisting>
</section>
<section xml:id="_hystrix_metrics_stream">
<title>Hystrix Metrics Stream</title>
<simpara>To enable the Hystrix metrics stream include a dependency on <literal>spring-boot-starter-actuator</literal>.  This will expose the <literal>/hystrix.stream</literal> as a management endpoint.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;</programlisting>
</section>
</chapter>
<chapter xml:id="_circuit_breaker_hystrix_dashboard">
<title>Circuit Breaker: Hystrix Dashboard</title>
<simpara>One of the main benefits of Hystrix is the set of metrics it gathers about each HystrixCommand.  The Hystrix Dashboard displays the health of each circuit breaker in an efficient manner.</simpara>
<figure>
<title>Hystrix Dashboard</title>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/1.4.x/docs/src/main/asciidoc/images/Hystrix.png"/>
</imageobject>
<textobject><phrase>Hystrix</phrase></textobject>
</mediaobject>
</figure>
</chapter>
<chapter xml:id="_hystrix_timeouts_and_ribbon_clients">
<title>Hystrix Timeouts And Ribbon Clients</title>
<simpara>When using Hystrix commands that wrap Ribbon clients you want to make sure your Hystrix timeout
is configured to be longer than the configured Ribbon timeout, including any potential
retries that might be made.  For example, if your Ribbon connection timeout is one second and
the Ribbon client might retry the request three times, than your Hystrix timeout should
be slightly more than three seconds.</simpara>
<section xml:id="netflix-hystrix-dashboard-starter">
<title>How to Include Hystrix Dashboard</title>
<simpara>To include the Hystrix Dashboard in your project use the starter with group <literal>org.springframework.cloud</literal>
and artifact id <literal>spring-cloud-starter-hystrix-netflix-dashboard</literal>. See the <link xl:href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</link>
for details on setting up your build system with the current Spring Cloud Release Train.</simpara>
<simpara>To run the Hystrix Dashboard annotate your Spring Boot main class with <literal>@EnableHystrixDashboard</literal>.  You then visit <literal>/hystrix</literal> and point the dashboard to an individual instances <literal>/hystrix.stream</literal> endpoint in a Hystrix client application.</simpara>
<note>
<simpara>When connecting to a <literal>/hystrix.stream</literal> endpoint which uses HTTPS the certificate used by the server
must be trusted by the JVM.  If the certificate is not trusted you must import the certificate into the JVM
in order for the Hystrix Dashboard to make a successful connection to the stream endpoint.</simpara>
</note>
</section>
<section xml:id="_turbine">
<title>Turbine</title>
<simpara>Looking at an individual instances Hystrix data is not very useful in terms of the overall health of the system.  <link xl:href="https://github.com/Netflix/Turbine">Turbine</link> is an application that aggregates all of the relevant <literal>/hystrix.stream</literal> endpoints into a combined <literal>/turbine.stream</literal> for use in the Hystrix Dashboard.  Individual instances are located via Eureka.  Running Turbine is as simple as annotating your main class with the <literal>@EnableTurbine</literal> annotation  (e.g. using spring-cloud-starter-netflix-turbine to set up the classpath).  All of the documented configuration properties from <link xl:href="https://github.com/Netflix/Turbine/wiki/Configuration-(1.x)">the Turbine 1 wiki</link> apply.  The only difference is that the <literal>turbine.instanceUrlSuffix</literal> does not need the port prepended as this is handled automatically unless <literal>turbine.instanceInsertPort=false</literal>.</simpara>
<note>
<simpara>By default, Turbine looks for the <literal>/hystrix.stream</literal> endpoint on a registered instance by looking up its <literal>hostName</literal> and <literal>port</literal> entries in Eureka, then appending <literal>/hystrix.stream</literal> to it.
If the instance&#8217;s metadata contains <literal>management.port</literal>, it will be used instead of the <literal>port</literal> value for the <literal>/hystrix.stream</literal> endpoint.
By default, metadata entry <literal>management.port</literal> is equal to the <literal>management.port</literal> configuration property, it can be overridden though with following configuration:</simpara>
</note>
<screen>eureka:
  instance:
    metadata-map:
      management.port: ${management.port:8081}</screen>
<simpara>The configuration key <literal>turbine.appConfig</literal> is a list of eureka serviceIds that turbine will use to lookup instances.  The turbine stream is then used in the Hystrix dashboard using a url that looks like: <literal><link xl:href="https://my.turbine.sever:8080/turbine.stream?cluster=CLUSTERNAME">https://my.turbine.sever:8080/turbine.stream?cluster=CLUSTERNAME</link></literal> (the cluster parameter can be omitted if the name is "default"). The <literal>cluster</literal> parameter must match an entry in <literal>turbine.aggregator.clusterConfig</literal>. Values returned from eureka are uppercase, thus we expect this example to work if there is an app registered with Eureka called "customers":</simpara>
<screen>turbine:
  aggregator:
    clusterConfig: CUSTOMERS
  appConfig: customers</screen>
<simpara>If you need to customize which cluster names should be used by Turbine (you don&#8217;t want to store cluster names in
<literal>turbine.aggregator.clusterConfig</literal> configuration) provide a bean of type <literal>TurbineClustersProvider</literal>.</simpara>
<simpara>The <literal>clusterName</literal> can be customized by a SPEL expression in <literal>turbine.clusterNameExpression</literal> with root an instance of <literal>InstanceInfo</literal>. The default value is <literal>appName</literal>, which means that the Eureka serviceId ends up as the cluster key (i.e. the <literal>InstanceInfo</literal> for customers has an <literal>appName</literal> of "CUSTOMERS").  A different example would be <literal>turbine.clusterNameExpression=aSGName</literal>, which would get the cluster name from the AWS ASG name. Another example:</simpara>
<screen>turbine:
  aggregator:
    clusterConfig: SYSTEM,USER
  appConfig: customers,stores,ui,admin
  clusterNameExpression: metadata['cluster']</screen>
<simpara>In this case, the cluster name from 4 services is pulled from their metadata map, and is expected to have values that include "SYSTEM" and "USER".</simpara>
<simpara>To use the "default" cluster for all apps you need a string literal expression (with single quotes, and escaped with double quotes if it is in YAML as well):</simpara>
<screen>turbine:
  appConfig: customers,stores
  clusterNameExpression: "'default'"</screen>
<simpara>Spring Cloud provides a <literal>spring-cloud-starter-netflix-turbine</literal> that has all the dependencies you need to get a Turbine server running. Just create a Spring Boot application and annotate it with <literal>@EnableTurbine</literal>.</simpara>
<note>
<simpara>by default Spring Cloud allows Turbine to use the host and port to allow multiple processes per host, per cluster. If you want the native Netflix behaviour built into Turbine that does <emphasis>not</emphasis> allow multiple processes per host, per cluster (the key to the instance id is the hostname), then set the property <literal>turbine.combineHostPort=false</literal>.</simpara>
</note>
</section>
<section xml:id="_turbine_stream">
<title>Turbine Stream</title>
<simpara>In some environments (e.g. in a PaaS setting), the classic Turbine model of pulling metrics from all the distributed Hystrix commands doesn&#8217;t work. In that case you might want to have your Hystrix commands push metrics to Turbine, and Spring Cloud enables that with messaging. All you need to do on the client is add a dependency to <literal>spring-cloud-netflix-hystrix-stream</literal> and the <literal>spring-cloud-starter-stream-*</literal> of your choice (see Spring Cloud Stream documentation for details on the brokers, and how to configure the client credentials, but it should work out of the box for a local broker).</simpara>
<simpara>On the server side Just create a Spring Boot application and annotate it with <literal>@EnableTurbineStream</literal> and by default it will come up on port 8989 (point your Hystrix dashboard to that port, any path). You can customize the port using either <literal>server.port</literal> or <literal>turbine.stream.port</literal>. If you have <literal>spring-boot-starter-web</literal> and <literal>spring-boot-starter-actuator</literal> on the classpath as well, then you can open up the Actuator endpoints on a separate port (with Tomcat by default) by providing a <literal>management.port</literal> which is different.</simpara>
<simpara>You can then point the Hystrix Dashboard to the Turbine Stream Server instead of individual Hystrix streams.  If Turbine Stream is running on port 8989 on myhost, then put <literal><link xl:href="http://myhost:8989">http://myhost:8989</link></literal> in the stream input field in the Hystrix Dashboard. Circuits will be prefixed by their respective serviceId, followed by a dot, then the circuit name.</simpara>
<simpara>Spring Cloud provides a <literal>spring-cloud-starter-netflix-turbine-stream</literal> that has all the dependencies you need to get a Turbine Stream server running - just add the Stream binder of your choice, e.g. <literal>spring-cloud-starter-stream-rabbit</literal>. You need Java 8 to run the app because it is Netty-based.</simpara>
</section>
</chapter>
<chapter xml:id="spring-cloud-ribbon">
<title>Client Side Load Balancer: Ribbon</title>
<simpara>Ribbon is a client side load balancer which gives you a lot of control
over the behaviour of HTTP and TCP clients. Feign already uses Ribbon,
so if you are using <literal>@FeignClient</literal> then this section also applies.</simpara>
<simpara>A central concept in Ribbon is that of the named client. Each load
balancer is part of an ensemble of components that work together to
contact a remote server on demand, and the ensemble has a name that
you give it as an application developer (e.g. using the <literal>@FeignClient</literal>
annotation). Spring Cloud creates a new ensemble as an
<literal>ApplicationContext</literal> on demand for each named client using
<literal>RibbonClientConfiguration</literal>. This contains (amongst other things) an
<literal>ILoadBalancer</literal>, a <literal>RestClient</literal>, and a <literal>ServerListFilter</literal>.</simpara>
<section xml:id="netflix-ribbon-starter">
<title>How to Include Ribbon</title>
<simpara>To include Ribbon in your project use the starter with group <literal>org.springframework.cloud</literal>
and artifact id <literal>spring-cloud-starter-netflix-ribbon</literal>. See the <link xl:href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</link>
for details on setting up your build system with the current Spring Cloud Release Train.</simpara>
</section>
<section xml:id="_customizing_the_ribbon_client">
<title>Customizing the Ribbon Client</title>
<simpara>You can configure some bits of a Ribbon client using external
properties in <literal>&lt;client&gt;.ribbon.*</literal>, which is no different than using
the Netflix APIs natively, except that you can use Spring Boot
configuration files. The native options can
be inspected as static fields in <link xl:href="https://github.com/Netflix/ribbon/blob/master/ribbon-core/src/main/java/com/netflix/client/config/CommonClientConfigKey.java"><literal>CommonClientConfigKey</literal></link> (part of
ribbon-core).</simpara>
<simpara>Spring Cloud also lets you take full control of the client by
declaring additional configuration (on top of the
<literal>RibbonClientConfiguration</literal>) using <literal>@RibbonClient</literal>. Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@RibbonClient(name = "foo", configuration = FooConfiguration.class)
public class TestConfiguration {
}</programlisting>
<simpara>In this case the client is composed from the components already in
<literal>RibbonClientConfiguration</literal> together with any in <literal>FooConfiguration</literal>
(where the latter generally will override the former).</simpara>
<warning>
<simpara>The <literal>FooConfiguration</literal> has to be <literal>@Configuration</literal> but take
care that it is not in a <literal>@ComponentScan</literal> for the main application
context, otherwise it will be shared by all the <literal>@RibbonClients</literal>. If
you use <literal>@ComponentScan</literal> (or <literal>@SpringBootApplication</literal>) you need to
take steps to avoid it being included (for instance put it in a
separate, non-overlapping package, or specify the packages to scan
explicitly in the <literal>@ComponentScan</literal>).</simpara>
</warning>
<simpara>Spring Cloud Netflix provides the following beans by default for ribbon
(<literal>BeanType</literal> beanName: <literal>ClassName</literal>):</simpara>
<itemizedlist>
<listitem>
<simpara><literal>IClientConfig</literal> ribbonClientConfig: <literal>DefaultClientConfigImpl</literal></simpara>
</listitem>
<listitem>
<simpara><literal>IRule</literal> ribbonRule: <literal>ZoneAvoidanceRule</literal></simpara>
</listitem>
<listitem>
<simpara><literal>IPing</literal> ribbonPing: <literal>DummyPing</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ServerList&lt;Server&gt;</literal> ribbonServerList: <literal>ConfigurationBasedServerList</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ServerListFilter&lt;Server&gt;</literal> ribbonServerListFilter: <literal>ZonePreferenceServerListFilter</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ILoadBalancer</literal> ribbonLoadBalancer: <literal>ZoneAwareLoadBalancer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ServerListUpdater</literal> ribbonServerListUpdater: <literal>PollingServerListUpdater</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Creating a bean of one of those type and placing it in a <literal>@RibbonClient</literal>
configuration (such as <literal>FooConfiguration</literal> above) allows you to override each
one of the beans described.  Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
protected static class FooConfiguration {
	@Bean
	public ZonePreferenceServerListFilter serverListFilter() {
		ZonePreferenceServerListFilter filter = new ZonePreferenceServerListFilter();
		filter.setZone("myTestZone");
		return filter;
	}

	@Bean
	public IPing ribbonPing() {
		return new PingUrl();
	}
}</programlisting>
<simpara>This replaces the <literal>NoOpPing</literal> with <literal>PingUrl</literal> and provides a custom <literal>serverListFilter</literal></simpara>
</section>
<section xml:id="_customizing_default_for_all_ribbon_clients">
<title>Customizing default for all Ribbon Clients</title>
<simpara>A default configuration can be provided for all Ribbon Clients using the <literal>@RibbonClients</literal> annotation and registering a default configuration as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RibbonClients(defaultConfiguration = DefaultRibbonConfig.class)
public class RibbonClientDefaultConfigurationTestsConfig {

	public static class BazServiceList extends ConfigurationBasedServerList {
		public BazServiceList(IClientConfig config) {
			super.initWithNiwsConfig(config);
		}
	}
}

@Configuration
class DefaultRibbonConfig {

	@Bean
	public IRule ribbonRule() {
		return new BestAvailableRule();
	}

	@Bean
	public IPing ribbonPing() {
		return new PingUrl();
	}

	@Bean
	public ServerList&lt;Server&gt; ribbonServerList(IClientConfig config) {
		return new RibbonClientDefaultConfigurationTestsConfig.BazServiceList(config);
	}

	@Bean
	public ServerListSubsetFilter serverListFilter() {
		ServerListSubsetFilter filter = new ServerListSubsetFilter();
		return filter;
	}

}</programlisting>
</section>
<section xml:id="_customizing_the_ribbon_client_using_properties">
<title>Customizing the Ribbon Client using properties</title>
<simpara>Starting with version 1.2.0, Spring Cloud Netflix now supports customizing Ribbon clients using properties to be compatible with the <link xl:href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers#components-of-load-balancer">Ribbon documentation</link>.</simpara>
<simpara>This allows you to change behavior at start up time in different environments.</simpara>
<simpara>The supported properties are listed below and should be prefixed by <literal>&lt;clientName&gt;.ribbon.</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>NFLoadBalancerClassName</literal>: should implement <literal>ILoadBalancer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>NFLoadBalancerRuleClassName</literal>: should implement <literal>IRule</literal></simpara>
</listitem>
<listitem>
<simpara><literal>NFLoadBalancerPingClassName</literal>: should implement <literal>IPing</literal></simpara>
</listitem>
<listitem>
<simpara><literal>NIWSServerListClassName</literal>: should implement <literal>ServerList</literal></simpara>
</listitem>
<listitem>
<simpara><literal>NIWSServerListFilterClassName</literal> should implement <literal>ServerListFilter</literal></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Classes defined in these properties have precedence over beans defined using <literal>@RibbonClient(configuration=MyRibbonConfig.class)</literal> and the defaults provided by Spring Cloud Netflix.</simpara>
</note>
<simpara>To set the <literal>IRule</literal> for a service name <literal>users</literal> you could set the following:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>users:
  ribbon:
    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule</screen>
</para>
</formalpara>
<simpara>See the <link xl:href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers">Ribbon documentation</link> for implementations provided by Ribbon.</simpara>
</section>
<section xml:id="_using_ribbon_with_eureka">
<title>Using Ribbon with Eureka</title>
<simpara>When Eureka is used in conjunction with Ribbon (i.e., both are on the classpath) the <literal>ribbonServerList</literal>
is overridden with an extension of <literal>DiscoveryEnabledNIWSServerList</literal>
which populates the list of servers from Eureka.  It also replaces the
<literal>IPing</literal> interface with <literal>NIWSDiscoveryPing</literal> which delegates to Eureka
to determine if a server is up. The <literal>ServerList</literal> that is installed by
default is a <literal>DomainExtractingServerList</literal> and the purpose of this is
to make physical metadata available to the load balancer without using
AWS AMI metadata (which is what Netflix relies on). By default the
server list will be constructed with "zone" information as provided in
the instance metadata (so on the remote clients set
<literal>eureka.instance.metadataMap.zone</literal>), and if that is missing it can use
the domain name from the server hostname as a proxy for zone (if the
flag <literal>approximateZoneFromHostname</literal> is set). Once the zone information
is available it can be used in a <literal>ServerListFilter</literal>. By default it
will be used to locate a server in the same zone as the client because
the default is a <literal>ZonePreferenceServerListFilter</literal>. The zone of the
client is determined the same way as the remote instances by default,
i.e. via <literal>eureka.instance.metadataMap.zone</literal>.</simpara>
<note>
<simpara>The orthodox "archaius" way to set the client zone is via a
configuration property called "@zone", and Spring Cloud will use that
in preference to all other settings if it is available (note that the
key will have to be quoted in YAML configuration).</simpara>
</note>
<note>
<simpara>If there is no other source of zone data then a guess is made
based on the client configuration (as opposed to the instance
configuration). We take <literal>eureka.client.availabilityZones</literal>, which is a
map from region name to a list of zones, and pull out the first zone
for the instance&#8217;s own region (i.e. the <literal>eureka.client.region</literal>, which
defaults to "us-east-1" for comatibility with native Netflix).</simpara>
</note>
</section>
<section xml:id="spring-cloud-ribbon-without-eureka">
<title>Example: How to Use Ribbon Without Eureka</title>
<simpara>Eureka is a convenient way to abstract the discovery of remote servers
so you don&#8217;t have to hard code their URLs in clients, but if you
prefer not to use it, Ribbon and Feign are still quite
amenable. Suppose you have declared a <literal>@RibbonClient</literal> for "stores",
and Eureka is not in use (and not even on the classpath). The Ribbon
client defaults to a configured server list, and you can supply the
configuration like this</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>stores:
  ribbon:
    listOfServers: example.com,google.com</screen>
</para>
</formalpara>
</section>
<section xml:id="_example_disable_eureka_use_in_ribbon">
<title>Example: Disable Eureka use in Ribbon</title>
<simpara>Setting the property <literal>ribbon.eureka.enabled = false</literal> will explicitly
disable the use of Eureka in Ribbon.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>ribbon:
  eureka:
   enabled: false</screen>
</para>
</formalpara>
</section>
<section xml:id="_using_the_ribbon_api_directly">
<title>Using the Ribbon API Directly</title>
<simpara>You can also use the <literal>LoadBalancerClient</literal> directly. Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MyClass {
    @Autowired
    private LoadBalancerClient loadBalancer;

    public void doStuff() {
        ServiceInstance instance = loadBalancer.choose("stores");
        URI storesUri = URI.create(String.format("http://%s:%s", instance.getHost(), instance.getPort()));
        // ... do something with the URI
    }
}</programlisting>
</section>
<section xml:id="ribbon-child-context-eager-load">
<title>Caching of Ribbon Configuration</title>
<simpara>Each Ribbon named client has a corresponding child Application Context that Spring Cloud maintains, this application context is lazily loaded up on the first request to the named client.
This lazy loading behavior can be changed to instead eagerly load up these child Application contexts at startup by specifying the names of the Ribbon clients.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>ribbon:
  eager-load:
    enabled: true
    clients: client1, client2, client3</screen>
</para>
</formalpara>
</section>
<section xml:id="how-to-configure-hystrix-thread-pools">
<title>How to Configure Hystrix thread pools</title>
<simpara>If you change <literal>zuul.ribbonIsolationStrategy</literal> to THREAD, the thread isolation strategy for Hystrix will be used for all routes. In this case, the HystrixThreadPoolKey is set to "RibbonCommand" as default. It means that HystrixCommands for all routes will be executed in the same Hystrix thread pool. This behavior can be changed using the following configuration and it will result in HystrixCommands being executed in the Hystrix thread pool for each route.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>zuul:
  threadPool:
    useSeparateThreadPools: true</screen>
</para>
</formalpara>
<simpara>The default HystrixThreadPoolKey in this case is same with service ID for each route. To add a prefix to HystrixThreadPoolKey, set <literal>zuul.threadPool.threadPoolKeyPrefix</literal> to a value that you want to add. For example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>zuul:
  threadPool:
    useSeparateThreadPools: true
    threadPoolKeyPrefix: zuulgw</screen>
</para>
</formalpara>
</section>
<section xml:id="how-to-provdie-a-key-to-ribbon">
<title>How to Provide a Key to Ribbon&#8217;s <literal>IRule</literal></title>
<simpara>If you need to provide your own <literal>IRule</literal> implementation to handle a special routing requirement like a canary test,
you probably want to pass some information to the <literal>choose</literal> method of <literal>IRule</literal>.</simpara>
<formalpara>
<title>com.netflix.loadbalancer.IRule.java</title>
<para>
<screen>public interface IRule{
    public Server choose(Object key);
         :</screen>
</para>
</formalpara>
<simpara>You can provide some information that will be used to choose a target server by your <literal>IRule</literal> implementation like
the following:</simpara>
<screen>RequestContext.getCurrentContext()
              .set(FilterConstants.LOAD_BALANCER_KEY, "canary-test");</screen>
<simpara>If you put any object into the <literal>RequestContext</literal> with a key <literal>FilterConstants.LOAD_BALANCER_KEY</literal>, it will
be passed to the <literal>choose</literal> method of <literal>IRule</literal> implementation. Above code must be executed before <literal>RibbonRoutingFilter</literal>
is executed and Zuul&#8217;s pre filter is the best place to do that. You can easily access HTTP headers and query parameters
via <literal>RequestContext</literal> in pre filter, so it can be used to determine <literal>LOAD_BALANCER_KEY</literal> that will be passed to Ribbon.
If you don&#8217;t put any value with <literal>LOAD_BALANCER_KEY</literal> in <literal>RequestContext</literal>, null will be passed as a parameter of <literal>choose</literal>
method.</simpara>
</section>
</chapter>
<chapter xml:id="spring-cloud-feign">
<title>Declarative REST Client: Feign</title>
<simpara><link xl:href="https://github.com/Netflix/feign">Feign</link> is a declarative web service client.  It makes writing web service clients easier.  To use Feign create an interface and annotate it.  It has pluggable annotation support including Feign annotations and JAX-RS annotations. Feign also supports pluggable encoders and decoders.  Spring Cloud adds support for Spring MVC annotations and for using the same <literal>HttpMessageConverters</literal> used by default in Spring Web.  Spring Cloud integrates Ribbon and Eureka to provide a load balanced http client when using Feign.</simpara>
<section xml:id="netflix-feign-starter">
<title>How to Include Feign</title>
<simpara>To include Feign in your project use the starter with group <literal>org.springframework.cloud</literal>
and artifact id <literal>spring-cloud-starter-openfeign</literal>. See the <link xl:href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</link>
for details on setting up your build system with the current Spring Cloud Release Train.</simpara>
<simpara>Example spring boot app</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@ComponentScan
@EnableAutoConfiguration
@EnableFeignClients
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</programlisting>
<formalpara>
<title>StoreClient.java</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@FeignClient("stores")
public interface StoreClient {
    @RequestMapping(method = RequestMethod.GET, value = "/stores")
    List&lt;Store&gt; getStores();

    @RequestMapping(method = RequestMethod.POST, value = "/stores/{storeId}", consumes = "application/json")
    Store update(@PathVariable("storeId") Long storeId, Store store);
}</programlisting>
</para>
</formalpara>
<simpara>In the <literal>@FeignClient</literal> annotation the String value ("stores" above) is
an arbitrary client name, which is used to create a Ribbon load
balancer (see <link linkend="spring-cloud-ribbon">below for details of Ribbon
support</link>). You can also specify a URL using the <literal>url</literal> attribute
(absolute value or just a hostname). The name of the bean in the
application context is the fully qualified name of the interface.
To specify your own alias value you can use the <literal>qualifier</literal> value
of the <literal>@FeignClient</literal> annotation.</simpara>
<simpara>The Ribbon client above will want to discover the physical addresses
for the "stores" service. If your application is a Eureka client then
it will resolve the service in the Eureka service registry. If you
don&#8217;t want to use Eureka, you can simply configure a list of servers
in your external configuration (see
<link linkend="spring-cloud-ribbon-without-eureka">above for example</link>).</simpara>
</section>
<section xml:id="spring-cloud-feign-overriding-defaults">
<title>Overriding Feign Defaults</title>
<simpara>A central concept in Spring Cloud&#8217;s Feign support is that of the named client. Each feign client is part of an ensemble of components that work together to contact a remote server on demand, and the ensemble has a name that you give it as an application developer using the <literal>@FeignClient</literal> annotation. Spring Cloud creates a new ensemble as an
<literal>ApplicationContext</literal> on demand for each named client using <literal>FeignClientsConfiguration</literal>. This contains (amongst other things) an <literal>feign.Decoder</literal>, a <literal>feign.Encoder</literal>, and a <literal>feign.Contract</literal>.</simpara>
<simpara>Spring Cloud lets you take full control of the feign client by declaring additional configuration (on top of the <literal>FeignClientsConfiguration</literal>) using <literal>@FeignClient</literal>. Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@FeignClient(name = "stores", configuration = FooConfiguration.class)
public interface StoreClient {
    //..
}</programlisting>
<simpara>In this case the client is composed from the components already in <literal>FeignClientsConfiguration</literal> together with any in <literal>FooConfiguration</literal> (where the latter will override the former).</simpara>
<note>
<simpara><literal>FooConfiguration</literal> does not need to be annotated with <literal>@Configuration</literal>. However, if it is, then take care to exclude it from any <literal>@ComponentScan</literal> that would otherwise include this configuration as it will become the default source for <literal>feign.Decoder</literal>, <literal>feign.Encoder</literal>, <literal>feign.Contract</literal>, etc., when specified. This can be avoided by putting it in a separate, non-overlapping package from any <literal>@ComponentScan</literal> or <literal>@SpringBootApplication</literal>, or it can be explicitly excluded in <literal>@ComponentScan</literal>.</simpara>
</note>
<note>
<simpara>The <literal>serviceId</literal> attribute is now deprecated in favor of the <literal>name</literal> attribute.</simpara>
</note>
<warning>
<simpara>Previously, using the <literal>url</literal> attribute, did not require the <literal>name</literal> attribute. Using <literal>name</literal> is now required.</simpara>
</warning>
<simpara>Placeholders are supported in the <literal>name</literal> and <literal>url</literal> attributes.</simpara>
<programlisting language="java" linenumbering="unnumbered">@FeignClient(name = "${feign.name}", url = "${feign.url}")
public interface StoreClient {
    //..
}</programlisting>
<simpara>Spring Cloud Netflix provides the following beans by default for feign (<literal>BeanType</literal> beanName: <literal>ClassName</literal>):</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Decoder</literal> feignDecoder: <literal>ResponseEntityDecoder</literal> (which wraps a <literal>SpringDecoder</literal>)</simpara>
</listitem>
<listitem>
<simpara><literal>Encoder</literal> feignEncoder: <literal>SpringEncoder</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Logger</literal> feignLogger: <literal>Slf4jLogger</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Contract</literal> feignContract: <literal>SpringMvcContract</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Feign.Builder</literal> feignBuilder: <literal>HystrixFeign.Builder</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Client</literal> feignClient: if Ribbon is enabled it is a <literal>LoadBalancerFeignClient</literal>, otherwise the default feign client is used.</simpara>
</listitem>
</itemizedlist>
<simpara>The OkHttpClient and ApacheHttpClient feign clients can be used by setting <literal>feign.okhttp.enabled</literal> or <literal>feign.httpclient.enabled</literal> to <literal>true</literal>, respectively, and having them on the classpath.
You can customize the HTTP client used by providing a bean of either <literal>ClosableHttpClient</literal> when using Apache or <literal>OkHttpClient</literal> whe using OK HTTP.</simpara>
<simpara>Spring Cloud Netflix <emphasis>does not</emphasis> provide the following beans by default for feign, but still looks up beans of these types from the application context to create the feign client:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Logger.Level</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Retryer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ErrorDecoder</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Request.Options</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Collection&lt;RequestInterceptor&gt;</literal></simpara>
</listitem>
<listitem>
<simpara><literal>SetterFactory</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Creating a bean of one of those type and placing it in a <literal>@FeignClient</literal> configuration (such as <literal>FooConfiguration</literal> above) allows you to override each one of the beans described.  Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
public class FooConfiguration {
    @Bean
    public Contract feignContract() {
        return new feign.Contract.Default();
    }

    @Bean
    public BasicAuthRequestInterceptor basicAuthRequestInterceptor() {
        return new BasicAuthRequestInterceptor("user", "password");
    }
}</programlisting>
<simpara>This replaces the <literal>SpringMvcContract</literal> with <literal>feign.Contract.Default</literal> and adds a <literal>RequestInterceptor</literal> to the collection of <literal>RequestInterceptor</literal>.</simpara>
<simpara><literal>@FeignClient</literal> also can be configured using configuration properties.</simpara>
<simpara>application.yml</simpara>
<programlisting language="yaml" linenumbering="unnumbered">feign:
  client:
    config:
      feignName:
        connectTimeout: 5000
        readTimeout: 5000
        loggerLevel: full
        errorDecoder: com.example.SimpleErrorDecoder
        retryer: com.example.SimpleRetryer
        requestInterceptors:
          - com.example.FooRequestInterceptor
          - com.example.BarRequestInterceptor
        decode404: false</programlisting>
<simpara>Default configurations can be specified in the <literal>@EnableFeignClients</literal> attribute <literal>defaultConfiguration</literal> in a similar manner as described above. The difference is that this configuration will apply to <emphasis>all</emphasis> feign clients.</simpara>
<simpara>If you prefer using configuration properties to configured all <literal>@FeignClient</literal>, you can create configuration properties with <literal>default</literal> feign name.</simpara>
<simpara>application.yml</simpara>
<programlisting language="yaml" linenumbering="unnumbered">feign:
  client:
    config:
      default:
        connectTimeout: 5000
        readTimeout: 5000
        loggerLevel: basic</programlisting>
<simpara>If we create both <literal>@Configuration</literal> bean and configuration properties, configuration properties will win.
It will override <literal>@Configuration</literal> values. But if you want to change the priority to <literal>@Configuration</literal>,
you can change <literal>feign.client.default-to-properties</literal> to <literal>false</literal>.</simpara>
<note>
<simpara>If you need to use <literal>ThreadLocal</literal> bound variables in your <literal>RequestInterceptor`s you will need to either set the
thread isolation strategy for Hystrix to `SEMAPHORE</literal> or disable Hystrix in Feign.</simpara>
</note>
<simpara>application.yml</simpara>
<programlisting language="yaml" linenumbering="unnumbered"># To disable Hystrix in Feign
feign:
  hystrix:
    enabled: false

# To set thread isolation to SEMAPHORE
hystrix:
  command:
    default:
      execution:
        isolation:
          strategy: SEMAPHORE</programlisting>
</section>
<section xml:id="_creating_feign_clients_manually">
<title>Creating Feign Clients Manually</title>
<simpara>In some cases it might be necessary to customize your Feign Clients in a way that is not
possible using the methods above.  In this case you can create Clients using the
<link xl:href="https://github.com/OpenFeign/feign/#basics">Feign Builder API</link>. Below is an example
which creates two Feign Clients with the same interface but configures each one with
a separate request interceptor.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Import(FeignClientsConfiguration.class)
class FooController {

	private FooClient fooClient;

	private FooClient adminClient;

    	@Autowired
	public FooController(
			Decoder decoder, Encoder encoder, Client client) {
		this.fooClient = Feign.builder().client(client)
				.encoder(encoder)
				.decoder(decoder)
				.requestInterceptor(new BasicAuthRequestInterceptor("user", "user"))
				.target(FooClient.class, "http://PROD-SVC");
		this.adminClient = Feign.builder().client(client)
				.encoder(encoder)
				.decoder(decoder)
				.requestInterceptor(new BasicAuthRequestInterceptor("admin", "admin"))
				.target(FooClient.class, "http://PROD-SVC");
    }
}</programlisting>
<note>
<simpara>In the above example <literal>FeignClientsConfiguration.class</literal> is the default configuration
provided by Spring Cloud Netflix.</simpara>
</note>
<note>
<simpara><literal>PROD-SVC</literal> is the name of the service the Clients will be making requests to.</simpara>
</note>
</section>
<section xml:id="spring-cloud-feign-hystrix">
<title>Feign Hystrix Support</title>
<simpara>If Hystrix is on the classpath and <literal>feign.hystrix.enabled=true</literal>, Feign will wrap all methods with a circuit breaker. Returning a <literal>com.netflix.hystrix.HystrixCommand</literal> is also available. This lets you use reactive patterns (with a call to <literal>.toObservable()</literal> or <literal>.observe()</literal> or asynchronous use (with a call to <literal>.queue()</literal>).</simpara>
<simpara>To disable Hystrix support on a per-client basis create a vanilla <literal>Feign.Builder</literal> with the "prototype" scope, e.g.:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
public class FooConfiguration {
    	@Bean
	@Scope("prototype")
	public Feign.Builder feignBuilder() {
		return Feign.builder();
	}
}</programlisting>
<warning>
<simpara>Prior to the Spring Cloud Dalston release, if Hystrix was on the classpath Feign would have wrapped
all methods in a circuit breaker by default.  This default behavior was changed in Spring Cloud Dalston in
favor for an opt-in approach.</simpara>
</warning>
</section>
<section xml:id="spring-cloud-feign-hystrix-fallback">
<title>Feign Hystrix Fallbacks</title>
<simpara>Hystrix supports the notion of a fallback: a default code path that is executed when they circuit is open or there is an error. To enable fallbacks for a given <literal>@FeignClient</literal> set the <literal>fallback</literal> attribute to the class name that implements the fallback. You also need to declare your implementation as a Spring bean.</simpara>
<programlisting language="java" linenumbering="unnumbered">@FeignClient(name = "hello", fallback = HystrixClientFallback.class)
protected interface HystrixClient {
    @RequestMapping(method = RequestMethod.GET, value = "/hello")
    Hello iFailSometimes();
}

static class HystrixClientFallback implements HystrixClient {
    @Override
    public Hello iFailSometimes() {
        return new Hello("fallback");
    }
}</programlisting>
<simpara>If one needs access to the cause that made the fallback trigger, one can use the <literal>fallbackFactory</literal> attribute inside <literal>@FeignClient</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@FeignClient(name = "hello", fallbackFactory = HystrixClientFallbackFactory.class)
protected interface HystrixClient {
	@RequestMapping(method = RequestMethod.GET, value = "/hello")
	Hello iFailSometimes();
}

@Component
static class HystrixClientFallbackFactory implements FallbackFactory&lt;HystrixClient&gt; {
	@Override
	public HystrixClient create(Throwable cause) {
		return new HystrixClient() {
			@Override
			public Hello iFailSometimes() {
				return new Hello("fallback; reason was: " + cause.getMessage());
			}
		};
	}
}</programlisting>
<warning>
<simpara>There is a limitation with the implementation of fallbacks in Feign and how Hystrix fallbacks work. Fallbacks are currently not supported for methods that return <literal>com.netflix.hystrix.HystrixCommand</literal> and <literal>rx.Observable</literal>.</simpara>
</warning>
</section>
<section xml:id="_feign_and_literal_primary_literal">
<title>Feign and <literal>@Primary</literal></title>
<simpara>When using Feign with Hystrix fallbacks, there are multiple beans in the <literal>ApplicationContext</literal> of the same type. This will cause <literal>@Autowired</literal> to not work because there isn&#8217;t exactly one bean, or one marked as primary. To work around this, Spring Cloud Netflix marks all Feign instances as <literal>@Primary</literal>, so Spring Framework will know which bean to inject. In some cases, this may not be desirable. To turn off this behavior set the <literal>primary</literal> attribute of <literal>@FeignClient</literal> to false.</simpara>
<programlisting language="java" linenumbering="unnumbered">@FeignClient(name = "hello", primary = false)
public interface HelloClient {
	// methods here
}</programlisting>
</section>
<section xml:id="spring-cloud-feign-inheritance">
<title>Feign Inheritance Support</title>
<simpara>Feign supports boilerplate apis via single-inheritance interfaces.
This allows grouping common operations into convenient base interfaces.</simpara>
<formalpara>
<title>UserService.java</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public interface UserService {

    @RequestMapping(method = RequestMethod.GET, value ="/users/{id}")
    User getUser(@PathVariable("id") long id);
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>UserResource.java</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@RestController
public class UserResource implements UserService {

}</programlisting>
</para>
</formalpara>
<formalpara>
<title>UserClient.java</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package project.user;

@FeignClient("users")
public interface UserClient extends UserService {

}</programlisting>
</para>
</formalpara>
<note>
<simpara>It is generally not advisable to share an interface between a
server and a client. It introduces tight coupling, and also actually
doesn&#8217;t work with Spring MVC in its current form (method parameter
mapping is not inherited).</simpara>
</note>
</section>
<section xml:id="_feign_request_response_compression">
<title>Feign request/response compression</title>
<simpara>You may consider enabling the request or response GZIP compression for your
Feign requests. You can do this by enabling one of the properties:</simpara>
<programlisting language="java" linenumbering="unnumbered">feign.compression.request.enabled=true
feign.compression.response.enabled=true</programlisting>
<simpara>Feign request compression gives you settings similar to what you may set for your web server:</simpara>
<programlisting language="java" linenumbering="unnumbered">feign.compression.request.enabled=true
feign.compression.request.mime-types=text/xml,application/xml,application/json
feign.compression.request.min-request-size=2048</programlisting>
<simpara>These properties allow you to be selective about the compressed media types and minimum request threshold length.</simpara>
</section>
<section xml:id="_feign_logging">
<title>Feign logging</title>
<simpara>A logger is created for each Feign client created. By default the name of the logger is the full class name of the interface used to create the Feign client. Feign logging only responds to the <literal>DEBUG</literal> level.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">logging.level.project.user.UserClient: DEBUG</programlisting>
</para>
</formalpara>
<simpara>The <literal>Logger.Level</literal> object that you may configure per client, tells Feign how much to log. Choices are:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>NONE</literal>, No logging (<emphasis role="strong">DEFAULT</emphasis>).</simpara>
</listitem>
<listitem>
<simpara><literal>BASIC</literal>, Log only the request method and URL and the response status code and execution time.</simpara>
</listitem>
<listitem>
<simpara><literal>HEADERS</literal>, Log the basic information along with request and response headers.</simpara>
</listitem>
<listitem>
<simpara><literal>FULL</literal>, Log the headers, body, and metadata for both requests and responses.</simpara>
</listitem>
</itemizedlist>
<simpara>For example, the following would set the <literal>Logger.Level</literal> to <literal>FULL</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
public class FooConfiguration {
    @Bean
    Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}</programlisting>
</section>
</chapter>
<chapter xml:id="_external_configuration_archaius">
<title>External Configuration: Archaius</title>
<simpara><link xl:href="https://github.com/Netflix/archaius">Archaius</link> is the Netflix client side configuration library.  It is the library used by all of the Netflix OSS components for configuration.  Archaius is an extension of the <link xl:href="https://commons.apache.org/proper/commons-configuration">Apache Commons Configuration</link> project.  It allows updates to configuration by either polling a source for changes or for a source to push changes to the client.  Archaius uses Dynamic&lt;Type&gt;Property classes as handles to properties.</simpara>
<formalpara>
<title>Archaius Example</title>
<para>
<programlisting language="java" linenumbering="unnumbered">class ArchaiusTest {
    DynamicStringProperty myprop = DynamicPropertyFactory
            .getInstance()
            .getStringProperty("my.prop");

    void doSomething() {
        OtherClass.someMethod(myprop.get());
    }
}</programlisting>
</para>
</formalpara>
<simpara>Archaius has its own set of configuration files and loading priorities.  Spring applications should generally not use Archaius directly, but the need to configure the Netflix tools natively remains.  Spring Cloud has a Spring Environment Bridge so Archaius can read properties from the Spring Environment.  This allows Spring Boot projects to use the normal configuration toolchain, while allowing them to configure the Netflix tools, for the most part, as documented.</simpara>
</chapter>
<chapter xml:id="_router_and_filter_zuul">
<title>Router and Filter: Zuul</title>
<simpara>Routing in an integral part of a microservice architecture.  For example, <literal>/</literal> may be mapped to your web application, <literal>/api/users</literal> is mapped to the user service and <literal>/api/shop</literal> is mapped to the shop service.  <link xl:href="https://github.com/Netflix/zuul">Zuul</link> is a JVM based router and server side load balancer by Netflix.</simpara>
<simpara><link xl:href="https://www.slideshare.net/MikeyCohen1/edge-architecture-ieee-international-conference-on-cloud-engineering-32240146/27">Netflix uses Zuul</link> for the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Authentication</simpara>
</listitem>
<listitem>
<simpara>Insights</simpara>
</listitem>
<listitem>
<simpara>Stress Testing</simpara>
</listitem>
<listitem>
<simpara>Canary Testing</simpara>
</listitem>
<listitem>
<simpara>Dynamic Routing</simpara>
</listitem>
<listitem>
<simpara>Service Migration</simpara>
</listitem>
<listitem>
<simpara>Load Shedding</simpara>
</listitem>
<listitem>
<simpara>Security</simpara>
</listitem>
<listitem>
<simpara>Static Response handling</simpara>
</listitem>
<listitem>
<simpara>Active/Active traffic management</simpara>
</listitem>
</itemizedlist>
<simpara>Zuul&#8217;s rule engine allows rules and filters to be written in essentially any JVM language, with built in support for Java and Groovy.</simpara>
<note>
<simpara>The configuration property <literal>zuul.max.host.connections</literal> has been replaced by two new properties, <literal>zuul.host.maxTotalConnections</literal> and <literal>zuul.host.maxPerRouteConnections</literal> which default to 200 and 20 respectively.</simpara>
</note>
<note>
<simpara>Default Hystrix isolation pattern (ExecutionIsolationStrategy) for all routes is SEMAPHORE.  <literal>zuul.ribbonIsolationStrategy</literal> can be changed to THREAD if this isolation pattern is preferred.</simpara>
</note>
<section xml:id="netflix-zuul-starter">
<title>How to Include Zuul</title>
<simpara>To include Zuul in your project use the starter with group <literal>org.springframework.cloud</literal>
and artifact id <literal>spring-cloud-starter-netflix-zuul</literal>. See the <link xl:href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</link>
for details on setting up your build system with the current Spring Cloud Release Train.</simpara>
</section>
<section xml:id="netflix-zuul-reverse-proxy">
<title>Embedded Zuul Reverse Proxy</title>
<simpara>Spring Cloud has created an embedded Zuul proxy to ease the
development of a very common use case where a UI application wants to
proxy calls to one or more back end services.  This feature is useful
for a user interface to proxy to the backend services it requires,
avoiding the need to manage CORS and authentication concerns
independently for all the backends.</simpara>
<simpara>To enable it, annotate a Spring Boot main class with
<literal>@EnableZuulProxy</literal>, and this forwards local calls to the appropriate
service.  By convention, a service with the ID "users", will
receive requests from the proxy located at <literal>/users</literal> (with the prefix
stripped). The proxy uses Ribbon to locate an instance to forward to
via discovery, and all requests are executed in a
<link linkend="hystrix-fallbacks-for-routes">hystrix command</link>, so
failures will show up in Hystrix metrics, and once the circuit is open
the proxy will not try to contact the service.</simpara>
<note>
<simpara>the Zuul starter does not include a discovery client, so for
routes based on service IDs you need to provide one of those
on the classpath as well (e.g. Eureka is one choice).</simpara>
</note>
<simpara>To skip having a service automatically added, set
<literal>zuul.ignored-services</literal> to a list of service id patterns. If a service
matches a pattern that is ignored, but also included in the explicitly
configured routes map, then it will be unignored. Example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  ignoredServices: '*'
  routes:
    users: /myusers/**</programlisting>
</para>
</formalpara>
<simpara>In this example, all services are ignored <emphasis role="strong">except</emphasis> "users".</simpara>
<simpara>To augment or change
the proxy routes, you can add external configuration like the
following:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  routes:
    users: /myusers/**</programlisting>
</para>
</formalpara>
<simpara>This means that http calls to "/myusers" get forwarded to the "users"
service (for example "/myusers/101" is forwarded to "/101").</simpara>
<simpara>To get more fine-grained control over a route you can specify the path
and the serviceId independently:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  routes:
    users:
      path: /myusers/**
      serviceId: users_service</programlisting>
</para>
</formalpara>
<simpara>This means that http calls to "/myusers" get forwarded to the
"users_service" service.  The route has to have a "path" which can be
specified as an ant-style pattern, so "/myusers/*" only matches one
level, but "/myusers/**" matches hierarchically.</simpara>
<simpara>The location of the backend can be specified as either a "serviceId"
(for a service from discovery) or a "url" (for a physical location), e.g.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  routes:
    users:
      path: /myusers/**
      url: https://example.com/users_service</programlisting>
</para>
</formalpara>
<simpara>These simple url-routes don&#8217;t get executed as a <literal>HystrixCommand</literal> nor do they loadbalance multiple URLs with Ribbon.
To achieve this, you can specify a <literal>serviceId</literal> with a static list of servers:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">zuul:
  routes:
    echo:
      path: /myusers/**
      serviceId: myusers-service
      stripPrefix: true

hystrix:
  command:
    myusers-service:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: ...

myusers-service:
  ribbon:
    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList
    ListOfServers: https://example1.com,http://example2.com
    ConnectTimeout: 1000
    ReadTimeout: 3000
    MaxTotalHttpConnections: 500
    MaxConnectionsPerHost: 100</programlisting>
</para>
</formalpara>
<simpara>Another method is specifiying a service-route and configure a Ribbon client for the
serviceId (this requires disabling Eureka support in Ribbon:
see <link linkend="spring-cloud-ribbon-without-eureka">above for more information</link>), e.g.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">zuul:
  routes:
    users:
      path: /myusers/**
      serviceId: users

ribbon:
  eureka:
    enabled: false

users:
  ribbon:
    listOfServers: example.com,google.com</programlisting>
</para>
</formalpara>
<simpara>You can provide convention between serviceId and routes using
regexmapper.  It uses regular expression named groups to extract
variables from serviceId and inject them into a route pattern.</simpara>
<formalpara>
<title>ApplicationConfiguration.java</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@Bean
public PatternServiceRouteMapper serviceRouteMapper() {
    return new PatternServiceRouteMapper(
        "(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)",
        "${version}/${name}");
}</programlisting>
</para>
</formalpara>
<simpara>This means that a serviceId "myusers-v1" will be mapped to route
"/v1/myusers/**".  Any regular expression is accepted but all named
groups must be present in both servicePattern and routePattern.  If
servicePattern does not match a serviceId, the default behavior is
used. In the example above, a serviceId "myusers" will be mapped to route
"/myusers/**" (no version detected) This feature is disabled by
default and only applies to discovered services.</simpara>
<simpara>To add a prefix to all mappings, set <literal>zuul.prefix</literal> to a value, such as
<literal>/api</literal>. The proxy prefix is stripped from the request before the
request is forwarded by default (switch this behaviour off with
<literal>zuul.stripPrefix=false</literal>). You can also switch off the stripping of
the service-specific prefix from individual routes, e.g.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  routes:
    users:
      path: /myusers/**
      stripPrefix: false</programlisting>
</para>
</formalpara>
<note>
<simpara><literal>zuul.stripPrefix</literal> only applies to the prefix set in <literal>zuul.prefix</literal>.  It does not have any effect on prefixes
defined within a given route&#8217;s <literal>path</literal>.</simpara>
</note>
<simpara>In this example, requests to "/myusers/101" will be forwarded to "/myusers/101" on the "users" service.</simpara>
<simpara>The <literal>zuul.routes</literal> entries actually bind to an object of type <literal>ZuulProperties</literal>. If you
look at the properties of that object you will see that it also has a "retryable" flag.
Set that flag to "true" to have the Ribbon client automatically retry failed requests
(and if you need to you can modify the parameters of the retry operations using
the Ribbon client configuration).</simpara>
<simpara>The <literal>X-Forwarded-Host</literal> header is added to the forwarded requests by
default.  To turn it off set <literal>zuul.addProxyHeaders = false</literal>.  The
prefix path is stripped by default, and the request to the backend
picks up a header "X-Forwarded-Prefix" ("/myusers" in the examples
above).</simpara>
<simpara>An application with <literal>@EnableZuulProxy</literal> could act as a standalone
server if you set a default route ("/"), for example <literal>zuul.route.home:
/</literal> would route all traffic (i.e. "/**") to the "home" service.</simpara>
<simpara>If more fine-grained ignoring is needed, you can specify specific patterns to ignore.
These patterns are evaluated at the start of the route location process, which
means prefixes should be included in the pattern to warrant a match. Ignored patterns
span all services and supersede any other route specification.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  ignoredPatterns: /**/admin/**
  routes:
    users: /myusers/**</programlisting>
</para>
</formalpara>
<simpara>This means that all calls such as "/myusers/101" will be forwarded to "/101" on the "users" service.
But calls including "/admin/" will not resolve.</simpara>
<warning>
<simpara>If you need your routes to have their order preserved you need to use a YAML
file as the ordering will be lost using a properties file. For example:</simpara>
</warning>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  routes:
    users:
      path: /myusers/**
    legacy:
      path: /**</programlisting>
</para>
</formalpara>
<simpara>If you were to use a properties file, the <literal>legacy</literal> path may end up in front of the <literal>users</literal>
path rendering the <literal>users</literal> path unreachable.</simpara>
</section>
<section xml:id="_zuul_http_client">
<title>Zuul Http Client</title>
<simpara>The default HTTP client used by zuul is now backed by the Apache HTTP Client instead of the
deprecated Ribbon <literal>RestClient</literal>. To use <literal>RestClient</literal> or to use the <literal>okhttp3.OkHttpClient</literal> set
<literal>ribbon.restclient.enabled=true</literal> or <literal>ribbon.okhttp.enabled=true</literal> respectively.  If you would
like to customize the Apache HTTP client or the OK HTTP client provide a bean of type
<literal>ClosableHttpClient</literal> or <literal>OkHttpClient</literal>.</simpara>
</section>
<section xml:id="_cookies_and_sensitive_headers">
<title>Cookies and Sensitive Headers</title>
<simpara>It&#8217;s OK to share headers between services in the same system, but you
probably don&#8217;t want sensitive headers leaking downstream into external
servers. You can specify a list of ignored headers as part of the
route configuration. Cookies play a special role because they have
well-defined semantics in browsers, and they are always to be treated
as sensitive. If the consumer of your proxy is a browser, then cookies
for downstream services also cause problems for the user because they
all get jumbled up (all downstream services look like they come from
the same place).</simpara>
<simpara>If you are careful with the design of your services, for example if
only one of the downstream services sets cookies, then you might be
able to let them flow from the backend all the way up to the
caller. Also, if your proxy sets cookies and all your back end
services are part of the same system, it can be natural to simply
share them (and for instance use Spring Session to link them up to some
shared state). Other than that, any cookies that get set by downstream
services are likely to be not very useful to the caller, so it is
recommended that you make (at least) "Set-Cookie" and "Cookie" into
sensitive headers for routes that are not part of your domain. Even
for routes that <emphasis role="strong">are</emphasis> part of your domain, try to think carefully
about what it means before allowing cookies to flow between them and
the proxy.</simpara>
<simpara>The sensitive headers can be configured as a comma-separated list per
route, e.g.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  routes:
    users:
      path: /myusers/**
      sensitiveHeaders: Cookie,Set-Cookie,Authorization
      url: https://downstream</programlisting>
</para>
</formalpara>
<note>
<simpara>this is the default value for <literal>sensitiveHeaders</literal>, so you don&#8217;t
need to set it unless you want it to be different. N.B. this is new in
Spring Cloud Netflix 1.1 (in 1.0 the user had no control over headers
and all cookies flow in both directions).</simpara>
</note>
<simpara>The <literal>sensitiveHeaders</literal> are a blacklist and the default is not empty,
so to make Zuul send all headers (except the "ignored" ones) you would
have to explicitly set it to the empty list. This is necessary if you
want to pass cookie or authorization headers to your back end. Example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  routes:
    users:
      path: /myusers/**
      sensitiveHeaders:
      url: https://downstream</programlisting>
</para>
</formalpara>
<simpara>Sensitive headers can also be set globally by setting <literal>zuul.sensitiveHeaders</literal>. If <literal>sensitiveHeaders</literal> is set on a route, this will override the global <literal>sensitiveHeaders</literal> setting.</simpara>
</section>
<section xml:id="_ignored_headers">
<title>Ignored Headers</title>
<simpara>In addition to the per-route sensitive headers, you can set a global
value for <literal>zuul.ignoredHeaders</literal> for values that should be discarded
(both request and response) during interactions with downstream
services. By default these are empty, if Spring Security is not on the
classpath, and otherwise they are initialized to a set of well-known
"security" headers (e.g. involving caching) as specified by Spring
Security. The assumption in this case is that the downstream services
might add these headers too, and we want the values from the proxy.
To not discard these well known security headers in case Spring Security is on the classpath you can set <literal>zuul.ignoreSecurityHeaders</literal> to <literal>false</literal>. This can be useful if you disabled the HTTP Security response headers in Spring Security and want the values provided by downstream services</simpara>
</section>
<section xml:id="_management_endpoints">
<title>Management Endpoints</title>
<simpara>If you are using <literal>@EnableZuulProxy</literal> with the Spring Boot Actuator you
will enable (by default) two additional endpoints:</simpara>
<itemizedlist>
<listitem>
<simpara>Routes</simpara>
</listitem>
<listitem>
<simpara>Filters</simpara>
</listitem>
</itemizedlist>
<section xml:id="_routes_endpoint">
<title>Routes Endpoint</title>
<simpara>A GET to the routes endpoint at <literal>/routes</literal> will return a list of the mapped
routes:</simpara>
<formalpara>
<title>GET /routes</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  /stores/**: "http://localhost:8081"
}</programlisting>
</para>
</formalpara>
<simpara>Additional route details can be requested by adding the <literal>?format=details</literal> query
string to <literal>/routes</literal>. This will produce the following output:</simpara>
<formalpara>
<title>GET /routes?format=details</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "/stores/**": {
    "id": "stores",
    "fullPath": "/stores/**",
    "location": "http://localhost:8081",
    "path": "/**",
    "prefix": "/stores",
    "retryable": false,
    "customSensitiveHeaders": false,
    "prefixStripped": true
  }
}</programlisting>
</para>
</formalpara>
<simpara>A POST will force a refresh of the existing routes (e.g. in
case there have been changes in the service catalog).  You can disable
this endpoint by setting <literal>endpoints.routes.enabled</literal> to <literal>false</literal>.</simpara>
<note>
<simpara>the routes should respond automatically to changes in the
service catalog, but the POST to /routes is a way to force the change
to happen immediately.</simpara>
</note>
</section>
<section xml:id="_filters_endpoint">
<title>Filters Endpoint</title>
<simpara>A GET to the filters endpoint at <literal>/filters</literal> will return a map of Zuul
filters by type. For each filter type in the map, you will find a list
of all the filters of that type, along with their details.</simpara>
</section>
</section>
<section xml:id="_strangulation_patterns_and_local_forwards">
<title>Strangulation Patterns and Local Forwards</title>
<simpara>A common pattern when migrating an existing application or API is to
"strangle" old endpoints, slowly replacing them with different
implementations. The Zuul proxy is a useful tool for this because you
can use it to handle all traffic from clients of the old endpoints,
but redirect some of the requests to new ones.</simpara>
<simpara>Example configuration:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  routes:
    first:
      path: /first/**
      url: https://first.example.com
    second:
      path: /second/**
      url: forward:/second
    third:
      path: /third/**
      url: forward:/3rd
    legacy:
      path: /**
      url: https://legacy.example.com</programlisting>
</para>
</formalpara>
<simpara>In this example we are strangling the "legacy" app which is mapped to
all requests that do not match one of the other patterns. Paths in
<literal>/first/**</literal> have been extracted into a new service with an external
URL. And paths in <literal>/second/**</literal> are forwarded so they can be handled
locally, e.g. with a normal Spring <literal>@RequestMapping</literal>. Paths in
<literal>/third/**</literal> are also forwarded, but with a different prefix
(i.e. <literal>/third/foo</literal> is forwarded to <literal>/3rd/foo</literal>).</simpara>
<note>
<simpara>The ignored patterns aren&#8217;t completely ignored, they just
aren&#8217;t handled by the proxy (so they are also effectively forwarded
locally).</simpara>
</note>
</section>
<section xml:id="_uploading_files_through_zuul">
<title>Uploading Files through Zuul</title>
<simpara>If you <literal>@EnableZuulProxy</literal> you can use the proxy paths to
upload files and it should just work as long as the files
are small. For large files there is an alternative path
which bypasses the Spring <literal>DispatcherServlet</literal> (to
avoid multipart processing) in "/zuul/*". I.e. if
<literal>zuul.routes.customers=/customers/**</literal> then you can
POST large files to "/zuul/customers/*". The servlet
path is externalized via <literal>zuul.servletPath</literal>. Extremely
large files will also require elevated timeout settings
if the proxy route takes you through a Ribbon load
balancer, e.g.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 60000
ribbon:
  ConnectTimeout: 3000
  ReadTimeout: 60000</programlisting>
</para>
</formalpara>
<simpara>Note that for streaming to work with large files, you need to use chunked encoding in the request (which some browsers
do not do by default). E.g. on the command line:</simpara>
<screen>$ curl -v -H "Transfer-Encoding: chunked" \
    -F "file=@mylarge.iso" localhost:9999/zuul/simple/file</screen>
</section>
<section xml:id="_query_string_encoding">
<title>Query String Encoding</title>
<simpara>When processing the incoming request, query params are decoded so they can be available for possible modifications in
Zuul filters. They are then re-encoded when building the backend request in the route filters. The result
can be different than the original input if it was encoded using Javascript&#8217;s <literal>encodeURIComponent()</literal> method for example.
While this causes no issues in most cases, some web servers can be picky with the encoding of complex query string.</simpara>
<simpara>To force the original encoding of the query string, it is possible to pass a special flag to <literal>ZuulProperties</literal> so
that the query string is taken as is with the <literal>HttpServletRequest::getQueryString</literal> method :</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  forceOriginalQueryStringEncoding: true</programlisting>
</para>
</formalpara>
<simpara><emphasis role="strong">Note:</emphasis> This special flag only works with <literal>SimpleHostRoutingFilter</literal> and you loose the ability to easily override
query parameters with <literal>RequestContext.getCurrentContext().setRequestQueryParams(someOverriddenParameters)</literal> since
the query string is now fetched directly on the original <literal>HttpServletRequest</literal>.</simpara>
</section>
<section xml:id="_plain_embedded_zuul">
<title>Plain Embedded Zuul</title>
<simpara>You can also run a Zuul server without the proxying, or switch on parts of the proxying platform selectively, if you
use <literal>@EnableZuulServer</literal> (instead of <literal>@EnableZuulProxy</literal>). Any beans that you add to the application of type <literal>ZuulFilter</literal>
will be installed automatically, as they are with <literal>@EnableZuulProxy</literal>, but without any of the proxy filters being added
automatically.</simpara>
<simpara>In this case the routes into the Zuul server are still specified by
configuring "zuul.routes.*", but there is no service
discovery and no proxying, so the "serviceId" and "url" settings are
ignored. For example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"> zuul:
  routes:
    api: /api/**</programlisting>
</para>
</formalpara>
<simpara>maps all paths in "/api/**" to the Zuul filter chain.</simpara>
</section>
<section xml:id="_disable_zuul_filters">
<title>Disable Zuul Filters</title>
<simpara>Zuul for Spring Cloud comes with a number of <literal>ZuulFilter</literal> beans enabled by default
in both proxy and server mode.  See <link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-zuul/src/main/java/org/springframework/cloud/netflix/zuul/filters">the zuul filters package</link> for the
possible filters that are enabled.  If you want to disable one, simply set
<literal>zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true</literal>. By convention, the package after
<literal>filters</literal> is the Zuul filter type. For example to disable
<literal>org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter</literal> set
<literal>zuul.SendResponseFilter.post.disable=true</literal>.</simpara>
</section>
<section xml:id="hystrix-fallbacks-for-routes">
<title>Providing Hystrix Fallbacks For Routes</title>
<simpara>When a circuit for a given route in Zuul is tripped you can provide a fallback response
by creating a bean of type <literal>ZuulFallbackProvider</literal>.  Within this bean you need to specify
the route ID the fallback is for and provide a <literal>ClientHttpResponse</literal> to return
as a fallback.  Here is a very simple <literal>ZuulFallbackProvider</literal> implementation.</simpara>
<programlisting language="java" linenumbering="unnumbered">class MyFallbackProvider implements ZuulFallbackProvider {
    @Override
    public String getRoute() {
        return "customers";
    }

    @Override
    public ClientHttpResponse fallbackResponse() {
        return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return HttpStatus.OK;
            }

            @Override
            public int getRawStatusCode() throws IOException {
                return 200;
            }

            @Override
            public String getStatusText() throws IOException {
                return "OK";
            }

            @Override
            public void close() {

            }

            @Override
            public InputStream getBody() throws IOException {
                return new ByteArrayInputStream("fallback".getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                return headers;
            }
        };
    }
}</programlisting>
<simpara>And here is what the route configuration would look like.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">zuul:
  routes:
    customers: /customers/**</programlisting>
<simpara>If you would like to provide a default fallback for all routes than you can create a bean of
type <literal>ZuulFallbackProvider</literal> and have the <literal>getRoute</literal> method return <literal>*</literal> or <literal>null</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">class MyFallbackProvider implements ZuulFallbackProvider {
    @Override
    public String getRoute() {
        return "*";
    }

    @Override
    public ClientHttpResponse fallbackResponse() {
        return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return HttpStatus.OK;
            }

            @Override
            public int getRawStatusCode() throws IOException {
                return 200;
            }

            @Override
            public String getStatusText() throws IOException {
                return "OK";
            }

            @Override
            public void close() {

            }

            @Override
            public InputStream getBody() throws IOException {
                return new ByteArrayInputStream("fallback".getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                return headers;
            }
        };
    }
}</programlisting>
<simpara>If you would like to choose the response based on the cause of the failure use <literal>FallbackProvider</literal> which will replace <literal>ZuulFallbackProvder</literal> in future versions.</simpara>
<programlisting language="java" linenumbering="unnumbered">class MyFallbackProvider implements FallbackProvider {

    @Override
    public String getRoute() {
        return "*";
    }

    @Override
    public ClientHttpResponse fallbackResponse(final Throwable cause) {
        if (cause instanceof HystrixTimeoutException) {
            return response(HttpStatus.GATEWAY_TIMEOUT);
        } else {
            return fallbackResponse();
        }
    }

    @Override
    public ClientHttpResponse fallbackResponse() {
        return response(HttpStatus.INTERNAL_SERVER_ERROR);
    }

    private ClientHttpResponse response(final HttpStatus status) {
        return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return status;
            }

            @Override
            public int getRawStatusCode() throws IOException {
                return status.value();
            }

            @Override
            public String getStatusText() throws IOException {
                return status.getReasonPhrase();
            }

            @Override
            public void close() {
            }

            @Override
            public InputStream getBody() throws IOException {
                return new ByteArrayInputStream("fallback".getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                return headers;
            }
        };
    }
}</programlisting>
</section>
<section xml:id="_zuul_timeouts">
<title>Zuul Timeouts</title>
<section xml:id="_service_discovery_configuration">
<title>Service Discovery Configuration</title>
<simpara>If Zuul is using service discovery there are two timeouts you need to be concerned
with, the Hystrix timeout (since all routes are wrapped in Hystrix commands by default)
and the Ribbon timeout.  The Hystrix timeout needs to take into account the Ribbon
read and connect timeout PLUS the total number of retries that will happen for that
service.  By default Spring Cloud Zuul will do its best to calculate the Hystrix timeout
for you <emphasis role="strong">UNLESS</emphasis> you specify the Hystrix timeout explicitly.</simpara>
<simpara>The Hystrix timeout is calculated using the following formula:</simpara>
<screen>(ribbon.ConnectTimeout + ribbon.ReadTimeout) * (ribbon.MaxAutoRetries + 1) * (ribbon.MaxAutoRetriesNextServer + 1)</screen>
<simpara>As an example, if you set the following properties in your application properties</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>ribbon:
  ReadTimeout:100
  ConnectTimeout:500
  MaxAutoRetries:1
  MaxAutoRetriesNextServer:1</screen>
</para>
</formalpara>
<simpara>Then the Hystrix timeout (for all routes in this case) will be set to <literal>2400ms.</literal></simpara>
<note>
<simpara>You can configure the Hystrix timeout for individual routes using <literal>service.ribbon.*</literal> properties.</simpara>
</note>
<note>
<simpara>If you choose to not configure the above properties than the default values will be used therefore the
default Hystrix timeout will be set to <literal>4000ms</literal>.</simpara>
</note>
<simpara>If you set <literal>hystrix.command.commandKey.execution.isolation.thread.timeoutInMilliseconds</literal>, where
<literal>commandKey</literal> is the route id, or set <literal>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</literal>
than these values will be used for the Hystrix timeout regardless of what you have set for the <literal>ribbon.*</literal> properties.
If you set either of these properties <emphasis role="strong">YOU</emphasis> are responsible for making sure it takes
into account the Ribbon connect and read timeouts as well as any retries that may happen.</simpara>
</section>
<section xml:id="_url_configuration">
<title>URL Configuration</title>
<simpara>If you have configured Zuul routes by specifying URLs than you will need to use
<literal>zuul.host.connect-timeout-millis</literal> and <literal>zuul.host.socket-timeout-millis</literal>.</simpara>
</section>
</section>
<section xml:id="zuul-redirect-location-rewrite">
<title>Rewriting <literal>Location</literal> header</title>
<simpara>If Zuul is fronting a web application then there may be a need to re-write the <literal>Location</literal> header when the web application redirects through a http status code of 3XX, otherwise the browser will end up redirecting to the web application&#8217;s url instead of the Zuul url.
A <literal>LocationRewriteFilter</literal> Zuul filter can  be configured to re-write the Location header to the Zuul&#8217;s url, it also adds back the stripped global and route specific prefixes. The filter can be added the following way via a Spring Configuration file:</simpara>
<programlisting language="java" linenumbering="unnumbered">import org.springframework.cloud.netflix.zuul.filters.post.LocationRewriteFilter;
...

@Configuration
@EnableZuulProxy
public class ZuulConfig {
    @Bean
    public LocationRewriteFilter locationRewriteFilter() {
        return new LocationRewriteFilter();
    }
}</programlisting>
<warning>
<simpara>Use this filter with caution though, the filter acts on the <literal>Location</literal> header of ALL 3XX response codes which may not be appropriate in all scenarios, say if the user is redirecting to an external URL.</simpara>
</warning>
</section>
<section xml:id="zuul-developer-guide">
<title>Zuul Developer Guide</title>
<simpara>For a general overview of how Zuul works, please see <link xl:href="https://github.com/Netflix/zuul/wiki/How-it-Works">the Zuul Wiki</link>.</simpara>
<section xml:id="_the_zuul_servlet">
<title>The Zuul Servlet</title>
<simpara>Zuul is implemented as a Servlet. For the general cases, Zuul is embedded into the Spring Dispatch mechanism. This allows Spring MVC to be in control of the routing. In this case, Zuul is configured to buffer requests. If there is a need to go through Zuul without buffering requests (e.g. for large file uploads), the Servlet is also installed outside of the Spring Dispatcher. By default, this is located at <literal>/zuul</literal>. This path can be changed with the <literal>zuul.servlet-path</literal> property.</simpara>
</section>
<section xml:id="_zuul_requestcontext">
<title>Zuul RequestContext</title>
<simpara>To pass information between filters, Zuul uses a <link xl:href="https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/context/RequestContext.java"><literal>RequestContext</literal></link>. Its data is held in a <literal>ThreadLocal</literal> specific to each request. Information about where to route requests, errors and the actual <literal>HttpServletRequest</literal> and <literal>HttpServletResponse</literal> are stored there. The <literal>RequestContext</literal> extends <literal>ConcurrentHashMap</literal>, so anything can be stored in the context. <link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/zuul/filters/support/FilterConstants.java"><literal>FilterConstants</literal></link> contains the keys that are used by the filters installed by Spring Cloud Netflix (more on these later).</simpara>
</section>
<section xml:id="__literal_enablezuulproxy_literal_vs_literal_enablezuulserver_literal">
<title><literal>@EnableZuulProxy</literal> vs. <literal>@EnableZuulServer</literal></title>
<simpara>Spring Cloud Netflix installs a number of filters based on which annotation was used to enable Zuul. <literal>@EnableZuulProxy</literal> is a superset of <literal>@EnableZuulServer</literal>. In other words, <literal>@EnableZuulProxy</literal> contains all filters installed by <literal>@EnableZuulServer</literal>. The additional filters in the "proxy" enable routing functionality. If you want a "blank" Zuul, you should use <literal>@EnableZuulServer</literal>.</simpara>
</section>
<section xml:id="__literal_enablezuulserver_literal_filters">
<title><literal>@EnableZuulServer</literal> Filters</title>
<simpara>Creates a <literal>SimpleRouteLocator</literal> that loads route definitions from Spring Boot configuration files.</simpara>
<simpara>The following filters are installed (as normal Spring Beans):</simpara>
<simpara>Pre filters:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ServletDetectionFilter</literal>: Detects if the request is through the Spring Dispatcher. Sets boolean with key <literal>FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>FormBodyWrapperFilter</literal>: Parses form data and reencodes it for downstream requests.</simpara>
</listitem>
<listitem>
<simpara><literal>DebugFilter</literal>: if the <literal>debug</literal> request parameter is set, this filter sets <literal>RequestContext.setDebugRouting()</literal> and <literal>RequestContext.setDebugRequest()</literal> to true.</simpara>
</listitem>
</itemizedlist>
<simpara>Route filters:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>SendForwardFilter</literal>: This filter forwards requests using the Servlet <literal>RequestDispatcher</literal>. The forwarding location is stored in the <literal>RequestContext</literal> attribute <literal>FilterConstants.FORWARD_TO_KEY</literal>. This is useful for forwarding to endpoints in the current application.</simpara>
</listitem>
</itemizedlist>
<simpara>Post filters:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>SendResponseFilter</literal>: Writes responses from proxied requests to the current response.</simpara>
</listitem>
</itemizedlist>
<simpara>Error filters:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>SendErrorFilter</literal>: Forwards to /error (by default) if <literal>RequestContext.getThrowable()</literal> is not null. The default forwarding path (<literal>/error</literal>) can be changed by setting the <literal>error.path</literal> property.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="__literal_enablezuulproxy_literal_filters">
<title><literal>@EnableZuulProxy</literal> Filters</title>
<simpara>Creates a <literal>DiscoveryClientRouteLocator</literal> that loads route definitions from a <literal>DiscoveryClient</literal> (like Eureka), as well as from properties. A route is created for each <literal>serviceId</literal> from the <literal>DiscoveryClient</literal>. As new services are added, the routes will be refreshed.</simpara>
<simpara>In addition to the filters described above, the following filters are installed (as normal Spring Beans):</simpara>
<simpara>Pre filters:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>PreDecorationFilter</literal>: This filter determines where and how to route based on the supplied <literal>RouteLocator</literal>. It also sets various proxy-related headers for downstream requests.</simpara>
</listitem>
</itemizedlist>
<simpara>Route filters:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>RibbonRoutingFilter</literal>: This filter uses Ribbon, Hystrix and pluggable HTTP clients to send requests. Service ids are found in the <literal>RequestContext</literal> attribute <literal>FilterConstants.SERVICE_ID_KEY</literal>. This filter can use different HTTP clients. They are:</simpara>
<itemizedlist>
<listitem>
<simpara>Apache <literal>HttpClient</literal>. This is the default client.</simpara>
</listitem>
<listitem>
<simpara>Squareup <literal>OkHttpClient</literal> v3. This is enabled by having the <literal>com.squareup.okhttp3:okhttp</literal> library on the classpath and setting <literal>ribbon.okhttp.enabled=true</literal>.</simpara>
</listitem>
<listitem>
<simpara>Netflix Ribbon HTTP client. This is enabled by setting <literal>ribbon.restclient.enabled=true</literal>. This client has limitations, such as it doesn&#8217;t support the PATCH method, but also has built-in retry.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>SimpleHostRoutingFilter</literal>: This filter sends requests to predetermined URLs via an Apache HttpClient. URLs are found in <literal>RequestContext.getRouteHost()</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_custom_zuul_filter_examples">
<title>Custom Zuul Filter examples</title>
<simpara>Most of the following "How to Write" examples below are included <link xl:href="https://github.com/spring-cloud-samples/sample-zuul-filters">Sample Zuul Filters</link> project. There are also examples of manipulating the request or response body in that repository.</simpara>
</section>
<section xml:id="_how_to_write_a_pre_filter">
<title>How to Write a Pre Filter</title>
<simpara>Pre filters are used to set up data in the <literal>RequestContext</literal> for use in filters downstream. The main use case is to set information required for route filters.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class QueryParamPreFilter extends ZuulFilter {
	@Override
	public int filterOrder() {
		return PRE_DECORATION_FILTER_ORDER - 1; // run before PreDecoration
	}

	@Override
	public String filterType() {
		return PRE_TYPE;
	}

	@Override
	public boolean shouldFilter() {
		RequestContext ctx = RequestContext.getCurrentContext();
		return !ctx.containsKey(FORWARD_TO_KEY) // a filter has already forwarded
				&amp;&amp; !ctx.containsKey(SERVICE_ID_KEY); // a filter has already determined serviceId
	}
    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
		HttpServletRequest request = ctx.getRequest();
		if (request.getParameter("foo") != null) {
		    // put the serviceId in `RequestContext`
    		ctx.put(SERVICE_ID_KEY, request.getParameter("foo"));
    	}
        return null;
    }
}</programlisting>
<simpara>The filter above populates <literal>SERVICE_ID_KEY</literal> from the <literal>foo</literal> request parameter. In reality, it&#8217;s not a good idea to do that kind of direct mapping, but the service id should be looked up from the value of <literal>foo</literal> instead.</simpara>
<simpara>Now that <literal>SERVICE_ID_KEY</literal> is populated, <literal>PreDecorationFilter</literal> won&#8217;t run and <literal>RibbonRoutingFilter</literal> will. If you wanted to route to a full URL instead, call <literal>ctx.setRouteHost(url)</literal> instead.</simpara>
<simpara>To modify the path that routing filters will forward to, set the <literal>REQUEST_URI_KEY</literal>.</simpara>
</section>
<section xml:id="_how_to_write_a_route_filter">
<title>How to Write a Route Filter</title>
<simpara>Route filters are run after pre filters and are used to make requests to other services. Much of the work here is to translate request and response data to and from the client required model.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class OkHttpRoutingFilter extends ZuulFilter {
	@Autowired
	private ProxyRequestHelper helper;

	@Override
	public String filterType() {
		return ROUTE_TYPE;
	}

	@Override
	public int filterOrder() {
		return SIMPLE_HOST_ROUTING_FILTER_ORDER - 1;
	}

	@Override
	public boolean shouldFilter() {
		return RequestContext.getCurrentContext().getRouteHost() != null
				&amp;&amp; RequestContext.getCurrentContext().sendZuulResponse();
	}

    @Override
    public Object run() {
		OkHttpClient httpClient = new OkHttpClient.Builder()
				// customize
				.build();

		RequestContext context = RequestContext.getCurrentContext();
		HttpServletRequest request = context.getRequest();

		String method = request.getMethod();

		String uri = this.helper.buildZuulRequestURI(request);

		Headers.Builder headers = new Headers.Builder();
		Enumeration&lt;String&gt; headerNames = request.getHeaderNames();
		while (headerNames.hasMoreElements()) {
			String name = headerNames.nextElement();
			Enumeration&lt;String&gt; values = request.getHeaders(name);

			while (values.hasMoreElements()) {
				String value = values.nextElement();
				headers.add(name, value);
			}
		}

		InputStream inputStream = request.getInputStream();

		RequestBody requestBody = null;
		if (inputStream != null &amp;&amp; HttpMethod.permitsRequestBody(method)) {
			MediaType mediaType = null;
			if (headers.get("Content-Type") != null) {
				mediaType = MediaType.parse(headers.get("Content-Type"));
			}
			requestBody = RequestBody.create(mediaType, StreamUtils.copyToByteArray(inputStream));
		}

		Request.Builder builder = new Request.Builder()
				.headers(headers.build())
				.url(uri)
				.method(method, requestBody);

		Response response = httpClient.newCall(builder.build()).execute();

		LinkedMultiValueMap&lt;String, String&gt; responseHeaders = new LinkedMultiValueMap&lt;&gt;();

		for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : response.headers().toMultimap().entrySet()) {
			responseHeaders.put(entry.getKey(), entry.getValue());
		}

		this.helper.setResponse(response.code(), response.body().byteStream(),
				responseHeaders);
		context.setRouteHost(null); // prevent SimpleHostRoutingFilter from running
		return null;
    }
}</programlisting>
<simpara>The above filter translates Servlet request information into OkHttp3 request information, executes an HTTP request, then translates OkHttp3 reponse information to the Servlet response. WARNING: this filter might have bugs and not function correctly.</simpara>
</section>
<section xml:id="_how_to_write_a_post_filter">
<title>How to Write a Post Filter</title>
<simpara>Post filters typically manipulate the response. In the filter below, we add a random <literal>UUID</literal> as the <literal>X-Foo</literal> header. Other manipulations, such as transforming the response body, are much more complex and compute-intensive.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class AddResponseHeaderFilter extends ZuulFilter {
	@Override
	public String filterType() {
		return POST_TYPE;
	}

	@Override
	public int filterOrder() {
		return SEND_RESPONSE_FILTER_ORDER - 1;
	}

	@Override
	public boolean shouldFilter() {
		return true;
	}

	@Override
	public Object run() {
		RequestContext context = RequestContext.getCurrentContext();
    	HttpServletResponse servletResponse = context.getResponse();
		servletResponse.addHeader("X-Foo", UUID.randomUUID().toString());
		return null;
	}
}</programlisting>
</section>
<section xml:id="_how_zuul_errors_work">
<title>How Zuul Errors Work</title>
<simpara>If an exception is thrown during any portion of the Zuul filter lifecycle, the error filters are executed. The <literal>SendErrorFilter</literal> is only run if <literal>RequestContext.getThrowable()</literal> is not <literal>null</literal>. It then sets specific <literal>javax.servlet.error.*</literal> attributes in the request and forwards the request to the Spring Boot error page.</simpara>
</section>
<section xml:id="_zuul_eager_application_context_loading">
<title>Zuul Eager Application Context Loading</title>
<simpara>Zuul internally uses Ribbon for calling the remote url&#8217;s and Ribbon clients are by default lazily loaded up by Spring Cloud on first call.
This behavior can be changed for Zuul using the following configuration and will result in the child Ribbon related Application contexts being eagerly loaded up at application startup time.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>zuul:
  ribbon:
    eager-load:
      enabled: true</screen>
</para>
</formalpara>
</section>
</section>
</chapter>
<chapter xml:id="_polyglot_support_with_sidecar">
<title>Polyglot support with Sidecar</title>
<simpara>Do you have non-jvm languages you want to take advantage of Eureka, Ribbon and
Config Server?  The Spring Cloud Netflix Sidecar was inspired by
<link xl:href="https://github.com/Netflix/Prana">Netflix Prana</link>.  It includes a simple http api
to get all of the instances (ie host and port) for a given service.  You can
also proxy service calls through an embedded Zuul proxy which gets its route
entries from Eureka.  The Spring Cloud Config Server can be accessed directly
via host lookup or through the Zuul Proxy.  The non-jvm app should implement
a health check so the Sidecar can report to eureka if the app is up or down.</simpara>
<simpara>To include Sidecar in your project use the dependency with group <literal>org.springframework.cloud</literal>
and artifact id <literal>spring-cloud-netflix-sidecar</literal>.</simpara>
<simpara>To enable the Sidecar, create a Spring Boot application with <literal>@EnableSidecar</literal>.
This annotation includes <literal>@EnableCircuitBreaker</literal>, <literal>@EnableDiscoveryClient</literal>,
and <literal>@EnableZuulProxy</literal>.  Run the resulting application on the same host as the
non-jvm application.</simpara>
<simpara>To configure the side car add <literal>sidecar.port</literal> and <literal>sidecar.health-uri</literal> to <literal>application.yml</literal>.
The <literal>sidecar.port</literal> property is the port the non-jvm app is listening on.  This
is so the Sidecar can properly register the app with Eureka.  The <literal>sidecar.health-uri</literal>
is a uri accessible on the non-jvm app that mimicks a Spring Boot health
indicator.  It should return a json document like the following:</simpara>
<formalpara>
<title>health-uri-document</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "status":"UP"
}</programlisting>
</para>
</formalpara>
<simpara>Here is an example application.yml for a Sidecar application:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">server:
  port: 5678
spring:
  application:
    name: sidecar

sidecar:
  port: 8000
  health-uri: http://localhost:8000/health.json</programlisting>
</para>
</formalpara>
<simpara>The api for the <literal>DiscoveryClient.getInstances()</literal> method is <literal>/hosts/{serviceId}</literal>.
Here is an example response for <literal>/hosts/customers</literal> that returns two instances on
different hosts.  This api is accessible to the non-jvm app (if the sidecar is
on port 5678) at <literal><link xl:href="http://localhost:5678/hosts/{serviceId}">http://localhost:5678/hosts/{serviceId}</link></literal>.</simpara>
<formalpara>
<title>/hosts/customers</title>
<para>
<programlisting language="json" linenumbering="unnumbered">[
    {
        "host": "myhost",
        "port": 9000,
        "uri": "http://myhost:9000",
        "serviceId": "CUSTOMERS",
        "secure": false
    },
    {
        "host": "myhost2",
        "port": 9000,
        "uri": "http://myhost2:9000",
        "serviceId": "CUSTOMERS",
        "secure": false
    }
]</programlisting>
</para>
</formalpara>
<simpara>The Zuul proxy automatically adds routes for each service known in eureka to
<literal>/&lt;serviceId&gt;</literal>, so the customers service is available at <literal>/customers</literal>.  The
Non-jvm app can access the customer service via <literal><link xl:href="http://localhost:5678/customers">http://localhost:5678/customers</link></literal>
(assuming the sidecar is listening on port 5678).</simpara>
<simpara>If the Config Server is registered with Eureka, non-jvm application can access
it via the Zuul proxy.  If the serviceId of the ConfigServer is <literal>configserver</literal>
and the Sidecar is on port 5678, then it can be accessed at
<link xl:href="http://localhost:5678/configserver">http://localhost:5678/configserver</link></simpara>
<simpara>Non-jvm app can take advantage of the Config Server&#8217;s ability to return YAML
documents.  For example, a call to <link xl:href="https://sidecar.local.spring.io:5678/configserver/default-master.yml">https://sidecar.local.spring.io:5678/configserver/default-master.yml</link>
might result in a YAML document like the following</simpara>
<programlisting language="yaml" linenumbering="unnumbered">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
  password: password
info:
  description: Spring Cloud Samples
  url: https://github.com/spring-cloud-samples</programlisting>
</chapter>
<chapter xml:id="netflix-rxjava-springmvc">
<title>RxJava with Spring MVC</title>
<simpara>Spring Cloud Netflix includes <link xl:href="https://github.com/ReactiveX/RxJava">RxJava</link>.</simpara>
<blockquote>
<simpara>RxJava is a Java VM implementation of <link xl:href="http://reactivex.io/">Reactive Extensions</link>: a library for composing asynchronous and event-based programs by using observable sequences.</simpara>
</blockquote>
<simpara>Spring Cloud Netflix provides support for returning <literal>rx.Single</literal> objects from Spring MVC Controllers. It also supports using <literal>rx.Observable</literal> objects for <link xl:href="https://en.wikipedia.org/wiki/Server-sent_events">Server-sent events (SSE)</link>. This can be very convenient if your internal APIs are already built using RxJava (see <xref linkend="spring-cloud-feign-hystrix"/> for examples).</simpara>
<simpara>Here are some examples of using <literal>rx.Single</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RequestMapping(method = RequestMethod.GET, value = "/single")
public Single&lt;String&gt; single() {
	return Single.just("single value");
}

@RequestMapping(method = RequestMethod.GET, value = "/singleWithResponse")
public ResponseEntity&lt;Single&lt;String&gt;&gt; singleWithResponse() {
	return new ResponseEntity&lt;&gt;(Single.just("single value"),
			HttpStatus.NOT_FOUND);
}

@RequestMapping(method = RequestMethod.GET, value = "/singleCreatedWithResponse")
public Single&lt;ResponseEntity&lt;String&gt;&gt; singleOuterWithResponse() {
	return Single.just(new ResponseEntity&lt;&gt;("single value", HttpStatus.CREATED));
}

@RequestMapping(method = RequestMethod.GET, value = "/throw")
public Single&lt;Object&gt; error() {
	return Single.error(new RuntimeException("Unexpected"));
}</programlisting>
<simpara>If you have an <literal>Observable</literal>, rather than a single, you can use <literal>.toSingle()</literal> or <literal>.toList().toSingle()</literal>. Here are some examples:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RequestMapping(method = RequestMethod.GET, value = "/single")
public Single&lt;String&gt; single() {
	return Observable.just("single value").toSingle();
}

@RequestMapping(method = RequestMethod.GET, value = "/multiple")
public Single&lt;List&lt;String&gt;&gt; multiple() {
	return Observable.just("multiple", "values").toList().toSingle();
}

@RequestMapping(method = RequestMethod.GET, value = "/responseWithObservable")
public ResponseEntity&lt;Single&lt;String&gt;&gt; responseWithObservable() {

	Observable&lt;String&gt; observable = Observable.just("single value");
	HttpHeaders headers = new HttpHeaders();
	headers.setContentType(APPLICATION_JSON_UTF8);
	return new ResponseEntity&lt;&gt;(observable.toSingle(), headers, HttpStatus.CREATED);
}

@RequestMapping(method = RequestMethod.GET, value = "/timeout")
public Observable&lt;String&gt; timeout() {
	return Observable.timer(1, TimeUnit.MINUTES).map(new Func1&lt;Long, String&gt;() {
		@Override
		public String call(Long aLong) {
			return "single value";
		}
	});
}</programlisting>
<simpara>If you have a streaming endpoint and client, SSE could be an option. To convert <literal>rx.Observable</literal> to a Spring <literal>SseEmitter</literal> use <literal>RxResponse.sse()</literal>. Here are some examples:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RequestMapping(method = RequestMethod.GET, value = "/sse")
public SseEmitter single() {
	return RxResponse.sse(Observable.just("single value"));
}

@RequestMapping(method = RequestMethod.GET, value = "/messages")
public SseEmitter messages() {
	return RxResponse.sse(Observable.just("message 1", "message 2", "message 3"));
}

@RequestMapping(method = RequestMethod.GET, value = "/events")
public SseEmitter event() {
	return RxResponse.sse(APPLICATION_JSON_UTF8,
			Observable.just(new EventDto("Spring io", getDate(2016, 5, 19)),
					new EventDto("SpringOnePlatform", getDate(2016, 8, 1))));
}</programlisting>
</chapter>
<chapter xml:id="netflix-metrics">
<title>Metrics: Spectator, Servo, and Atlas</title>
<simpara>When used together, Spectator/Servo and Atlas provide a near real-time operational insight platform.</simpara>
<simpara>Spectator and Servo are Netflix&#8217;s metrics collection libraries. Atlas is a Netflix metrics backend to manage dimensional time series data.</simpara>
<simpara>Servo served Netflix for several years and is still usable, but is gradually being phased out in favor of Spectator, which is only designed to work with Java 8.  Spring Cloud Netflix provides support for both, but Java 8 based applications are encouraged to use Spectator.</simpara>
<section xml:id="_dimensional_vs_hierarchical_metrics">
<title>Dimensional vs. Hierarchical Metrics</title>
<simpara>Spring Boot Actuator metrics are hierarchical and metrics are separated only by name. These names often follow a naming convention that embeds key/value attribute pairs (dimensions) into the name separated by periods. Consider the following metrics for two endpoints, root and star-star:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
    "counter.status.200.root": 20,
    "counter.status.400.root": 3,
    "counter.status.200.star-star": 5,
}</programlisting>
<simpara>The first metric gives us a normalized count of successful requests against the root endpoint per unit of time. But what if the system had 20 endpoints and you want to get a count of successful requests against all the endpoints? Some hierarchical metrics backends would allow you to specify a wild card such as <literal>counter.status.200.*</literal> that would read all 20 metrics and aggregate the results. Alternatively, you could provide a <literal>HandlerInterceptorAdapter</literal> that intercepts and records a metric like <literal>counter.status.200.all</literal> for all successful requests irrespective of the endpoint, but now you must write 20+1 different metrics. Similarly if you want to know the total number of successful requests for all endpoints in the service, you could specify a wild card such as <literal>counter.status.2*.*</literal>.</simpara>
<simpara>Even in the presence of wildcarding support on a hierarchical metrics backend, naming consistency can be difficult. Specifically the position of these tags in the name string can slip with time, breaking queries. For example, suppose we add an additional dimension to the hierarchical metrics above for HTTP method. Then <literal>counter.status.200.root</literal> becomes <literal>counter.status.200.method.get.root</literal>, etc. Our <literal>counter.status.200.*</literal> suddenly no longer has the same semantic meaning.  Furthermore, if the new dimension is not applied uniformly across the codebase, certain queries may become impossible. This can quickly get out of hand.</simpara>
<simpara>Netflix metrics are tagged (a.k.a. dimensional). Each metric has a name, but this single named metric can contain multiple statistics and 'tag' key/value pairs that allows more querying flexibility. In fact, the statistics themselves are recorded in a special tag.</simpara>
<simpara>Recorded with Netflix Servo or Spectator, a timer for the root endpoint described above contains 4 statistics per status code, where the count statistic is identical to Spring Boot Actuator&#8217;s counter. In the event that we have encountered an HTTP 200 and 400 thus far, there will be 8 available data points:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
    "root(status=200,stastic=count)": 20,
    "root(status=200,stastic=max)": 0.7265630630000001,
    "root(status=200,stastic=totalOfSquares)": 0.04759702862580789,
    "root(status=200,stastic=totalTime)": 0.2093076914666667,
    "root(status=400,stastic=count)": 1,
    "root(status=400,stastic=max)": 0,
    "root(status=400,stastic=totalOfSquares)": 0,
    "root(status=400,stastic=totalTime)": 0,
}</programlisting>
</section>
<section xml:id="_default_metrics_collection">
<title>Default Metrics Collection</title>
<simpara>Without any additional dependencies or configuration, a Spring Cloud based service will autoconfigure a Servo <literal>MonitorRegistry</literal> and begin collecting metrics on every Spring MVC request. By default, a Servo timer with the name <literal>rest</literal> will be recorded for each MVC request which is tagged with:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>HTTP method</simpara>
</listitem>
<listitem>
<simpara>HTTP status (e.g. 200, 400, 500)</simpara>
</listitem>
<listitem>
<simpara>URI (or "root" if the URI is empty), sanitized for Atlas</simpara>
</listitem>
<listitem>
<simpara>The exception class name, if the request handler threw an exception</simpara>
</listitem>
<listitem>
<simpara>The caller, if a request header with a key matching <literal>netflix.metrics.rest.callerHeader</literal> is set on the request. There is no default key for <literal>netflix.metrics.rest.callerHeader</literal>. You must add it to your application properties if you wish to collect caller information.</simpara>
</listitem>
</orderedlist>
<simpara>Set the <literal>netflix.metrics.rest.metricName</literal> property to change the name of the metric from <literal>rest</literal> to a name you provide.</simpara>
<simpara>If Spring AOP is enabled and <literal>org.aspectj:aspectjweaver</literal> is present on your runtime classpath, Spring Cloud will also collect metrics on every client call made with <literal>RestTemplate</literal>. A Servo timer with the name of <literal>restclient</literal> will be recorded for each MVC request which is tagged with:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>HTTP method</simpara>
</listitem>
<listitem>
<simpara>HTTP status (e.g. 200, 400, 500), "CLIENT_ERROR" if the response returned null, or "IO_ERROR" if an <literal>IOException</literal> occurred during the execution of the <literal>RestTemplate</literal> method</simpara>
</listitem>
<listitem>
<simpara>URI, sanitized for Atlas</simpara>
</listitem>
<listitem>
<simpara>Client name</simpara>
</listitem>
</orderedlist>
<warning>
<simpara>Avoid using hardcoded url parameters within <literal>RestTemplate</literal>.  When targeting dynamic endpoints use URL variables. This will avoid potential "GC Overhead Limit Reached" issues where <literal>ServoMonitorCache</literal> treats each url as a unique key.</simpara>
</warning>
<programlisting language="java" linenumbering="unnumbered">// recommended
String orderid = "1";
restTemplate.getForObject("http://testeurekabrixtonclient/orders/{orderid}", String.class, orderid)

// avoid
restTemplate.getForObject("http://testeurekabrixtonclient/orders/1", String.class)</programlisting>
</section>
<section xml:id="netflix-metrics-spectator">
<title>Metrics Collection: Spectator</title>
<simpara>To enable Spectator metrics, include a dependency on <literal>spring-boot-starter-spectator</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-spectator&lt;/artifactId&gt;
    &lt;/dependency&gt;</programlisting>
<simpara>In Spectator parlance, a meter is a named, typed, and tagged configuration and a metric represents the value of a given meter at a point in time. Spectator meters are created and controlled by a registry, which currently has several different implementations. Spectator provides 4 meter types: counter, timer, gauge, and distribution summary.</simpara>
<simpara>Spring Cloud Spectator integration configures an injectable <literal>com.netflix.spectator.api.Registry</literal> instance for you. Specifically, it configures a <literal>ServoRegistry</literal> instance in order to unify the collection of REST metrics and the exporting of metrics to the Atlas backend under a single Servo API. Practically, this means that your code may use a mixture of Servo monitors and Spectator meters and both will be scooped up by Spring Boot Actuator <literal>MetricReader</literal> instances and both will be shipped to the Atlas backend.</simpara>
<section xml:id="_spectator_counter">
<title>Spectator Counter</title>
<simpara>A counter is used to measure the rate at which some event is occurring.</simpara>
<programlisting language="java" linenumbering="unnumbered">// create a counter with a name and a set of tags
Counter counter = registry.counter("counterName", "tagKey1", "tagValue1", ...);
counter.increment(); // increment when an event occurs
counter.increment(10); // increment by a discrete amount</programlisting>
<simpara>The counter records a single time-normalized statistic.</simpara>
</section>
<section xml:id="_spectator_timer">
<title>Spectator Timer</title>
<simpara>A timer is used to measure how long some event is taking. Spring Cloud automatically records timers for Spring MVC requests and conditionally <literal>RestTemplate</literal> requests, which can later be used to create dashboards for request related metrics like latency:</simpara>
<figure>
<title>Request Latency</title>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/1.4.x/docs/src/main/asciidoc/images/RequestLatency.png"/>
</imageobject>
<textobject><phrase>RequestLatency</phrase></textobject>
</mediaobject>
</figure>
<programlisting language="java" linenumbering="unnumbered">// create a timer with a name and a set of tags
Timer timer = registry.timer("timerName", "tagKey1", "tagValue1", ...);

// execute an operation and time it at the same time
T result = timer.record(() -&gt; fooReturnsT());

// alternatively, if you must manually record the time
Long start = System.nanoTime();
T result = fooReturnsT();
timer.record(System.nanoTime() - start, TimeUnit.NANOSECONDS);</programlisting>
<simpara>The timer simultaneously records 4 statistics: count, max, totalOfSquares, and totalTime.  The count statistic will always match the single normalized value provided by a counter if you had called <literal>increment()</literal> once on the counter for each time you recorded a timing, so it is rarely necessary to count and time separately for a single operation.</simpara>
<simpara>For <link xl:href="https://github.com/Netflix/spectator/wiki/Timer-Usage#longtasktimer">long running operations</link>, Spectator provides a special <literal>LongTaskTimer</literal>.</simpara>
</section>
<section xml:id="_spectator_gauge">
<title>Spectator Gauge</title>
<simpara>Gauges are used to determine some current value like the size of a queue or number of threads in a running state. Since gauges are sampled, they provide no information about how these values fluctuate between samples.</simpara>
<simpara>The normal use of a gauge involves registering the gauge once in initialization with an id, a reference to the object to be sampled, and a function to get or compute a numeric value based on the object. The reference to the object is passed in separately and the Spectator registry will keep a weak reference to the object. If the object is garbage collected, then Spectator will automatically drop the registration. See <link xl:href="https://github.com/Netflix/spectator/wiki/Gauge-Usage#using-lambda">the note</link> in Spectator&#8217;s documentation about potential memory leaks if this API is misused.</simpara>
<programlisting language="java" linenumbering="unnumbered">// the registry will automatically sample this gauge periodically
registry.gauge("gaugeName", pool, Pool::numberOfRunningThreads);

// manually sample a value in code at periodic intervals -- last resort!
registry.gauge("gaugeName", Arrays.asList("tagKey1", "tagValue1", ...), 1000);</programlisting>
</section>
<section xml:id="_spectator_distribution_summaries">
<title>Spectator Distribution Summaries</title>
<simpara>A distribution summary is used to track the distribution of events. It is similar to a timer, but more general in that the size does not have to be a period of time. For example, a distribution summary could be used to measure the payload sizes of requests hitting a server.</simpara>
<programlisting language="java" linenumbering="unnumbered">// the registry will automatically sample this gauge periodically
DistributionSummary ds = registry.distributionSummary("dsName", "tagKey1", "tagValue1", ...);
ds.record(request.sizeInBytes());</programlisting>
</section>
</section>
<section xml:id="netflix-metrics-servo">
<title>Metrics Collection: Servo</title>
<warning>
<simpara>If your code is compiled on Java 8, please use Spectator instead of Servo as Spectator is destined to replace Servo entirely in the long term.</simpara>
</warning>
<simpara>In Servo parlance, a monitor is a named, typed, and tagged configuration and a metric represents the value of a given monitor at a point in time. Servo monitors are logically equivalent to Spectator meters. Servo monitors are created and controlled by a <literal>MonitorRegistry</literal>. In spite of the above warning, Servo does have a <link xl:href="https://github.com/Netflix/servo/wiki/Getting-Started">wider array</link> of monitor options than Spectator has meters.</simpara>
<simpara>Spring Cloud integration configures an injectable <literal>com.netflix.servo.MonitorRegistry</literal> instance for you. Once you have created the appropriate <literal>Monitor</literal> type in Servo, the process of recording data is wholly similar to Spectator.</simpara>
<section xml:id="_creating_servo_monitors">
<title>Creating Servo Monitors</title>
<simpara>If you are using the Servo <literal>MonitorRegistry</literal> instance provided by Spring Cloud (specifically, an instance of <literal>DefaultMonitorRegistry</literal>), Servo provides convenience classes for retrieving <link xl:href="https://github.com/Netflix/spectator/wiki/Servo-Comparison#dynamiccounter">counters</link> and <link xl:href="https://github.com/Netflix/spectator/wiki/Servo-Comparison#dynamictimer">timers</link>.  These convenience classes ensure that only one <literal>Monitor</literal> is registered for each unique combination of name and tags.</simpara>
<simpara>To manually create a Monitor type in Servo, especially for the more exotic monitor types for which convenience methods are not provided, instantiate the appropriate type by providing a <literal>MonitorConfig</literal> instance:</simpara>
<programlisting language="java" linenumbering="unnumbered">MonitorConfig config = MonitorConfig.builder("timerName").withTag("tagKey1", "tagValue1").build();

// somewhere we should cache this Monitor by MonitorConfig
Timer timer = new BasicTimer(config);
monitorRegistry.register(timer);</programlisting>
</section>
</section>
<section xml:id="netflix-metrics-atlas">
<title>Metrics Backend: Atlas</title>
<simpara>Atlas was developed by Netflix to manage dimensional time series data for near real-time operational insight. Atlas features in-memory data storage, allowing it to gather and report very large numbers of metrics, very quickly.</simpara>
<simpara>Atlas captures operational intelligence. Whereas business intelligence is data gathered for analyzing trends over time, operational intelligence provides a picture of what is currently happening within a system.</simpara>
<simpara>Spring Cloud provides a <literal>spring-cloud-starter-netflix-atlas</literal> that has all the dependencies you need. Then just annotate your Spring Boot application with <literal>@EnableAtlas</literal> and provide a location for your running Atlas server with the <literal>netflix.atlas.uri</literal> property.</simpara>
<section xml:id="_global_tags">
<title>Global tags</title>
<simpara>Spring Cloud enables you to add tags to every metric sent to the Atlas backend. Global tags can be used to separate metrics by application name, environment, region, etc.</simpara>
<simpara>Each bean implementing <literal>AtlasTagProvider</literal> will contribute to the global tag list:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bean
AtlasTagProvider atlasCommonTags(
    @Value("${spring.application.name}") String appName) {
  return () -&gt; Collections.singletonMap("app", appName);
}</programlisting>
</section>
<section xml:id="_using_atlas">
<title>Using Atlas</title>
<simpara>To bootstrap a in-memory standalone Atlas instance:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ curl -LO https://github.com/Netflix/atlas/releases/download/v1.4.2/atlas-1.4.2-standalone.jar
$ java -jar atlas-1.4.2-standalone.jar</programlisting>
<tip>
<simpara>An Atlas standalone node running on an r3.2xlarge (61GB RAM) can handle roughly 2 million metrics per minute for a given 6 hour window.</simpara>
</tip>
<simpara>Once running and you have collected a handful of metrics, verify that your setup is correct by listing tags on the Atlas server:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ curl http://ATLAS/api/v1/tags</programlisting>
<tip>
<simpara>After executing several requests against your service, you can gather some very basic information on the request latency of every request by pasting the following url in your browser: <literal><link xl:href="http://ATLAS/api/v1/graph?q=name,rest,:eq,:avg">http://ATLAS/api/v1/graph?q=name,rest,:eq,:avg</link></literal></simpara>
</tip>
<simpara>The Atlas wiki contains a <link xl:href="https://github.com/Netflix/atlas/wiki/Single-Line">compilation of sample queries</link> for various scenarios.</simpara>
<simpara>Make sure to check out the <link xl:href="https://github.com/Netflix/atlas/wiki/Alerting-Philosophy">alerting philosophy</link> and docs on using <link xl:href="https://github.com/Netflix/atlas/wiki/DES">double exponential smoothing</link> to generate dynamic alert thresholds.</simpara>
</section>
</section>
<section xml:id="retrying-failed-requests">
<title>Retrying Failed Requests</title>
<simpara>Spring Cloud Netflix offers a variety of ways to make HTTP requests.  You can use a load balanced
<literal>RestTemplate</literal>, Ribbon, or Feign.  No matter how you choose to your HTTP requests, there is always
a chance the request may fail.  When a request fails you may want to have the request retried
automatically.  To accomplish this when using Sping Cloud Netflix you need to include
<link xl:href="https://github.com/spring-projects/spring-retry">Spring Retry</link> on your application&#8217;s classpath.
When Spring Retry is present load balanced <literal>RestTemplates</literal>, Feign, and Zuul will automatically
retry any failed requests (assuming you configuration allows it to).</simpara>
<section xml:id="_backoff_policies">
<title>BackOff Policies</title>
<simpara>By default no backoff policy is used when retrying requests.  If you would like to configure
a backoff policy you will need to create a bean of type <literal>LoadBalancedBackOffPolicyFactory</literal>
which will be used to create a <literal>BackOffPolicy</literal> for a given service.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
public class MyConfiguration {
    @Bean
    LoadBalancedBackOffPolicyFactory backOffPolciyFactory() {
        return new LoadBalancedBackOffPolicyFactory() {
            @Override
            public BackOffPolicy createBackOffPolicy(String service) {
                return new ExponentialBackOffPolicy();
            }
        };
    }
}</programlisting>
</section>
<section xml:id="_configuration">
<title>Configuration</title>
<simpara>Anytime Ribbon is used with Spring Retry you can control the retry functionality by configuring
certain Ribbon properties.  The properties you can use are
<literal>client.ribbon.MaxAutoRetries</literal>, <literal>client.ribbon.MaxAutoRetriesNextServer</literal>, and
<literal>client.ribbon.OkToRetryOnAllOperations</literal>. See the <link xl:href="https://github.com/Netflix/ribbon/wiki/Getting-Started#the-properties-file-sample-clientproperties">Ribbon documentation</link>
for a description of what there properties do.</simpara>
<warning>
<simpara>Enabling <literal>client.ribbon.OkToRetryOnAllOperations</literal> includes retring POST requests wich can have a impact
on the server&#8217;s resources due to the buffering of the request&#8217;s body.</simpara>
</warning>
<simpara>In addition you may want to retry requests when certain status codes are returned in the
response.  You can list the response codes you would like the Ribbon client to retry using the
 property <literal>clientName.ribbon.retryableStatusCodes</literal>.  For example</simpara>
<programlisting language="yaml" linenumbering="unnumbered">clientName:
  ribbon:
    retryableStatusCodes: 404,502</programlisting>
<simpara>You can also create a bean of type <literal>LoadBalancedRetryPolicy</literal> and implement the <literal>retryableStatusCode</literal>
method to determine whether you want to retry a request given the status code.</simpara>
</section>
<section xml:id="_zuul">
<title>Zuul</title>
<simpara>You can turn off Zuul&#8217;s retry functionality by setting <literal>zuul.retryable</literal> to <literal>false</literal>.  You
can also disable retry functionality on route by route basis by setting
<literal>zuul.routes.routename.retryable</literal> to <literal>false</literal>.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="_http_clients">
<title>HTTP Clients</title>
<simpara>Spring Cloud Netflix will automatically create the HTTP client used by Ribbon, Feign, and
Zuul for you.  However you can also provide your own HTTP clients customized how you please
yourself.  To do this you can either create a bean of type <literal>ClosableHttpClient</literal> if you
are using the Apache Http Cient, or <literal>OkHttpClient</literal> if you are using OK HTTP.</simpara>
<note>
<simpara>When you create your own HTTP client you are also responsible for implementing
the correct connection management strategies for these clients.  Doing this improperly
can result in resource management issues.</simpara>
</note>
</chapter>
</part>
<part xml:id="_spring_cloud_stream">
<title>Spring Cloud Stream</title>
<partintro>
<simpara>This section goes into more detail about how you can work with Spring Cloud Stream.
It covers topics such as creating and running stream applications.</simpara>
</partintro>
<chapter xml:id="_introducing_spring_cloud_stream">
<title>Introducing Spring Cloud Stream</title>
<simpara>Spring Cloud Stream is a framework for building message-driven microservice applications.
Spring Cloud Stream builds upon Spring Boot to create standalone, production-grade Spring applications, and uses Spring Integration to provide connectivity to message brokers.
It provides opinionated configuration of middleware from several vendors, introducing the concepts of persistent publish-subscribe semantics, consumer groups, and partitions.</simpara>
<simpara>You can add the <literal>@EnableBinding</literal> annotation to your application to get immediate connectivity to a message broker, and you can add <literal>@StreamListener</literal> to a method to cause it to receive events for stream processing.
The following is a simple sink application which receives external messages.</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableBinding(Sink.class)
public class VoteRecordingSinkApplication {

  public static void main(String[] args) {
    SpringApplication.run(VoteRecordingSinkApplication.class, args);
  }

  @StreamListener(Sink.INPUT)
  public void processVote(Vote vote) {
      votingService.recordVote(vote);
  }
}</programlisting>
<simpara>The <literal>@EnableBinding</literal> annotation takes one or more interfaces as parameters (in this case, the parameter is a single <literal>Sink</literal> interface).
An interface declares input and/or output channels.
Spring Cloud Stream provides the interfaces <literal>Source</literal>, <literal>Sink</literal>, and <literal>Processor</literal>; you can also define your own interfaces.</simpara>
<simpara>The following is the definition of the <literal>Sink</literal> interface:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Sink {
  String INPUT = "input";

  @Input(Sink.INPUT)
  SubscribableChannel input();
}</programlisting>
<simpara>The <literal>@Input</literal> annotation identifies an <emphasis>input channel</emphasis>, through which received messages enter the application; the <literal>@Output</literal> annotation identifies an <emphasis>output channel</emphasis>, through which published messages leave the application.
The <literal>@Input</literal> and <literal>@Output</literal> annotations can take a channel name as a parameter; if a name is not provided, the name of the annotated method will be used.</simpara>
<simpara>Spring Cloud Stream will create an implementation of the interface for you.
You can use this in the application by autowiring it, as in the following example of a test case.</simpara>
<programlisting language="java" linenumbering="unnumbered">@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = VoteRecordingSinkApplication.class)
@WebAppConfiguration
@DirtiesContext
public class StreamApplicationTests {

  @Autowired
  private Sink sink;

  @Test
  public void contextLoads() {
    assertNotNull(this.sink.input());
  }
}</programlisting>
</chapter>
<chapter xml:id="_main_concepts">
<title>Main Concepts</title>
<simpara>Spring Cloud Stream provides a number of abstractions and primitives that simplify the writing of message-driven microservice applications.
This section gives an overview of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Spring Cloud Stream&#8217;s application model</simpara>
</listitem>
<listitem>
<simpara>The Binder abstraction</simpara>
</listitem>
<listitem>
<simpara>Persistent publish-subscribe support</simpara>
</listitem>
<listitem>
<simpara>Consumer group support</simpara>
</listitem>
<listitem>
<simpara>Partitioning support</simpara>
</listitem>
<listitem>
<simpara>A pluggable Binder API</simpara>
</listitem>
</itemizedlist>
<section xml:id="_application_model">
<title>Application Model</title>
<simpara>A Spring Cloud Stream application consists of a middleware-neutral core.
The application communicates with the outside world through input and output <emphasis>channels</emphasis> injected into it by Spring Cloud Stream.
Channels are connected to external brokers through middleware-specific Binder implementations.</simpara>
<figure>
<title>Spring Cloud Stream Application</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/SCSt-with-binder.png" contentwidth="300" width="50%" scalefit="1"/>
</imageobject>
<textobject><phrase>SCSt with binder</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_fat_jar">
<title>Fat JAR</title>
<simpara>Spring Cloud Stream applications can be run in standalone mode from your IDE for testing.
To run a Spring Cloud Stream application in production, you can create an executable (or "fat") JAR by using the standard Spring Boot tooling provided for Maven or Gradle.</simpara>
</section>
</section>
<section xml:id="_the_binder_abstraction">
<title>The Binder Abstraction</title>
<simpara>Spring Cloud Stream provides Binder implementations for <link xl:href="https://github.com/spring-cloud/spring-cloud-stream/tree/master/spring-cloud-stream-binders/spring-cloud-stream-binder-kafka">Kafka</link> and <link xl:href="https://github.com/spring-cloud/spring-cloud-stream/tree/master/spring-cloud-stream-binders/spring-cloud-stream-binder-rabbit">Rabbit MQ</link>.
Spring Cloud Stream also includes a <link xl:href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-test-support/src/main/java/org/springframework/cloud/stream/test/binder/TestSupportBinder.java">TestSupportBinder</link>, which leaves a channel unmodified so that tests can interact with channels directly and reliably assert on what is received.
You can use the extensible API to write your own Binder.</simpara>
<simpara>Spring Cloud Stream uses Spring Boot for configuration, and the Binder abstraction makes it possible for a Spring Cloud Stream application to be flexible in how it connects to middleware.
For example, deployers can dynamically choose, at runtime, the destinations (e.g., the Kafka topics or RabbitMQ exchanges) to which channels connect.
Such configuration can be provided through external configuration properties and in any form supported by Spring Boot (including application arguments, environment variables, and <literal>application.yml</literal> or <literal>application.properties</literal> files).
In the sink example from the <xref linkend="_introducing_spring_cloud_stream"/> section, setting the application property <literal>spring.cloud.stream.bindings.input.destination</literal> to <literal>raw-sensor-data</literal> will cause it to read from the <literal>raw-sensor-data</literal> Kafka topic, or from a queue bound to the <literal>raw-sensor-data</literal> RabbitMQ exchange.</simpara>
<simpara>Spring Cloud Stream automatically detects and uses a binder found on the classpath.
You can easily use different types of middleware with the same code: just include a different binder at build time.
For more complex use cases, you can also package multiple binders with your application and have it choose the binder, and even whether to use different binders for different channels, at runtime.</simpara>
</section>
<section xml:id="_persistent_publish_subscribe_support">
<title>Persistent Publish-Subscribe Support</title>
<simpara>Communication between applications follows a publish-subscribe model, where data is broadcast through shared topics.
This can be seen in the following figure, which shows a typical deployment for a set of interacting Spring Cloud Stream applications.</simpara>
<figure>
<title>Spring Cloud Stream Publish-Subscribe</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/SCSt-sensors.png" contentwidth="300" width="50%" scalefit="1"/>
</imageobject>
<textobject><phrase>SCSt sensors</phrase></textobject>
</mediaobject>
</figure>
<simpara>Data reported by sensors to an HTTP endpoint is sent to a common destination named <literal>raw-sensor-data</literal>.
From the destination, it is independently processed by a microservice application that computes time-windowed averages and by another microservice application that ingests the raw data into HDFS.
In order to process the data, both applications declare the topic as their input at runtime.</simpara>
<simpara>The publish-subscribe communication model reduces the complexity of both the producer and the consumer, and allows new applications to be added to the topology without disruption of the existing flow.
For example, downstream from the average-calculating application, you can add an application that calculates the highest temperature values for display and monitoring.
You can then add another application that interprets the same flow of averages for fault detection.
Doing all communication through shared topics rather than point-to-point queues reduces coupling between microservices.</simpara>
<simpara>While the concept of publish-subscribe messaging is not new, Spring Cloud Stream takes the extra step of making it an opinionated choice for its application model.
By using native middleware support, Spring Cloud Stream also simplifies use of the publish-subscribe model across different platforms.</simpara>
</section>
<section xml:id="consumer-groups">
<title>Consumer Groups</title>
<simpara>While the publish-subscribe model makes it easy to connect applications through shared topics, the ability to scale up by creating multiple instances of a given application is equally important.
When doing this, different instances of an application are placed in a competing consumer relationship, where only one of the instances is expected to handle a given message.</simpara>
<simpara>Spring Cloud Stream models this behavior through the concept of a <emphasis>consumer group</emphasis>.
(Spring Cloud Stream consumer groups are similar to and inspired by Kafka consumer groups.)
Each consumer binding can use the <literal>spring.cloud.stream.bindings.&lt;channelName&gt;.group</literal> property to specify a group name.
For the consumers shown in the following figure, this property would be set as <literal>spring.cloud.stream.bindings.&lt;channelName&gt;.group=hdfsWrite</literal> or <literal>spring.cloud.stream.bindings.&lt;channelName&gt;.group=average</literal>.</simpara>
<figure>
<title>Spring Cloud Stream Consumer Groups</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/SCSt-groups.png" contentwidth="300" width="50%" scalefit="1"/>
</imageobject>
<textobject><phrase>SCSt groups</phrase></textobject>
</mediaobject>
</figure>
<simpara>All groups which subscribe to a given destination receive a copy of published data, but only one member of each group receives a given message from that destination.
By default, when a group is not specified, Spring Cloud Stream assigns the application to an anonymous and independent single-member consumer group that is in a publish-subscribe relationship with all other consumer groups.</simpara>
<section xml:id="durability">
<title>Durability</title>
<simpara>Consistent with the opinionated application model of Spring Cloud Stream, consumer group subscriptions are <emphasis>durable</emphasis>.
That is, a binder implementation ensures that group subscriptions are persistent, and once at least one subscription for a group has been created, the group will receive messages, even if they are sent while all applications in the group are stopped.</simpara>
<note>
<simpara>Anonymous subscriptions are non-durable by nature.
For some binder implementations (e.g., RabbitMQ), it is possible to have non-durable group subscriptions.</simpara>
</note>
<simpara>In general, it is preferable to always specify a consumer group when binding an application to a given destination.
When scaling up a Spring Cloud Stream application, you must specify a consumer group for each of its input bindings.
This prevents the application&#8217;s instances from receiving duplicate messages (unless that behavior is desired, which is unusual).</simpara>
</section>
</section>
<section xml:id="partitioning">
<title>Partitioning Support</title>
<simpara>Spring Cloud Stream provides support for <emphasis>partitioning</emphasis> data between multiple instances of a given application.
In a partitioned scenario, the physical communication medium (e.g., the broker topic) is viewed as being structured into multiple partitions.
One or more producer application instances send data to multiple consumer application instances and ensure that data identified by common characteristics are processed by the same consumer instance.</simpara>
<simpara>Spring Cloud Stream provides a common abstraction for implementing partitioned processing use cases in a uniform fashion.
Partitioning can thus be used whether the broker itself is naturally partitioned (e.g., Kafka) or not (e.g., RabbitMQ).</simpara>
<figure>
<title>Spring Cloud Stream Partitioning</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/SCSt-partitioning.png" contentwidth="300" width="50%" scalefit="1"/>
</imageobject>
<textobject><phrase>SCSt partitioning</phrase></textobject>
</mediaobject>
</figure>
<simpara>Partitioning is a critical concept in stateful processing, where it is critiical, for either performance or consistency reasons, to ensure that all related data is processed together.
For example, in the time-windowed average calculation example, it is important that all measurements from any given sensor are processed by the same application instance.</simpara>
<note>
<simpara>To set up a partitioned processing scenario, you must configure both the data-producing and the data-consuming ends.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="_programming_model">
<title>Programming Model</title>
<simpara>This section describes Spring Cloud Stream&#8217;s programming model.
Spring Cloud Stream provides a number of predefined annotations for declaring bound input and output channels as well as how to listen to channels.</simpara>
<section xml:id="_declaring_and_binding_channels">
<title>Declaring and Binding Channels</title>
<section xml:id="_triggering_binding_via_literal_enablebinding_literal">
<title>Triggering Binding Via <literal>@EnableBinding</literal></title>
<simpara>You can turn a Spring application into a Spring Cloud Stream application by applying the <literal>@EnableBinding</literal> annotation to one of the application&#8217;s configuration classes.
The <literal>@EnableBinding</literal> annotation itself is meta-annotated with <literal>@Configuration</literal> and triggers the configuration of Spring Cloud Stream infrastructure:</simpara>
<programlisting language="java" linenumbering="unnumbered">...
@Import(...)
@Configuration
@EnableIntegration
public @interface EnableBinding {
    ...
    Class&lt;?&gt;[] value() default {};
}</programlisting>
<simpara>The <literal>@EnableBinding</literal> annotation can take as parameters one or more interface classes that contain methods which represent bindable components (typically message channels).</simpara>
<note>
<simpara>The <literal>@EnableBinding</literal> annotation is only required on your <literal>Configuration</literal> classes, you can provide as many binding interfaces as you need, for instance: <literal>@EnableBinding(value={Orders.class, Payment.class}</literal>.
Where both <literal>Order</literal> and <literal>Payment</literal> interfaces would declare <literal>@Input</literal> and <literal>@Output</literal> channels.</simpara>
</note>
</section>
<section xml:id="__literal_input_literal_and_literal_output_literal">
<title><literal>@Input</literal> and <literal>@Output</literal></title>
<simpara>A Spring Cloud Stream application can have an arbitrary number of input and output channels defined in an interface as <literal>@Input</literal> and <literal>@Output</literal> methods:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Barista {

    @Input
    SubscribableChannel orders();

    @Output
    MessageChannel hotDrinks();

    @Output
    MessageChannel coldDrinks();
}</programlisting>
<simpara>Using this interface as a parameter to <literal>@EnableBinding</literal> will trigger the creation of three bound channels named <literal>orders</literal>, <literal>hotDrinks</literal>, and <literal>coldDrinks</literal>, respectively.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Barista.class)
public class CafeConfiguration {

   ...
}</programlisting>
<note>
<simpara>In Spring Cloud Stream, the bindable <literal>MessageChannel</literal> components are the Spring Messaging <literal>MessageChannel</literal> (for outbound) and its extension <literal>SubscribableChannel</literal> (for inbound).
Using the same mechanism other bindable components can be supported.
<literal>KStream</literal> support in Spring Cloud Stream Kafka binder is one such example where KStream is used as inbound/outbound <literal>bindable</literal> components.
In this documentation, we will continue to refer to MessageChannels as the <literal>bindable</literal> components.</simpara>
</note>
<section xml:id="_customizing_channel_names">
<title>Customizing Channel Names</title>
<simpara>Using the <literal>@Input</literal> and <literal>@Output</literal> annotations, you can specify a customized channel name for the channel, as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Barista {
    ...
    @Input("inboundOrders")
    SubscribableChannel orders();
}</programlisting>
<simpara>In this example, the created bound channel will be named <literal>inboundOrders</literal>.</simpara>
</section>
<section xml:id="__literal_source_literal_literal_sink_literal_and_literal_processor_literal">
<title><literal>Source</literal>, <literal>Sink</literal>, and <literal>Processor</literal></title>
<simpara>For easy addressing of the most common use cases, which involve either an input channel, an output channel, or both, Spring Cloud Stream provides three predefined interfaces out of the box.</simpara>
<simpara><literal>Source</literal> can be used for an application which has a single outbound channel.</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Source {

  String OUTPUT = "output";

  @Output(Source.OUTPUT)
  MessageChannel output();

}</programlisting>
<simpara><literal>Sink</literal> can be used for an application which has a single inbound channel.</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Sink {

  String INPUT = "input";

  @Input(Sink.INPUT)
  SubscribableChannel input();

}</programlisting>
<simpara><literal>Processor</literal> can be used for an application which has both an inbound channel and an outbound channel.</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Processor extends Source, Sink {
}</programlisting>
<simpara>Spring Cloud Stream provides no special handling for any of these interfaces; they are only provided out of the box.</simpara>
</section>
</section>
<section xml:id="_accessing_bound_channels">
<title>Accessing Bound Channels</title>
<section xml:id="_injecting_the_bound_interfaces">
<title>Injecting the Bound Interfaces</title>
<simpara>For each bound interface, Spring Cloud Stream will generate a bean that implements the interface.
Invoking a <literal>@Input</literal>-annotated or <literal>@Output</literal>-annotated method of one of these beans will return the relevant bound channel.</simpara>
<simpara>The bean in the following example sends a message on the output channel when its <literal>hello</literal> method is invoked.
It invokes <literal>output()</literal> on the injected <literal>Source</literal> bean to retrieve the target channel.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Component
public class SendingBean {

    private Source source;

    @Autowired
    public SendingBean(Source source) {
        this.source = source;
    }

    public void sayHello(String name) {
         source.output().send(MessageBuilder.withPayload(name).build());
    }
}</programlisting>
</section>
<section xml:id="_injecting_channels_directly">
<title>Injecting Channels Directly</title>
<simpara>Bound channels can be also injected directly:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Component
public class SendingBean {

    private MessageChannel output;

    @Autowired
    public SendingBean(MessageChannel output) {
        this.output = output;
    }

    public void sayHello(String name) {
         output.send(MessageBuilder.withPayload(name).build());
    }
}</programlisting>
<simpara>If the name of the channel is customized on the declaring annotation, that name should be used instead of the method name.
Given the following declaration:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface CustomSource {
    ...
    @Output("customOutput")
    MessageChannel output();
}</programlisting>
<simpara>The channel will be injected as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Component
public class SendingBean {

    private MessageChannel output;

    @Autowired
    public SendingBean(@Qualifier("customOutput") MessageChannel output) {
        this.output = output;
    }

    public void sayHello(String name) {
         this.output.send(MessageBuilder.withPayload(name).build());
    }
}</programlisting>
</section>
</section>
<section xml:id="_producing_and_consuming_messages">
<title>Producing and Consuming Messages</title>
<simpara>You can write a Spring Cloud Stream application using either Spring Integration annotations or Spring Cloud Stream&#8217;s <literal>@StreamListener</literal> annotation.
The <literal>@StreamListener</literal> annotation is modeled after other Spring Messaging annotations (such as <literal>@MessageMapping</literal>, <literal>@JmsListener</literal>, <literal>@RabbitListener</literal>, etc.) but adds content type management and type coercion features.</simpara>
<section xml:id="_native_spring_integration_support">
<title>Native Spring Integration Support</title>
<simpara>Because Spring Cloud Stream is based on Spring Integration, Stream completely inherits Integration&#8217;s foundation and infrastructure as well as the component itself.
For example, you can attach the  output channel of a <literal>Source</literal> to a <literal>MessageSource</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Source.class)
public class TimerSource {

  @Value("${format}")
  private String format;

  @Bean
  @InboundChannelAdapter(value = Source.OUTPUT, poller = @Poller(fixedDelay = "${fixedDelay}", maxMessagesPerPoll = "1"))
  public MessageSource&lt;String&gt; timerMessageSource() {
    return () -&gt; new GenericMessage&lt;&gt;(new SimpleDateFormat(format).format(new Date()));
  }
}</programlisting>
<simpara>Or you can use a processor&#8217;s channels in a transformer:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Processor.class)
public class TransformProcessor {
  @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
  public Object transform(String message) {
    return message.toUpperCase();
  }
}</programlisting>
<note>
<simpara>It&#8217;s important to understant that when you consume from the same binding using <literal>@StreamListener</literal> a pubsub model is used, where each method annotated with <literal>@StreamListener</literal> receives it&#8217;s own copy of the message, each one has its own consumer group.
However, if you share a bindable channel as an input for <literal>@Aggregator</literal>, <literal>@Transformer</literal> or <literal>@ServiceActivator</literal>, those will consume in a competing model, no individual consumer group is created for each subscription.</simpara>
</note>
</section>
<section xml:id="_spring_integration_error_channel_support">
<title>Spring Integration Error Channel Support</title>
<simpara>Spring Cloud Stream supports publishing error messages received by the Spring Integration global
error channel. Error messages sent to the <literal>errorChannel</literal> can be published to a specific destination
at the broker by configuring a binding for the outbound target named <literal>error</literal>. For example, to
publish error messages to a broker destination named "myErrors", provide the following property:
<literal>spring.cloud.stream.bindings.error.destination=myErrors</literal>.</simpara>
</section>
<section xml:id="binder-error-channels">
<title>Message Channel Binders and Error Channels</title>
<simpara>Starting with <emphasis>version 1.3</emphasis>, some <literal>MessageChannel</literal> - based binders publish errors to a discrete error channel for each destination.
In addition, these error channels are bridged to the global Spring Integration <literal>errorChannel</literal> mentioned above.
You can therefore consume errors for specific destinations and/or for all destinations, using a standard Spring Integration flow (<literal>IntegrationFlow</literal>, <literal>@ServiceActivator</literal>, etc).</simpara>
<simpara>On the consumer side, the listener thread catches any exceptions and forwards an <literal>ErrorMessage</literal> to the destination&#8217;s error channel.
The payload of the message is a <literal>MessagingException</literal> with the normal <literal>failedMessage</literal> and <literal>cause</literal> properties.
Usually, the raw data received from the broker is included in a header.
For binders that support (and are configured with) a dead letter destination; a <literal>MessagePublishingErrorHandler</literal> is subscribed to the channel, and the raw data is forwarded to the dead letter destination.</simpara>
<simpara>On the producer side; for binders that support some kind of async result after publishing messages (e.g. RabbitMQ, Kafka), you can enable an error channel by setting the <literal>&#8230;&#8203;producer.errorChannelEnabled</literal> to <literal>true</literal>.
The payload of the <literal>ErrorMessage</literal> depends on the binder implementation but will be a <literal>MessagingException</literal> with the normal <literal>failedMessage</literal>  property, as well as additional properties about the failure.
Refer to the binder documentation for complete details.</simpara>
</section>
<section xml:id="_using_streamlistener_for_automatic_content_type_handling">
<title>Using @StreamListener for Automatic Content Type Handling</title>
<simpara>Complementary to its Spring Integration support, Spring Cloud Stream provides its own <literal>@StreamListener</literal> annotation, modeled after other Spring Messaging annotations (e.g. <literal>@MessageMapping</literal>, <literal>@JmsListener</literal>, <literal>@RabbitListener</literal>, etc.).
The <literal>@StreamListener</literal> annotation provides a simpler model for handling inbound messages, especially when dealing with use cases that involve content type management and type coercion.</simpara>
<simpara>Spring Cloud Stream provides an extensible <literal>MessageConverter</literal> mechanism for handling data conversion by bound channels and for, in this case, dispatching to methods annotated with <literal>@StreamListener</literal>.
The following is an example of an application which processes external <literal>Vote</literal> events:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Sink.class)
public class VoteHandler {

  @Autowired
  VotingService votingService;

  @StreamListener(Sink.INPUT)
  public void handle(Vote vote) {
    votingService.record(vote);
  }
}</programlisting>
<simpara>The distinction between <literal>@StreamListener</literal> and a Spring Integration <literal>@ServiceActivator</literal> is seen when considering an inbound <literal>Message</literal> that has a <literal>String</literal> payload and a <literal>contentType</literal> header of <literal>application/json</literal>.
In the case of <literal>@StreamListener</literal>, the <literal>MessageConverter</literal> mechanism will use the <literal>contentType</literal> header to parse the <literal>String</literal> payload into a <literal>Vote</literal> object.</simpara>
<simpara>As with other Spring Messaging methods, method arguments can be annotated with <literal>@Payload</literal>, <literal>@Headers</literal> and <literal>@Header</literal>.</simpara>
<note>
<simpara>For methods which return data, you must use the <literal>@SendTo</literal> annotation to specify the output binding destination for data returned by the method:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Processor.class)
public class TransformProcessor {

  @Autowired
  VotingService votingService;

  @StreamListener(Processor.INPUT)
  @SendTo(Processor.OUTPUT)
  public VoteResult handle(Vote vote) {
    return votingService.record(vote);
  }
}</programlisting>
</note>
</section>
<section xml:id="_using_streamlistener_for_dispatching_messages_to_multiple_methods">
<title>Using @StreamListener for dispatching messages to multiple methods</title>
<simpara>Since version 1.2, Spring Cloud Stream supports dispatching messages to multiple <literal>@StreamListener</literal> methods registered on an input channel, based on a condition.</simpara>
<simpara>In order to be eligible to support conditional dispatching, a method must satisfy the follow conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>it must not return a value</simpara>
</listitem>
<listitem>
<simpara>it must be an individual message handling method (reactive API methods are not supported)</simpara>
</listitem>
</itemizedlist>
<simpara>The condition is specified via a SpEL expression in the <literal>condition</literal> attribute of the annotation and is evaluated for each message.
All the handlers that match the condition will be invoked in the same thread and no assumption must be made about the order in which the invocations take place.</simpara>
<simpara>An example of using <literal>@StreamListener</literal> with dispatching conditions can be seen below.
In this example, all the messages bearing a header <literal>type</literal> with the value <literal>foo</literal> will be dispatched to the <literal>receiveFoo</literal> method, and all the messages bearing a header <literal>type</literal> with the value <literal>bar</literal> will be dispatched to the <literal>receiveBar</literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Sink.class)
@EnableAutoConfiguration
public static class TestPojoWithAnnotatedArguments {

    @StreamListener(target = Sink.INPUT, condition = "headers['type']=='foo'")
    public void receiveFoo(@Payload FooPojo fooPojo) {
       // handle the message
    }

    @StreamListener(target = Sink.INPUT, condition = "headers['type']=='bar'")
    public void receiveBar(@Payload BarPojo barPojo) {
       // handle the message
    }
}</programlisting>
<note>
<simpara>Dispatching via <literal>@StreamListener</literal> conditions is only supported for handlers of individual messages, and not for reactive programming support (described below).</simpara>
</note>
</section>
</section>
<section xml:id="_reactive_programming_support">
<title>Reactive Programming Support</title>
<simpara>Spring Cloud Stream also supports the use of reactive APIs where incoming and outgoing data is handled as continuous data flows.
Support for reactive APIs is available via the <literal>spring-cloud-stream-reactive</literal>, which needs to be added explicitly to your project.</simpara>
<simpara>The programming model with reactive APIs is declarative, where instead of specifying how each individual message should be handled, you can use operators that describe functional transformations from inbound to outbound data flows.</simpara>
<simpara>Spring Cloud Stream supports the following reactive APIs:</simpara>
<itemizedlist>
<listitem>
<simpara>Reactor</simpara>
</listitem>
<listitem>
<simpara>RxJava 1.x</simpara>
</listitem>
</itemizedlist>
<simpara>In the future, it is intended to support a more generic model based on Reactive Streams.</simpara>
<simpara>The reactive programming model is also using the <literal>@StreamListener</literal> annotation for setting up reactive handlers. The differences are that:</simpara>
<itemizedlist>
<listitem>
<simpara>the <literal>@StreamListener</literal> annotation must not specify an input or output, as they are provided as arguments and return values from the method;</simpara>
</listitem>
<listitem>
<simpara>the arguments of the method must be annotated with <literal>@Input</literal> and <literal>@Output</literal> indicating which input or output will the incoming and respectively outgoing data flows connect to;</simpara>
</listitem>
<listitem>
<simpara>the return value of the method, if any, will be annotated with <literal>@Output</literal>, indicating the input where data shall be sent.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Reactive programming support requires Java 1.8.</simpara>
</note>
<note>
<simpara>As of Spring Cloud Stream 1.1.1 and later (starting with release train Brooklyn.SR2), reactive programming support requires the use of Reactor 3.0.4.RELEASE and higher.
Earlier Reactor versions (including 3.0.1.RELEASE, 3.0.2.RELEASE and 3.0.3.RELEASE) are not supported.
<literal>spring-cloud-stream-reactive</literal> will transitively retrieve the proper version, but it is possible for the project structure to manage the version of the <literal>io.projectreactor:reactor-core</literal> to an earlier release, especially when using Maven.
This is the case for projects generated via Spring Initializr with Spring Boot 1.x, which will override the Reactor version to <literal>2.0.8.RELEASE</literal>.
In such cases you must ensure that the proper version of the artifact is released.
This can be simply achieved by adding a direct dependency on <literal>io.projectreactor:reactor-core</literal> with a version of <literal>3.0.4.RELEASE</literal> or later to your project.</simpara>
</note>
<note>
<simpara>The use of term <literal>reactive</literal> is currently referring to the reactive APIs being used and not to the execution model being reactive (i.e. the bound endpoints are still using a 'push' rather than 'pull' model). While some backpressure support is provided by the use of Reactor, we do intend on the long run to support entirely reactive pipelines by the use of native reactive clients for the connected middleware.</simpara>
</note>
<section xml:id="_reactor_based_handlers">
<title>Reactor-based handlers</title>
<simpara>A Reactor based handler can have the following argument types:</simpara>
<itemizedlist>
<listitem>
<simpara>For arguments annotated with <literal>@Input</literal>, it supports the  Reactor type <literal>Flux</literal>.
The parameterization of the inbound Flux follows the same rules as in the case of individual message handling: it can be the entire <literal>Message</literal>, a POJO which can be the <literal>Message</literal> payload, or a POJO which is the result of a transformation based on the <literal>Message</literal> content-type header. Multiple inputs are provided;</simpara>
</listitem>
<listitem>
<simpara>For arguments annotated with <literal>Output</literal>, it supports the type <literal>FluxSender</literal> which connects a <literal>Flux</literal> produced by the method with an output. Generally speaking, specifying outputs as arguments is only recommended when the method can have multiple outputs;</simpara>
</listitem>
</itemizedlist>
<simpara>A Reactor based handler supports a return type of <literal>Flux</literal>, case in which it must be annotated with <literal>@Output</literal>. We recommend using the return value of the method when a single output flux is available.</simpara>
<simpara>Here is an example of a simple Reactor-based Processor.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  @Output(Processor.OUTPUT)
  public Flux&lt;String&gt; receive(@Input(Processor.INPUT) Flux&lt;String&gt; input) {
    return input.map(s -&gt; s.toUpperCase());
  }
}</programlisting>
<simpara>The same processor using output arguments looks like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  public void receive(@Input(Processor.INPUT) Flux&lt;String&gt; input,
     @Output(Processor.OUTPUT) FluxSender output) {
     output.send(input.map(s -&gt; s.toUpperCase()));
  }
}</programlisting>
</section>
<section xml:id="_rxjava_1_x_support">
<title>RxJava 1.x support</title>
<simpara>RxJava 1.x handlers follow the same rules as Reactor-based one, but will use <literal>Observable</literal> and <literal>ObservableSender</literal> arguments and return types.</simpara>
<simpara>So the first example above will become:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  @Output(Processor.OUTPUT)
  public Observable&lt;String&gt; receive(@Input(Processor.INPUT) Observable&lt;String&gt; input) {
    return input.map(s -&gt; s.toUpperCase());
  }
}</programlisting>
<simpara>The second example above will become:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  public void receive(@Input(Processor.INPUT) Observable&lt;String&gt; input,
     @Output(Processor.OUTPUT) ObservableSender output) {
     output.send(input.map(s -&gt; s.toUpperCase()));
  }
}</programlisting>
</section>
<section xml:id="_reactive_sources">
<title>Reactive Sources</title>
<simpara>Spring Cloud Stream reactive support also provides the ability for creating reactive sources through the StreamEmitter annotation.
Using StreamEmitter annotation, a regular source may be converted to a reactive one.
StreamEmitter is a method level annotation that marks a method to be an emitter to outputs declared via EnableBinding.
It is not allowed to use the Input annotation along with StreamEmitter, as the methods marked with this annotation are not listening from any input, rather generating to an output.
Following the same programming model used in StreamListener, StreamEmitter also allows flexible ways of using the Output annotation depending on whether the method has any arguments, return type etc.</simpara>
<simpara>Here are some examples of using StreamEmitter in various styles.</simpara>
<simpara>The following example will emit the "Hello World" message every millisecond and publish to a Flux.
In this case, the resulting messages in Flux will be sent to the output channel of the Source.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  @Output(Source.OUTPUT)
  public Flux&lt;String&gt; emit() {
    return Flux.intervalMillis(1)
            .map(l -&gt; "Hello World");
  }
}</programlisting>
<simpara>Following is another flavor of the same sample as above.
Instead of returning a Flux, this method uses a FluxSender to programmatically send Flux from a source.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  @Output(Source.OUTPUT)
  public void emit(FluxSender output) {
    output.send(Flux.intervalMillis(1)
            .map(l -&gt; "Hello World"));
  }
}</programlisting>
<simpara>Following is exactly same as the above snippet in functionality and style.
However, instead of using an explicit Output annotation at the method level, it is used as the method parameter level.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  public void emit(@Output(Source.OUTPUT) FluxSender output) {
    output.send(Flux.intervalMillis(1)
            .map(l -&gt; "Hello World"));
  }
}</programlisting>
<simpara>Here is yet another flavor of writing reacting sources using the Reactive Streams Publisher API and the support for it in the <link xl:href="https://github.com/spring-projects/spring-integration-java-dsl/wiki/Spring-Integration-Java-DSL-Reference">Spring Integration Java DSL</link>.
The Publisher is still using Reactor Flux under the hood, but from an application perspective, that is transparent to the user and only needs Reactive Streams and Java DSL for Spring Integration.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  @Output(Source.OUTPUT)
  @Bean
  public Publisher&lt;Message&lt;String&gt;&gt; emit() {
    return IntegrationFlows.from(() -&gt;
                new GenericMessage&lt;&gt;("Hello World"),
        e -&gt; e.poller(p -&gt; p.fixedDelay(1)))
        .toReactivePublisher();
  }
}</programlisting>
</section>
</section>
<section xml:id="_aggregation">
<title>Aggregation</title>
<simpara>Spring Cloud Stream provides support for aggregating multiple applications together, connecting their input and output channels directly and avoiding the additional cost of exchanging messages via a broker.
As of version 1.0 of Spring Cloud Stream, aggregation is supported only for the following types of applications:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>sources</emphasis> - applications with a single output channel named <literal>output</literal>, typically having a single binding of the type <literal>org.springframework.cloud.stream.messaging.Source</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis>sinks</emphasis> - applications with a single input channel named <literal>input</literal>, typically having a single binding of the type <literal>org.springframework.cloud.stream.messaging.Sink</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis>processors</emphasis> - applications with a single input channel named <literal>input</literal> and a single output channel named <literal>output</literal>, typically having a single binding of the type <literal>org.springframework.cloud.stream.messaging.Processor</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>They can be aggregated together by creating a sequence of interconnected applications, in which the output channel of an element in the sequence is connected to the input channel of the next element, if it exists.
A sequence can start with either a <emphasis>source</emphasis> or a <emphasis>processor</emphasis>, it can contain an arbitrary number of <emphasis>processors</emphasis> and must end with either a <emphasis>processor</emphasis> or a <emphasis>sink</emphasis>.</simpara>
<simpara>Depending on the nature of the starting and ending element, the sequence may have one or more bindable channels, as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>if the sequence starts with a source and ends with a sink, all communication between the applications is direct and no channels will be bound</simpara>
</listitem>
<listitem>
<simpara>if the sequence starts with a processor, then its input channel will become the <literal>input</literal> channel of the aggregate and will be bound accordingly</simpara>
</listitem>
<listitem>
<simpara>if the sequence ends with a processor, then its output channel will become the <literal>output</literal> channel of the aggregate and will be bound accordingly</simpara>
</listitem>
</itemizedlist>
<simpara>Aggregation is performed using the <literal>AggregateApplicationBuilder</literal> utility class, as in the following example.
Let&#8217;s consider a project in which we have source, processor and a sink, which may be defined in the project, or may be contained in one of the project&#8217;s dependencies.</simpara>
<note>
<simpara>Each component (source, sink or processor) in an aggregate application must be provided in a separate package if the configuration classes use <literal>@SpringBootApplication</literal>.
This is required to avoid cross-talk between applications, due to the classpath scanning performed by <literal>@SpringBootApplication</literal> on the configuration classes inside the same package.
In the example below, it can be seen that the Source, Processor and Sink application classes are grouped in separate packages.
A possible alternative is to provide the source, sink or processor configuration in a separate <literal>@Configuration</literal> class, avoid the use of <literal>@SpringBootApplication</literal>/<literal>@ComponentScan</literal> and use those for aggregation.</simpara>
</note>
<programlisting language="java" linenumbering="unnumbered">package com.app.mysink;

@SpringBootApplication
@EnableBinding(Sink.class)
public class SinkApplication {

	private static Logger logger = LoggerFactory.getLogger(SinkApplication.class);

	@ServiceActivator(inputChannel=Sink.INPUT)
	public void loggerSink(Object payload) {
		logger.info("Received: " + payload);
	}
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">package com.app.myprocessor;

// Imports omitted

@SpringBootApplication
@EnableBinding(Processor.class)
public class ProcessorApplication {

	@Transformer
	public String loggerSink(String payload) {
		return payload.toUpperCase();
	}
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">package com.app.mysource;

// Imports omitted

@SpringBootApplication
@EnableBinding(Source.class)
public class SourceApplication {

	@InboundChannelAdapter(value = Source.OUTPUT)
	public String timerMessageSource() {
		return new SimpleDateFormat().format(new Date());
	}
}</programlisting>
<simpara>Each configuration can be used for running a separate component, but in this case they can be aggregated together as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.app;

// Imports omitted

@SpringBootApplication
public class SampleAggregateApplication {

	public static void main(String[] args) {
		new AggregateApplicationBuilder()
			.from(SourceApplication.class).args("--fixedDelay=5000")
			.via(ProcessorApplication.class)
			.to(SinkApplication.class).args("--debug=true").run(args);
	}
}</programlisting>
<simpara>The starting component of the sequence is provided as argument to the <literal>from()</literal> method.
The ending component of the sequence is provided as argument to the <literal>to()</literal> method.
Intermediate processors are provided as argument to the <literal>via()</literal> method.
Multiple processors of the same type can be chained together (e.g. for pipelining transformations with different configurations).
For each component, the builder can provide runtime arguments for Spring Boot configuration.</simpara>
<section xml:id="_configuring_aggregate_application">
<title>Configuring aggregate application</title>
<simpara>Spring Cloud Stream supports passing properties for the individual applications inside the aggregate application using 'namespace' as prefix.</simpara>
<simpara>The namespace can be set for applications as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
public class SampleAggregateApplication {

	public static void main(String[] args) {
		new AggregateApplicationBuilder()
			.from(SourceApplication.class).namespace("source").args("--fixedDelay=5000")
			.via(ProcessorApplication.class).namespace("processor1")
			.to(SinkApplication.class).namespace("sink").args("--debug=true").run(args);
	}
}</programlisting>
<simpara>Once the 'namespace' is set for the individual applications, the application properties with the <literal>namespace</literal> as prefix can be passed to the aggregate application using any supported property source (commandline, environment properties etc.,)</simpara>
<simpara>For instance, to override the default <literal>fixedDelay</literal> and <literal>debug</literal> properties of 'source' and 'sink' applications:</simpara>
<screen>java -jar target/MyAggregateApplication-0.0.1-SNAPSHOT.jar --source.fixedDelay=10000 --sink.debug=false</screen>
</section>
<section xml:id="_configuring_binding_service_properties_for_non_self_contained_aggregate_application">
<title>Configuring binding service properties for non self contained aggregate application</title>
<simpara>The non self-contained aggregate application is bound to external broker via either or both the inbound/outbound components (typically, message channels) of the aggregate application while the applications inside the aggregate application are directly bound.
For example: a source application&#8217;s output and a processor application&#8217;s input are directly bound while the processor&#8217;s output channel is bound to an external destination at the broker.
When passing the binding service properties for non-self contained aggregate application, it is required to pass the binding service properties to the aggregate application instead of setting them as 'args' to individual child application.
For instance,</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
public class SampleAggregateApplication {

	public static void main(String[] args) {
		new AggregateApplicationBuilder()
			.from(SourceApplication.class).namespace("source").args("--fixedDelay=5000")
			.via(ProcessorApplication.class).namespace("processor1").args("--debug=true").run(args);
	}
}</programlisting>
<simpara>The binding properties like <literal>--spring.cloud.stream.bindings.output.destination=processor-output</literal> need to be specified as one of the external configuration properties (cmdline arg etc.,).</simpara>
</section>
</section>
</section>
</chapter>
<chapter xml:id="_binders">
<title>Binders</title>
<simpara>Spring Cloud Stream provides a Binder abstraction for use in connecting to physical destinations at the external middleware.
This section provides information about the main concepts behind the Binder SPI, its main components, and implementation-specific details.</simpara>
<section xml:id="_producers_and_consumers">
<title>Producers and Consumers</title>
<figure>
<title>Producers and Consumers</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/producers-consumers.png" contentwidth="300" width="75%" scalefit="1"/>
</imageobject>
<textobject><phrase>producers consumers</phrase></textobject>
</mediaobject>
</figure>
<simpara>A <emphasis>producer</emphasis> is any component that sends messages to a channel.
The channel can be bound to an external message broker via a Binder implementation for that broker.
When invoking the <literal>bindProducer()</literal> method, the first parameter is the name of the destination within the broker, the second parameter is the local channel instance to which the producer will send messages, and the third parameter contains properties (such as a partition key expression) to be used within the adapter that is created for that channel.</simpara>
<simpara>A <emphasis>consumer</emphasis> is any component that receives messages from a channel.
As with a producer, the consumer&#8217;s channel can be bound to an external message broker.
When invoking the <literal>bindConsumer()</literal> method, the first parameter is the destination name, and a second parameter provides the name of a logical group of consumers.
Each group that is represented by consumer bindings for a given destination receives a copy of each message that a producer sends to that destination (i.e., publish-subscribe semantics).
If there are multiple consumer instances bound using the same group name, then messages will be load-balanced across those consumer instances so that each message sent by a producer is consumed by only a single consumer instance within each group (i.e., queueing semantics).</simpara>
</section>
<section xml:id="_binder_spi">
<title>Binder SPI</title>
<simpara>The Binder SPI consists of a number of interfaces, out-of-the box utility classes and discovery strategies that provide a pluggable mechanism for connecting to external middleware.</simpara>
<simpara>The key point of the SPI is the <literal>Binder</literal> interface which is a strategy for connecting inputs and outputs to external middleware.</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Binder&lt;T, C extends ConsumerProperties, P extends ProducerProperties&gt; {
	Binding&lt;T&gt; bindConsumer(String name, String group, T inboundBindTarget, C consumerProperties);

	Binding&lt;T&gt; bindProducer(String name, T outboundBindTarget, P producerProperties);
}</programlisting>
<simpara>The interface is parameterized, offering a number of extension points:</simpara>
<itemizedlist>
<listitem>
<simpara>input and output bind targets - as of version 1.0, only <literal>MessageChannel</literal> is supported, but this is intended to be used as an extension point in the future;</simpara>
</listitem>
<listitem>
<simpara>extended consumer and producer properties - allowing specific Binder implementations to add supplemental properties which can be supported in a type-safe manner.</simpara>
</listitem>
</itemizedlist>
<simpara>A typical binder implementation consists of the following</simpara>
<itemizedlist>
<listitem>
<simpara>a class that implements the <literal>Binder</literal> interface;</simpara>
</listitem>
<listitem>
<simpara>a Spring <literal>@Configuration</literal> class that creates a bean of the type above along with the middleware connection infrastructure;</simpara>
</listitem>
<listitem>
<simpara>a <literal>META-INF/spring.binders</literal> file found on the classpath containing one or more binder definitions, e.g.</simpara>
</listitem>
</itemizedlist>
<screen>kafka:\
org.springframework.cloud.stream.binder.kafka.config.KafkaBinderConfiguration</screen>
</section>
<section xml:id="_binder_detection">
<title>Binder Detection</title>
<simpara>Spring Cloud Stream relies on implementations of the Binder SPI to perform the task of connecting channels to message brokers.
Each Binder implementation typically connects to one type of messaging system.</simpara>
<section xml:id="_classpath_detection">
<title>Classpath Detection</title>
<simpara>By default, Spring Cloud Stream relies on Spring Boot&#8217;s auto-configuration to configure the binding process.
If a single Binder implementation is found on the classpath, Spring Cloud Stream will use it automatically.
For example, a Spring Cloud Stream project that aims to bind only to RabbitMQ can simply add the following dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For the specific maven coordinates of other binder dependencies, please refer to the documentation of that binder implementation.</simpara>
</section>
</section>
<section xml:id="multiple-binders">
<title>Multiple Binders on the Classpath</title>
<simpara>When multiple binders are present on the classpath, the application must indicate which binder is to be used for each channel binding.
Each binder configuration contains a <literal>META-INF/spring.binders</literal>, which is a simple properties file:</simpara>
<screen>rabbit:\
org.springframework.cloud.stream.binder.rabbit.config.RabbitServiceAutoConfiguration</screen>
<simpara>Similar files exist for the other provided binder implementations (e.g., Kafka), and custom binder implementations are expected to provide them, as well.
The key represents an identifying name for the binder implementation, whereas the value is a comma-separated list of configuration classes that each contain one and only one bean definition of type <literal>org.springframework.cloud.stream.binder.Binder</literal>.</simpara>
<simpara>Binder selection can either be performed globally, using the <literal>spring.cloud.stream.defaultBinder</literal> property (e.g., <literal>spring.cloud.stream.defaultBinder=rabbit</literal>) or individually, by configuring the binder on each channel binding.
For instance, a processor application (that has channels with the names <literal>input</literal> and <literal>output</literal> for read/write respectively) which reads from Kafka and writes to RabbitMQ can specify the following configuration:</simpara>
<screen>spring.cloud.stream.bindings.input.binder=kafka
spring.cloud.stream.bindings.output.binder=rabbit</screen>
</section>
<section xml:id="multiple-systems">
<title>Connecting to Multiple Systems</title>
<simpara>By default, binders share the application&#8217;s Spring Boot auto-configuration, so that one instance of each binder found on the classpath will be created.
If your application should connect to more than one broker of the same type, you can specify multiple binder configurations, each with different environment settings.</simpara>
<note>
<simpara>Turning on explicit binder configuration will disable the default binder configuration process altogether.
If you do this, all binders in use must be included in the configuration.
Frameworks that intend to use Spring Cloud Stream transparently may create binder configurations that can be referenced by name, but will not affect the default binder configuration.
In order to do so, a binder configuration may have its <literal>defaultCandidate</literal> flag set to false, e.g. <literal>spring.cloud.stream.binders.&lt;configurationName&gt;.defaultCandidate=false</literal>.
This denotes a configuration that will exist independently of the default binder configuration process.</simpara>
</note>
<simpara>For example, this is the typical configuration for a processor application which connects to two RabbitMQ broker instances:</simpara>
<programlisting language="yml" linenumbering="unnumbered">spring:
  cloud:
    stream:
      bindings:
        input:
          destination: foo
          binder: rabbit1
        output:
          destination: bar
          binder: rabbit2
      binders:
        rabbit1:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: &lt;host1&gt;
        rabbit2:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: &lt;host2&gt;</programlisting>
</section>
<section xml:id="_binder_configuration_properties">
<title>Binder configuration properties</title>
<simpara>The following properties are available when creating custom binder configurations.
They must be prefixed with <literal>spring.cloud.stream.binders.&lt;configurationName&gt;</literal>.</simpara>
<variablelist>
<varlistentry>
<term>type</term>
<listitem>
<simpara>  The binder type.
It typically references one of the binders found on the classpath, in particular a key in a <literal>META-INF/spring.binders</literal> file.</simpara>
<simpara>By default, it has the same value as the configuration name.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>inheritEnvironment</term>
<listitem>
<simpara>Whether the configuration will inherit the environment of the application itself.</simpara>
<simpara>Default <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>environment</term>
<listitem>
<simpara>  Root for a set of properties that can be used to customize the environment of the binder.
When this is configured, the context in which the binder is being created is not a child of the application context.
This allows for complete separation between the binder components and the application components.</simpara>
<simpara>Default <literal>empty</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>defaultCandidate</term>
<listitem>
<simpara>  Whether the binder configuration is a candidate for being considered a default binder, or can be used only when explicitly referenced.
This allows adding binder configurations without interfering with the default processing.</simpara>
<simpara>Default <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</chapter>
<chapter xml:id="_configuration_options">
<title>Configuration Options</title>
<simpara>Spring Cloud Stream supports general configuration options as well as configuration for bindings and binders.
Some binders allow additional binding properties to support middleware-specific features.</simpara>
<simpara>Configuration options can be provided to Spring Cloud Stream applications via any mechanism supported by Spring Boot.
This includes application arguments, environment variables, and YAML or .properties files.</simpara>
<section xml:id="_spring_cloud_stream_properties">
<title>Spring Cloud Stream Properties</title>
<variablelist>
<varlistentry>
<term>spring.cloud.stream.instanceCount</term>
<listitem>
<simpara>  The number of deployed instances of an application.
Must be set for partitioning and if using Kafka.</simpara>
<simpara>Default: <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.instanceIndex</term>
<listitem>
<simpara>  The instance index of the application: a number from <literal>0</literal> to <literal>instanceCount</literal>-1.
Used for partitioning and with Kafka.
Automatically set in Cloud Foundry to match the application&#8217;s instance index.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.dynamicDestinations</term>
<listitem>
<simpara>  A list of destinations that can be bound dynamically (for example, in a dynamic routing scenario).
If set, only listed destinations can be bound.</simpara>
<simpara>Default: empty (allowing any destination to be bound).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.defaultBinder</term>
<listitem>
<simpara>  The default binder to use, if multiple binders are configured.
See <link linkend="multiple-binders">Multiple Binders on the Classpath</link>.</simpara>
<simpara>Default: empty.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.overrideCloudConnectors</term>
<listitem>
<simpara>  This property is only applicable when the <literal>cloud</literal> profile is active and Spring Cloud Connectors are provided with the application.
If the property is false (the default), the binder will detect a suitable bound service (e.g. a RabbitMQ service bound in Cloud Foundry for the RabbitMQ binder) and will use it for creating connections (usually via Spring Cloud Connectors).
When set to true, this property instructs binders to completely ignore the bound services and rely on Spring Boot properties (e.g. relying on the <literal>spring.rabbitmq.*</literal> properties provided in the environment for the RabbitMQ binder).
The typical usage of this property is to be nested in a customized environment <link linkend="multiple-systems">when connecting to multiple systems</link>.</simpara>
<simpara>Default: false.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="binding-properties">
<title>Binding Properties</title>
<simpara>Binding properties are supplied using the format <literal>spring.cloud.stream.bindings.&lt;channelName&gt;.&lt;property&gt;=&lt;value&gt;</literal>.
The <literal>&lt;channelName&gt;</literal> represents the name of the channel being configured (e.g., <literal>output</literal> for a <literal>Source</literal>).</simpara>
<simpara>To avoid repetition, Spring Cloud Stream supports setting values for all channels, in the format <literal>spring.cloud.stream.default.&lt;property&gt;=&lt;value&gt;</literal>.</simpara>
<simpara>In what follows, we indicate where we have omitted the <literal>spring.cloud.stream.bindings.&lt;channelName&gt;.</literal> prefix and focus just on the property name, with the understanding that the prefix will be included at runtime.</simpara>
<section xml:id="_properties_for_use_of_spring_cloud_stream">
<title>Properties for Use of Spring Cloud Stream</title>
<simpara>The following binding properties are available for both input and output bindings and must be prefixed with <literal>spring.cloud.stream.bindings.&lt;channelName&gt;.</literal>, e.g. <literal>spring.cloud.stream.bindings.input.destination=ticktock</literal>.</simpara>
<simpara>Default values can be set by using the prefix <literal>spring.cloud.stream.default</literal>, e.g. <literal>spring.cloud.stream.default.contentType=application/json</literal>.</simpara>
<variablelist>
<varlistentry>
<term>destination</term>
<listitem>
<simpara>The target destination of a channel on the bound middleware (e.g., the RabbitMQ exchange or Kafka topic).
If the channel is bound as a consumer, it could be bound to multiple destinations and the destination names can be specified as comma separated String values.
If not set, the channel name is used instead.
The default value of this property cannot be overridden.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>group</term>
<listitem>
<simpara>    The consumer group of the channel.
Applies only to inbound bindings.
See <link linkend="consumer-groups">Consumer Groups</link>.</simpara>
<simpara>Default: null (indicating an anonymous consumer).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>contentType</term>
<listitem>
<simpara>The content type of the channel.</simpara>
<simpara>Default: null (so that no type coercion is performed).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>binder</term>
<listitem>
<simpara>    The binder used by this binding.
See <xref linkend="multiple-binders"/> for details.</simpara>
<simpara>Default: null (the default binder will be used, if one exists).</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_consumer_properties">
<title>Consumer properties</title>
<simpara>The following binding properties are available for input bindings only and must be prefixed with <literal>spring.cloud.stream.bindings.&lt;channelName&gt;.consumer.</literal>, e.g. <literal>spring.cloud.stream.bindings.input.consumer.concurrency=3</literal>.</simpara>
<simpara>Default values can be set by using the prefix <literal>spring.cloud.stream.default.consumer</literal>, e.g. <literal>spring.cloud.stream.default.consumer.headerMode=raw</literal>.</simpara>
<variablelist>
<varlistentry>
<term>concurrency</term>
<listitem>
<simpara>The concurrency of the inbound consumer.</simpara>
<simpara>Default: <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>partitioned</term>
<listitem>
<simpara>Whether the consumer receives data from a partitioned producer.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>headerMode</term>
<listitem>
<simpara>    When set to <literal>raw</literal>, disables header parsing on input.
Effective only for messaging middleware that does not support message headers natively and requires header embedding.
Useful when inbound data is coming from outside Spring Cloud Stream applications.</simpara>
<simpara>Default: <literal>embeddedHeaders</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>maxAttempts</term>
<listitem>
<simpara>If processing fails, the number of attempts to process the message (including the first).
Set to 1 to disable retry.</simpara>
<simpara>Default: <literal>3</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>backOffInitialInterval</term>
<listitem>
<simpara>The backoff initial interval on retry.</simpara>
<simpara>Default: <literal>1000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>backOffMaxInterval</term>
<listitem>
<simpara>The maximum backoff interval.</simpara>
<simpara>Default: <literal>10000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>backOffMultiplier</term>
<listitem>
<simpara>The backoff multiplier.</simpara>
<simpara>Default: <literal>2.0</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>instanceIndex</term>
<listitem>
<simpara>  When set to a value greater than equal to zero, allows customizing the instance index of this consumer (if different from <literal>spring.cloud.stream.instanceIndex</literal>).
When set to a negative value, it will default to <literal>spring.cloud.stream.instanceIndex</literal>.</simpara>
<simpara>Default: <literal>-1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>instanceCount</term>
<listitem>
<simpara>  When set to a value greater than equal to zero, allows customizing the instance count of this consumer (if different from <literal>spring.cloud.stream.instanceCount</literal>).
When set to a negative value, it will default to <literal>spring.cloud.stream.instanceCount</literal>.</simpara>
<simpara>Default: <literal>-1</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_producer_properties">
<title>Producer Properties</title>
<simpara>The following binding properties are available for output bindings only and must be prefixed with <literal>spring.cloud.stream.bindings.&lt;channelName&gt;.producer.</literal>, e.g. <literal>spring.cloud.stream.bindings.input.producer.partitionKeyExpression=payload.id</literal>.</simpara>
<simpara>Default values can be set by using the prefix <literal>spring.cloud.stream.default.producer</literal>, e.g. <literal>spring.cloud.stream.default.producer.partitionKeyExpression=payload.id</literal>.</simpara>
<variablelist>
<varlistentry>
<term>partitionKeyExpression</term>
<listitem>
<simpara>  A SpEL expression that determines how to partition outbound data.
If set, or if <literal>partitionKeyExtractorClass</literal> is set, outbound data on this channel will be partitioned, and <literal>partitionCount</literal> must be set to a value greater than 1 to be effective.
The two options are mutually exclusive.
See <xref linkend="partitioning"/>.</simpara>
<simpara>Default: null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>partitionKeyExtractorClass</term>
<listitem>
<simpara>  A <literal>PartitionKeyExtractorStrategy</literal> implementation.
If set, or if <literal>partitionKeyExpression</literal> is set, outbound data on this channel will be partitioned, and <literal>partitionCount</literal> must be set to a value greater than 1 to be effective.
The two options are mutually exclusive.
See <xref linkend="partitioning"/>.</simpara>
<simpara>Default: null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>partitionSelectorClass</term>
<listitem>
<simpara>  A <literal>PartitionSelectorStrategy</literal> implementation.
Mutually exclusive with <literal>partitionSelectorExpression</literal>.
If neither is set, the partition will be selected as the <literal>hashCode(key) % partitionCount</literal>, where <literal>key</literal> is computed via either <literal>partitionKeyExpression</literal> or <literal>partitionKeyExtractorClass</literal>.</simpara>
<simpara>Default: null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>partitionSelectorExpression</term>
<listitem>
<simpara>  A SpEL expression for customizing partition selection.
Mutually exclusive with <literal>partitionSelectorClass</literal>.
If neither is set, the partition will be selected as the <literal>hashCode(key) % partitionCount</literal>, where <literal>key</literal> is computed via either <literal>partitionKeyExpression</literal> or <literal>partitionKeyExtractorClass</literal>.</simpara>
<simpara>Default: null.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>partitionCount</term>
<listitem>
<simpara>  The number of target partitions for the data, if partitioning is enabled.
Must be
  set to a value greater than 1 if the producer is partitioned.
On Kafka, interpreted as a
  hint; the larger of this and the partition count of the target topic is used instead.</simpara>
<simpara>Default: <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>requiredGroups</term>
<listitem>
<simpara>A comma-separated list of groups to which the producer must ensure message delivery even if they start after it has been created (e.g., by pre-creating durable queues in RabbitMQ).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>headerMode</term>
<listitem>
<simpara>  When set to <literal>raw</literal>, disables header embedding on output.
Effective only for messaging middleware that does not support message headers natively and requires header embedding.
Useful when producing data for non-Spring Cloud Stream applications.</simpara>
<simpara>Default: <literal>embeddedHeaders</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>useNativeEncoding</term>
<listitem>
<simpara>  When set to <literal>true</literal>, the outbound message is serialized directly by client library, which must be configured correspondingly (e.g. setting an appropriate Kafka producer value serializer).
When this configuration is being used, the outbound message marshalling is not based on the <literal>contentType</literal> of the binding.
When native encoding is used, it is the responsibility of the consumer to use appropriate decoder (ex: Kafka consumer value de-serializer) to deserialize the inbound message.
Also, when native encoding/decoding is used the <literal>headerMode</literal> property is ignored and headers will not be embedded into the message.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>errorChannelEnabled</term>
<listitem>
<simpara>When set to <literal>true</literal>, if the binder supports async send results; send failures will be sent to an error channel for the destination.
See <xref linkend="binder-error-channels"/> for more information.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="dynamicdestination">
<title>Using dynamically bound destinations</title>
<simpara>Besides the channels defined via <literal>@EnableBinding</literal>, Spring Cloud Stream allows applications to send messages to dynamically bound destinations.
This is useful, for example, when the target destination needs to be determined at runtime.
Applications can do so by using the <literal>BinderAwareChannelResolver</literal> bean, registered automatically by the <literal>@EnableBinding</literal> annotation.</simpara>
<simpara>The property 'spring.cloud.stream.dynamicDestinations' can be used for restricting the dynamic destination names to a set known beforehand (whitelisting).
If the property is not set, any destination can be bound dynamicaly.</simpara>
<simpara>The <literal>BinderAwareChannelResolver</literal> can be used directly as in the following example, in which a REST controller uses a path variable to decide the target channel.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding
@Controller
public class SourceWithDynamicDestination {

	@Autowired
	private BinderAwareChannelResolver resolver;

	@RequestMapping(path = "/{target}", method = POST, consumes = "*/*")
	@ResponseStatus(HttpStatus.ACCEPTED)
	public void handleRequest(@RequestBody String body, @PathVariable("target") target,
	       @RequestHeader(HttpHeaders.CONTENT_TYPE) Object contentType) {
		sendMessage(body, target, contentType);
	}

	private void sendMessage(String body, String target, Object contentType) {
		resolver.resolveDestination(target).send(MessageBuilder.createMessage(body,
				new MessageHeaders(Collections.singletonMap(MessageHeaders.CONTENT_TYPE, contentType))));
	}
}</programlisting>
<simpara>After starting the application on the default port 8080, when sending the following data:</simpara>
<screen>curl -H "Content-Type: application/json" -X POST -d "customer-1" http://localhost:8080/customers

curl -H "Content-Type: application/json" -X POST -d "order-1" http://localhost:8080/orders</screen>
<simpara>The destinations 'customers' and 'orders' are created in the broker (for example: exchange in case of Rabbit or topic in case of Kafka) with the names 'customers' and 'orders', and the data is published to the appropriate destinations.</simpara>
<simpara>The <literal>BinderAwareChannelResolver</literal> is a general purpose Spring Integration <literal>DestinationResolver</literal> and can be injected in other components.
For example, in a router using a SpEL expression based on the <literal>target</literal> field of an incoming JSON message.</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding
@Controller
public class SourceWithDynamicDestination {

	@Autowired
	private BinderAwareChannelResolver resolver;


	@RequestMapping(path = "/", method = POST, consumes = "application/json")
	@ResponseStatus(HttpStatus.ACCEPTED)
	public void handleRequest(@RequestBody String body, @RequestHeader(HttpHeaders.CONTENT_TYPE) Object contentType) {
		sendMessage(body, contentType);
	}

	private void sendMessage(Object body, Object contentType) {
		routerChannel().send(MessageBuilder.createMessage(body,
				new MessageHeaders(Collections.singletonMap(MessageHeaders.CONTENT_TYPE, contentType))));
	}

	@Bean(name = "routerChannel")
	public MessageChannel routerChannel() {
		return new DirectChannel();
	}

	@Bean
	@ServiceActivator(inputChannel = "routerChannel")
	public ExpressionEvaluatingRouter router() {
        ExpressionEvaluatingRouter router =
            new ExpressionEvaluatingRouter(new SpelExpressionParser().parseExpression("payload.target"));
		router.setDefaultOutputChannelName("default-output");
		router.setChannelResolver(resolver);
		return router;
	}
}</programlisting>
</section>
</chapter>
<chapter xml:id="contenttypemanagement">
<title>Content Type and Transformation</title>
<simpara>To allow you to propagate information about the content type of produced messages, Spring Cloud Stream attaches, by default, a <literal>contentType</literal> header to outbound messages.
For middleware that does not directly support headers, Spring Cloud Stream provides its own mechanism of automatically wrapping outbound messages in an envelope of its own.
For middleware that does support headers, Spring Cloud Stream applications may receive messages with a given content type from non-Spring Cloud Stream applications.</simpara>
<simpara>Spring Cloud Stream can handle messages based on this information in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Through its <literal>contentType</literal> settings on inbound and outbound channels</simpara>
</listitem>
<listitem>
<simpara>Through its argument mapping performed for methods annotated with <literal>@StreamListener</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Spring Cloud Stream allows you to declaratively configure type conversion for inputs and outputs using the <literal>spring.cloud.stream.bindings.&lt;channelName&gt;.content-type</literal> property of a binding.
Note that general type conversion may also be accomplished easily by using a transformer inside your application.
Currently, Spring Cloud Stream natively supports the following type conversions commonly used in streams:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">JSON</emphasis> to/from <emphasis role="strong">POJO</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">JSON</emphasis> to/from <link xl:href="https://github.com/spring-projects/spring-tuple/blob/master/spring-tuple/src/main/java/org/springframework/tuple/Tuple.java">org.springframework.tuple.Tuple</link></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Object</emphasis> to/from <emphasis role="strong">byte[]</emphasis> : Either the raw bytes serialized for remote transport, bytes emitted by an application, or converted to bytes using Java serialization(requires the object to be Serializable)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">String</emphasis> to/from <emphasis role="strong">byte[]</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Object</emphasis> to <emphasis role="strong">plain text</emphasis> (invokes the object&#8217;s <emphasis>toString()</emphasis> method)</simpara>
</listitem>
</itemizedlist>
<simpara>Where <emphasis>JSON</emphasis> represents either a byte array or String payload containing JSON.
Currently, Objects may be converted from a JSON byte array or String.
Converting to JSON always produces a String.</simpara>
<simpara>If no <literal>content-type</literal> property is set on an outbound channel, Spring Cloud Stream will serialize the payload using a serializer based on the <link xl:href="https://github.com/EsotericSoftware/kryo">Kryo</link> serialization framework.
Deserializing messages at the destination requires the payload class to be present on the receiver&#8217;s classpath.</simpara>
<section xml:id="mime-types">
<title>MIME types</title>
<simpara><literal>content-type</literal> values are parsed as media types, e.g., <literal>application/json</literal> or <literal>text/plain;charset=UTF-8</literal>.
MIME types are especially useful for indicating how to convert to String or byte[] content.
Spring Cloud Stream also uses MIME type format to represent Java types, using the general type <literal>application/x-java-object</literal> with a <literal>type</literal> parameter.
For example, <literal>application/x-java-object;type=java.util.Map</literal> or <literal>application/x-java-object;type=com.bar.Foo</literal> can be set as the <literal>content-type</literal> property of an input binding.
In addition, Spring Cloud Stream provides custom MIME types, notably, <literal>application/x-spring-tuple</literal> to specify a Tuple.</simpara>
</section>
<section xml:id="mime-types-and-java-types">
<title>MIME types and Java types</title>
<simpara>The type conversions Spring Cloud Stream provides out of the box are summarized in the following table:
'Source Payload' means the payload before conversion and 'Target Payload' means the 'payload' after conversion.
The type conversion can occur either on the 'producer' side (output) or at the 'consumer' side (input).</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Source Payload</entry>
<entry align="left" valign="top">Target Payload</entry>
<entry align="left" valign="top"><literal>content-type</literal> header (source message)</entry>
<entry align="left" valign="top"><literal>content-type</literal> header (after conversion)</entry>
<entry align="left" valign="top">Comments</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>POJO</simpara></entry>
<entry align="left" valign="top"><simpara>JSON String</simpara></entry>
<entry align="left" valign="top"><simpara>ignored</simpara></entry>
<entry align="left" valign="top"><simpara>application/json</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tuple</simpara></entry>
<entry align="left" valign="top"><simpara>JSON String</simpara></entry>
<entry align="left" valign="top"><simpara>ignored</simpara></entry>
<entry align="left" valign="top"><simpara>application/json</simpara></entry>
<entry align="left" valign="top"><simpara>JSON is tailored for Tuple</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>POJO</simpara></entry>
<entry align="left" valign="top"><simpara>String (toString())</simpara></entry>
<entry align="left" valign="top"><simpara>ignored</simpara></entry>
<entry align="left" valign="top"><simpara>text/plain, java.lang.String</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>POJO</simpara></entry>
<entry align="left" valign="top"><simpara>byte[] (java.io serialized)</simpara></entry>
<entry align="left" valign="top"><simpara>ignored</simpara></entry>
<entry align="left" valign="top"><simpara>application/x-java-serialized-object</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>JSON byte[] or String</simpara></entry>
<entry align="left" valign="top"><simpara>POJO</simpara></entry>
<entry align="left" valign="top"><simpara>application/json (or none)</simpara></entry>
<entry align="left" valign="top"><simpara>application/x-java-object</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>byte[] or String</simpara></entry>
<entry align="left" valign="top"><simpara>Serializable</simpara></entry>
<entry align="left" valign="top"><simpara>application/x-java-serialized-object</simpara></entry>
<entry align="left" valign="top"><simpara>application/x-java-object</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>JSON byte[] or String</simpara></entry>
<entry align="left" valign="top"><simpara>Tuple</simpara></entry>
<entry align="left" valign="top"><simpara>application/json (or none)</simpara></entry>
<entry align="left" valign="top"><simpara>application/x-spring-tuple</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>byte[]</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>any</simpara></entry>
<entry align="left" valign="top"><simpara>text/plain, java.lang.String</simpara></entry>
<entry align="left" valign="top"><simpara>will apply any Charset specified in the content-type header</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>byte[]</simpara></entry>
<entry align="left" valign="top"><simpara>any</simpara></entry>
<entry align="left" valign="top"><simpara>application/octet-stream</simpara></entry>
<entry align="left" valign="top"><simpara>will apply any Charset specified in the content-type header</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>Conversion applies to payloads that require type conversion.
For example, if an application produces an XML string with outputType=application/json, the payload will not be converted from XML to JSON.
This is because the payload send to the outbound channel is already a String so no conversion will be applied at runtime.
It is also important to note that when using the default serialization mechanism, the payload class must be shared between the sending and receiving application, and compatible with the binary content.
This can create issues when application code changes independently in the two applications, as the binary format and code may become incompatible.</simpara>
</note>
<tip>
<simpara>While conversion is supported for both inbound and outbound channels, it is especially recommended to be used for the conversion of outbound messages.
For the conversion of inbound messages, especially when the target is a POJO, the <literal>@StreamListener</literal> support will perform the conversion automatically.</simpara>
</tip>
</section>
<section xml:id="_customizing_message_conversion">
<title>Customizing message conversion</title>
<simpara>Besides the conversions that it supports out of the box, Spring Cloud Stream also supports registering your own message conversion implementations.
This allows you to send and receive data in a variety of custom formats, including binary, and associate them with specific <literal>contentTypes</literal>.
Spring Cloud Stream registers all the beans of type <literal>org.springframework.messaging.converter.MessageConverter</literal> as custom message converters along with the out of the box message converters.</simpara>
<simpara>If your message converter needs to work with a specific <literal>content-type</literal> and target class (for both input and output), then the message converter needs to extend <literal>org.springframework.messaging.converter.AbstractMessageConverter</literal>.
For conversion when using <literal>@StreamListener</literal>, a message converter that implements <literal>org.springframework.messaging.converter.MessageConverter</literal> would suffice.</simpara>
<simpara>Here is an example of creating a message converter bean (with the content-type <literal>application/bar</literal>) inside a Spring Cloud Stream application:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

  ...

  @Bean
  public MessageConverter customMessageConverter() {
    return new MyCustomMessageConverter();
  }</programlisting>
<programlisting language="java" linenumbering="unnumbered">public class MyCustomMessageConverter extends AbstractMessageConverter {

	public MyCustomMessageConverter() {
		super(new MimeType("application", "bar"));
	}

	@Override
  protected boolean supports(Class&lt;?&gt; clazz) {
    return (Bar.class == clazz);
  }

	@Override
	protected Object convertFromInternal(Message&lt;?&gt; message, Class&lt;?&gt; targetClass, Object conversionHint) {
		Object payload = message.getPayload();
		return (payload instanceof Bar ? payload : new Bar((byte[]) payload));
	}
}</programlisting>
<simpara>Spring Cloud Stream also provides support for Avro-based converters and schema evolution.
See <link linkend="schema-evolution">the specific section</link> for details.</simpara>
</section>
<section xml:id="__literal_streamlistener_literal_and_message_conversion">
<title><literal>@StreamListener</literal> and Message Conversion</title>
<simpara>The <literal>@StreamListener</literal> annotation provides a convenient way for converting incoming messages without the need to specify the content type of an input channel.
During the dispatching process to methods annotated with <literal>@StreamListener</literal>, a conversion will be applied automatically if the argument requires it.</simpara>
<simpara>For example, let&#8217;s consider a message with the String content <literal>{"greeting":"Hello, world"}</literal> and a <literal>content-type</literal> header of <literal>application/json</literal> is received on the input channel.
Let us consider the following application that receives it:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class GreetingMessage {

  String greeting;

  public String getGreeting() {
    return greeting;
  }

  public void setGreeting(String greeting) {
    this.greeting = greeting;
  }
}

@EnableBinding(Sink.class)
@EnableAutoConfiguration
public static class GreetingSink {

		@StreamListener(Sink.INPUT)
		public void receive(Greeting greeting) {
			// handle Greeting
		}
	}</programlisting>
<simpara>The argument of the method will be populated automatically with the POJO containing the unmarshalled form of the JSON String.</simpara>
</section>
</chapter>
<chapter xml:id="schema-evolution">
<title>Schema evolution support</title>
<simpara>Spring Cloud Stream provides support for schema-based message converters through its <literal>spring-cloud-stream-schema</literal> module.
Currently, the only serialization format supported out of the box for schema-based message converters is Apache Avro, with more formats to be added in future versions.</simpara>
<section xml:id="_apache_avro_message_converters">
<title>Apache Avro Message Converters</title>
<simpara>The <literal>spring-cloud-stream-schema</literal> module contains two types of message converters that can be used for Apache Avro serialization:</simpara>
<itemizedlist>
<listitem>
<simpara>converters using the class information of the serialized/deserialized objects, or a schema with a location known at startup;</simpara>
</listitem>
<listitem>
<simpara>converters using a schema registry - they locate the schemas at runtime, as well as dynamically registering new schemas as domain objects evolve.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_converters_with_schema_support">
<title>Converters with schema support</title>
<simpara>The <literal>AvroSchemaMessageConverter</literal> supports serializing and deserializing messages either using a predefined schema or by using the schema information available in the class (either reflectively, or contained in the <literal>SpecificRecord</literal>).
If the target type of the conversion is a <literal>GenericRecord</literal>, then a schema must be set.</simpara>
<simpara>For using it, you can simply add it to the application context, optionally specifying one ore more <literal>MimeTypes</literal> to associate it with.
The default <literal>MimeType</literal> is <literal>application/avro</literal>.</simpara>
<simpara>Here is an example of configuring it in a sink application registering the Apache Avro <literal>MessageConverter</literal>, without a predefined schema:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

  ...

  @Bean
  public MessageConverter userMessageConverter() {
      return new AvroSchemaMessageConverter(MimeType.valueOf("avro/bytes"));
  }
}</programlisting>
<simpara>Conversely, here is an application that registers a converter with a predefined schema, to be found on the classpath:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

  ...

  @Bean
  public MessageConverter userMessageConverter() {
      AvroSchemaMessageConverter converter = new AvroSchemaMessageConverter(MimeType.valueOf("avro/bytes"));
      converter.setSchemaLocation(new ClassPathResource("schemas/User.avro"));
      return converter;
  }
}</programlisting>
<simpara>In order to understand the schema registry client converter, we will describe the schema registry support first.</simpara>
</section>
<section xml:id="_schema_registry_support">
<title>Schema Registry Support</title>
<simpara>Most serialization models, especially the ones that aim for portability across different platforms and languages, rely on a schema that describes how the data is serialized in the binary payload.
In order to serialize the data and then to interpret it, both the sending and receiving sides must have access to a schema that describes the binary format.
In certain cases, the schema can be inferred from the payload type on serialization, or from the target type on deserialization, but in a lot of cases applications benefit from having access to an explicit schema that describes the binary data format.
A schema registry allows you to store schema information in a textual format (typically JSON) and makes that information accessible to various applications that need it to receive and send data in binary format.
A schema is referenceable as a tuple consisting of:</simpara>
<itemizedlist>
<listitem>
<simpara>a <emphasis>subject</emphasis> that is the logical name of the schema;</simpara>
</listitem>
<listitem>
<simpara>the schema <emphasis>version</emphasis>;</simpara>
</listitem>
<listitem>
<simpara>the schema <emphasis>format</emphasis>  which describes the binary format of the data.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_schema_registry_server">
<title>Schema Registry Server</title>
<simpara>Spring Cloud Stream provides a schema registry server implementation.
In order to use it, you can simply add the <literal>spring-cloud-stream-schema-server</literal> artifact to your project and use the <literal>@EnableSchemaRegistryServer</literal> annotation, adding the schema registry server REST controller to your application.
This annotation is intended to be used with Spring Boot web applications, and the listening port of the server is controlled by the <literal>server.port</literal> setting.
The <literal>spring.cloud.stream.schema.server.path</literal> setting can be used to control the root path of the schema server (especially when it is embedded in other applications).
The <literal>spring.cloud.stream.schema.server.allowSchemaDeletion</literal> boolean setting enables the deletion of schema. By default this is disabled.</simpara>
<simpara>The schema registry server uses a relational database to store the schemas.
 By default, it uses an embedded database.
You can customize the schema storage using the <link xl:href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-sql">Spring Boot SQL database and JDBC configuration options</link>.</simpara>
<simpara>A Spring Boot application enabling the schema registry looks as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableSchemaRegistryServer
public class SchemaRegistryServerApplication {
	public static void main(String[] args) {
		SpringApplication.run(SchemaRegistryServerApplication.class, args);
	}
}</programlisting>
<section xml:id="_schema_registry_server_api">
<title>Schema Registry Server API</title>
<simpara>The Schema Registry Server API consists of the following operations:</simpara>
<section xml:id="__literal_post_literal">
<title><literal>POST /</literal></title>
<simpara>Register a new schema.</simpara>
<simpara>Accepts JSON payload  with the following fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>subject</literal> the schema subject;</simpara>
</listitem>
<listitem>
<simpara><literal>format</literal> the schema format;</simpara>
</listitem>
<listitem>
<simpara><literal>definition</literal> the schema definition.</simpara>
</listitem>
</itemizedlist>
<simpara>Response is a schema object in JSON format, with the following fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>id</literal> the schema id;</simpara>
</listitem>
<listitem>
<simpara><literal>subject</literal> the schema subject;</simpara>
</listitem>
<listitem>
<simpara><literal>format</literal> the schema format;</simpara>
</listitem>
<listitem>
<simpara><literal>version</literal> the schema version;</simpara>
</listitem>
<listitem>
<simpara><literal>definition</literal> the schema definition.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="__literal_get_subject_format_version_literal">
<title><literal>GET /{subject}/{format}/{version}</literal></title>
<simpara>Retrieve an existing schema by its subject, format and version.</simpara>
<simpara>Response is a schema object in JSON format, with the following fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>id</literal> the schema id;</simpara>
</listitem>
<listitem>
<simpara><literal>subject</literal> the schema subject;</simpara>
</listitem>
<listitem>
<simpara><literal>format</literal> the schema format;</simpara>
</listitem>
<listitem>
<simpara><literal>version</literal> the schema version;</simpara>
</listitem>
<listitem>
<simpara><literal>definition</literal> the schema definition.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="__literal_get_subject_format_literal">
<title><literal>GET /{subject}/{format}</literal></title>
<simpara>Retrieve a list of existing schema by its subject and format.</simpara>
<simpara>Response is a list of schemas with each schema object in JSON format, with the following fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>id</literal> the schema id;</simpara>
</listitem>
<listitem>
<simpara><literal>subject</literal> the schema subject;</simpara>
</listitem>
<listitem>
<simpara><literal>format</literal> the schema format;</simpara>
</listitem>
<listitem>
<simpara><literal>version</literal> the schema version;</simpara>
</listitem>
<listitem>
<simpara><literal>definition</literal> the schema definition.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="__literal_get_schemas_id_literal">
<title><literal>GET /schemas/{id}</literal></title>
<simpara>Retrieve an existing schema by its id.</simpara>
<simpara>Response is a schema object in JSON format, with the following fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>id</literal> the schema id;</simpara>
</listitem>
<listitem>
<simpara><literal>subject</literal> the schema subject;</simpara>
</listitem>
<listitem>
<simpara><literal>format</literal> the schema format;</simpara>
</listitem>
<listitem>
<simpara><literal>version</literal> the schema version;</simpara>
</listitem>
<listitem>
<simpara><literal>definition</literal> the schema definition.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="__literal_delete_subject_format_version_literal">
<title><literal>DELETE /{subject}/{format}/{version}</literal></title>
<simpara>Delete an existing schema by its subject, format and version.</simpara>
</section>
<section xml:id="__literal_delete_schemas_id_literal">
<title><literal>DELETE /schemas/{id}</literal></title>
<simpara>Delete an existing schema by its id.</simpara>
</section>
<section xml:id="__literal_delete_subject_literal">
<title><literal>DELETE /{subject}</literal></title>
<simpara>Delete existing schemas by their subject.</simpara>
<note>
<simpara>This note applies to users of Spring Cloud Stream 1.1.0.RELEASE only.
Spring Cloud Stream 1.1.0.RELEASE used the table name <literal>schema</literal> for storing <literal>Schema</literal> objects, which is a keyword in a number of database implementations.
To avoid any conflicts in the future, starting with 1.1.1.RELEASE we have opted for the name <literal>SCHEMA_REPOSITORY</literal> for the storage table.
Any Spring Cloud Stream 1.1.0.RELEASE users that are upgrading are advised to migrate their existing schemas to the new table before upgrading.</simpara>
</note>
</section>
</section>
</section>
<section xml:id="_schema_registry_client">
<title>Schema Registry Client</title>
<simpara>The client-side abstraction for interacting with schema registry servers is the <literal>SchemaRegistryClient</literal> interface, with the following structure:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface SchemaRegistryClient {

	SchemaRegistrationResponse register(String subject, String format, String schema);

	String fetch(SchemaReference schemaReference);

	String fetch(Integer id);

}</programlisting>
<simpara>Spring Cloud Stream provides out of the box implementations for interacting with its own schema server, as well as for interacting with the Confluent Schema Registry.</simpara>
<simpara>A client for the Spring Cloud Stream schema registry can be configured using the <literal>@EnableSchemaRegistryClient</literal> as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">  @EnableBinding(Sink.class)
  @SpringBootApplication
  @EnableSchemaRegistryClient
  public static class AvroSinkApplication {
    ...
  }</programlisting>
<note>
<simpara>The default converter is optimized to cache not only the schemas from the remote server but also the <literal>parse()</literal> and <literal>toString()</literal> methods that are quite expensive.
Because of this, it uses a <literal>DefaultSchemaRegistryClient</literal> that does not caches responses.
If you intend to use the client directly on your code, you can request a bean that also caches responses to be created.
To do that, just add the property <literal>spring.cloud.stream.schemaRegistryClient.cached=true</literal> to your application properties.</simpara>
</note>
<section xml:id="_using_confluent_s_schema_registry">
<title>Using Confluent&#8217;s Schema Registry</title>
<simpara>The default configuration will create a <literal>DefaultSchemaRegistryClient</literal> bean.
If you want to use the Confluent schema registry, you need to create a bean of type <literal>ConfluentSchemaRegistryClient</literal>, which will supersede the one configured by default by the framework.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bean
public SchemaRegistryClient schemaRegistryClient(@Value("${spring.cloud.stream.schemaRegistryClient.endpoint}") String endpoint){
  ConfluentSchemaRegistryClient client = new ConfluentSchemaRegistryClient();
  client.setEndpoint(endpoint);
  return client;
}</programlisting>
<note>
<simpara>The ConfluentSchemaRegistryClient is tested against Confluent platform version 3.2.2.</simpara>
</note>
</section>
<section xml:id="_schema_registry_client_properties">
<title>Schema Registry Client properties</title>
<simpara>The Schema Registry Client supports the following properties:</simpara>
<variablelist>
<varlistentry>
<term>spring.cloud.stream.schemaRegistryClient.endpoint</term>
<listitem>
<simpara>The location of the schema-server.
Use a full URL when setting this, including protocol (<literal>http</literal> or <literal>https</literal>) , port and context path.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default</term>
<listitem>
<simpara><literal><link xl:href="http://localhost:8990/">http://localhost:8990/</link></literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.schemaRegistryClient.cached</term>
<listitem>
<simpara>Whether the client should cache schema server responses.
Normally set to <literal>false</literal>, as the caching happens in the message converter.
Clients using the schema registry client should set this to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default</term>
<listitem>
<simpara><literal>true</literal></simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_avro_schema_registry_client_message_converters">
<title>Avro Schema Registry Client Message Converters</title>
<simpara>For Spring Boot applications that have a <literal>SchemaRegistryClient</literal> bean registered with the application context, Spring Cloud Stream will auto-configure an Apache Avro message converter that uses the schema registry client for schema management.
This eases schema evolution, as applications that receive messages can get easy access to a writer schema that can be reconciled with their own reader schema.</simpara>
<simpara>For outbound messages, the <literal>MessageConverter</literal> will be activated if the content type of the channel is set to <literal>application/*+avro</literal>, e.g.:</simpara>
<programlisting language="properties" linenumbering="unnumbered">spring.cloud.stream.bindings.output.contentType=application/*+avro</programlisting>
<simpara>During the outbound conversion, the message converter will try to infer the schemas of the outbound messages based on their type and register them to a subject based on the payload type using the <literal>SchemaRegistryClient</literal>.
If an identical schema is already found, then a reference to it will be retrieved.
If not, the schema will be registered and a new version number will be provided.
The message will be sent with a <literal>contentType</literal> header using the scheme <literal>application/[prefix].[subject].v[version]+avro</literal>, where <literal>prefix</literal> is configurable and <literal>subject</literal> is deduced from the payload type.</simpara>
<simpara>For example, a message of the type <literal>User</literal> may be sent as a binary payload with a content type of <literal>application/vnd.user.v2+avro</literal>, where <literal>user</literal> is the subject and <literal>2</literal> is the version number.</simpara>
<simpara>When receiving messages, the converter will infer the schema reference from the header of the incoming message and will try to retrieve it. The schema will be used as the writer schema in the deserialization process.</simpara>
<section xml:id="_avro_schema_registry_message_converter_properties">
<title>Avro Schema Registry Message Converter properties</title>
<simpara>If you have enabled Avro based schema registry client by setting <literal>spring.cloud.stream.bindings.output.contentType=application/*+avro</literal> you can customize the behavior of the registration with the following properties.</simpara>
<variablelist>
<varlistentry>
<term>spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</term>
<listitem>
<simpara>Enable if you want the converter to use reflection to infer a Schema from a POJO.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default</term>
<listitem>
<simpara><literal>false</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.schema.avro.readerSchema</term>
<listitem>
<simpara>Avro compares schema versions by looking at a writer schema (origin payload) and a reader schema (your application payload), check <link xl:href="https://avro.apache.org/docs/1.7.6/spec.html">Avro</link> documentation for more information. If set, this overrides any lookups at the schema server and uses the local schema as the reader schema.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default</term>
<listitem>
<simpara><literal>null</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.schema.avro.schemaLocations</term>
<listitem>
<simpara>Register any <literal>.avsc</literal> files listed in this property with the Schema Server.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default</term>
<listitem>
<simpara><literal>empty</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.schema.avro.prefix</term>
<listitem>
<simpara>The prefix to be used on the Content-Type header.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default</term>
<listitem>
<simpara><literal>vnd</literal></simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="_schema_registration_and_resolution">
<title>Schema Registration and Resolution</title>
<simpara>To better understand how Spring Cloud Stream registers and resolves new schemas, as well as its use of Avro schema comparison features, we will provide two separate subsections below: one for the registration, and one for the resolution of schemas.</simpara>
<section xml:id="_schema_registration_process_serialization">
<title>Schema Registration Process (Serialization)</title>
<simpara>The first part of the registration process is extracting a schema from the payload that is being sent over a channel.
Avro types such as <literal>SpecificRecord</literal> or <literal>GenericRecord</literal> already contain a schema, which can be retrieved immediately from the instance.
In the case of POJOs a schema will be inferred if the property <literal>spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</literal> is set to <literal>true</literal> (the default).</simpara>
<figure>
<title>Schema Writer Resolution Process</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/schema_resolution.png" contentwidth="300" width="75%" scalefit="1" align="center"/>
</imageobject>
<textobject><phrase>schema resolution</phrase></textobject>
</mediaobject>
</figure>
<simpara>Once a schema is obtained, the converter will then load its metadata (version) from the remote server.
First it queries a local cache, and if not found it then submits the data to the server that will reply with versioning information.
The converter will always cache the results to avoid the overhead of querying the Schema Server for every new message that needs to be serialized.</simpara>
<figure>
<title>Schema Registration Process</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/registration.png" contentwidth="300" width="75%" scalefit="1" align="center"/>
</imageobject>
<textobject><phrase>registration</phrase></textobject>
</mediaobject>
</figure>
<simpara>With the schema version information, the converter sets the <literal>contentType</literal> header of the message to carry the version information such as <literal>application/vnd.user.v1+avro</literal></simpara>
</section>
<section xml:id="_schema_resolution_process_deserialization">
<title>Schema Resolution Process (Deserialization)</title>
<simpara>When reading messages that contain version information (i.e. a <literal>contentType</literal> header with a scheme like above), the converter will query the Schema server to fetch the <emphasis role="strong">writer</emphasis> schema of the message.
Once it has found the correct schema of the incoming message, it then retrieves the reader schema and using Avro&#8217;s schema resolution support reads it into the reader definition (setting defaults and missing properties).</simpara>
<figure>
<title>Schema Reading Resolution Process</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/schema_reading.png" contentwidth="300" width="75%" scalefit="1" align="center"/>
</imageobject>
<textobject><phrase>schema reading</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara>It&#8217;s important to understand the difference between a writer schema (the application that wrote the message) and a reader schema (the receiving application).
Please take a moment to read <link xl:href="https://avro.apache.org/docs/1.7.6/spec.html">the Avro terminology</link> and understand the process.
Spring Cloud Stream will always fetch the writer schema to determine how to read a message. If you want to get Avro&#8217;s schema evolution support working you need to make sure that a readerSchema was properly set for your application.</simpara>
</note>
</section>
</section>
</chapter>
<chapter xml:id="_inter_application_communication">
<title>Inter-Application Communication</title>
<section xml:id="_connecting_multiple_application_instances">
<title>Connecting Multiple Application Instances</title>
<simpara>While Spring Cloud Stream makes it easy for individual Spring Boot applications to connect to messaging systems, the typical scenario for Spring Cloud Stream is the creation of multi-application pipelines, where microservice applications send data to each other.
You can achieve this scenario by correlating the input and output destinations of adjacent applications.</simpara>
<simpara>Supposing that a design calls for the Time Source application to send data to the Log Sink application, you can use a common destination named <literal>ticktock</literal> for bindings within both applications.</simpara>
<simpara>Time Source (that has the channel name <literal>output</literal>) will set the following property:</simpara>
<screen>spring.cloud.stream.bindings.output.destination=ticktock</screen>
<simpara>Log Sink (that has the channel name <literal>input</literal>) will set the following property:</simpara>
<screen>spring.cloud.stream.bindings.input.destination=ticktock</screen>
</section>
<section xml:id="_instance_index_and_instance_count">
<title>Instance Index and Instance Count</title>
<simpara>When scaling up Spring Cloud Stream applications, each instance can receive information about how many other instances of the same application exist and what its own instance index is.
Spring Cloud Stream does this through the <literal>spring.cloud.stream.instanceCount</literal> and <literal>spring.cloud.stream.instanceIndex</literal> properties.
For example, if there are three instances of a HDFS sink application, all three instances will have <literal>spring.cloud.stream.instanceCount</literal> set to <literal>3</literal>, and the individual applications will have <literal>spring.cloud.stream.instanceIndex</literal> set to <literal>0</literal>, <literal>1</literal>, and <literal>2</literal>, respectively.</simpara>
<simpara>When Spring Cloud Stream applications are deployed via Spring Cloud Data Flow, these properties are configured automatically; when Spring Cloud Stream applications are launched independently, these properties must be set correctly.
By default, <literal>spring.cloud.stream.instanceCount</literal> is <literal>1</literal>, and <literal>spring.cloud.stream.instanceIndex</literal> is <literal>0</literal>.</simpara>
<simpara>In a scaled-up scenario, correct configuration of these two properties is important for addressing partitioning behavior (see below) in general, and the two properties are always required by certain binders (e.g., the Kafka binder) in order to ensure that data are split correctly across multiple consumer instances.</simpara>
</section>
<section xml:id="_partitioning">
<title>Partitioning</title>
<section xml:id="_configuring_output_bindings_for_partitioning">
<title>Configuring Output Bindings for Partitioning</title>
<simpara>An output binding is configured to send partitioned data by setting one and only one of its <literal>partitionKeyExpression</literal> or <literal>partitionKeyExtractorClass</literal> properties, as well as its <literal>partitionCount</literal> property.
For example, the following is a valid and typical configuration:</simpara>
<screen>spring.cloud.stream.bindings.output.producer.partitionKeyExpression=payload.id
spring.cloud.stream.bindings.output.producer.partitionCount=5</screen>
<simpara>Based on the above example configuration, data will be sent to the target partition using the following logic.</simpara>
<simpara>A partition key&#8217;s value is calculated for each message sent to a partitioned output channel based on the <literal>partitionKeyExpression</literal>.
The <literal>partitionKeyExpression</literal> is a SpEL expression which is evaluated against the outbound message for extracting the partitioning key.</simpara>
<simpara>If a SpEL expression is not sufficient for your needs, you can instead calculate the partition key value by setting the property <literal>partitionKeyExtractorClass</literal> to a class which implements the <literal>org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy</literal> interface.
While the SpEL expression should usually suffice, more complex cases may use the custom implementation strategy.
In that case, the property 'partitionKeyExtractorClass' can be set as follows:</simpara>
<screen>spring.cloud.stream.bindings.output.producer.partitionKeyExtractorClass=com.example.MyKeyExtractor
spring.cloud.stream.bindings.output.producer.partitionCount=5</screen>
<simpara>Once the message key is calculated, the partition selection process will determine the target partition as a value between <literal>0</literal> and <literal>partitionCount - 1</literal>.
The default calculation, applicable in most scenarios, is based on the formula <literal>key.hashCode() % partitionCount</literal>.
This can be customized on the binding, either by setting a SpEL expression to be evaluated against the 'key' (via the <literal>partitionSelectorExpression</literal> property) or by setting a <literal>org.springframework.cloud.stream.binder.PartitionSelectorStrategy</literal> implementation (via the <literal>partitionSelectorClass</literal> property).</simpara>
<simpara>The binding level properties for 'partitionSelectorExpression' and 'partitionSelectorClass' can be specified similar to the way 'partitionKeyExpression' and 'partitionKeyExtractorClass' properties are specified in the above examples.
Additional properties can be configured for more advanced scenarios, as described in the following section.</simpara>
<section xml:id="_spring_managed_custom_literal_partitionkeyextractorclass_literal_implementations">
<title>Spring-managed custom <literal>PartitionKeyExtractorClass</literal> implementations</title>
<simpara>In the example above, a custom strategy such as <literal>MyKeyExtractor</literal> is instantiated by the Spring Cloud Stream directly.
In some cases, it is necessary for such a custom strategy implementation to be created as a Spring bean, for being able to be managed by Spring, so that it can perform dependency injection, property binding, etc.
This can be done by configuring it as a @Bean in the application context and using the fully qualified class name as the bean&#8217;s name, as in the following example.</simpara>
<screen>@Bean(name="com.example.MyKeyExtractor")
public MyKeyExtractor extractor() {
    return new MyKeyExtractor();
}</screen>
<simpara>As a Spring bean, the custom strategy benefits from the full lifecycle of a Spring bean.
For example, if the implementation need access to the application context directly, it can make implement 'ApplicationContextAware'.</simpara>
</section>
<section xml:id="_configuring_input_bindings_for_partitioning">
<title>Configuring Input Bindings for Partitioning</title>
<simpara>An input binding (with the channel name <literal>input</literal>) is configured to receive partitioned data by setting its <literal>partitioned</literal> property, as well as the <literal>instanceIndex</literal> and <literal>instanceCount</literal> properties on the application itself, as in the following example:</simpara>
<screen>spring.cloud.stream.bindings.input.consumer.partitioned=true
spring.cloud.stream.instanceIndex=3
spring.cloud.stream.instanceCount=5</screen>
<simpara>The <literal>instanceCount</literal> value represents the total number of application instances between which the data need to be partitioned, and the <literal>instanceIndex</literal> must be a unique value across the multiple instances, between <literal>0</literal> and <literal>instanceCount - 1</literal>.
The instance index helps each application instance to identify the unique partition (or, in the case of Kafka, the partition set) from which it receives data.
It is important to set both values correctly in order to ensure that all of the data is consumed and that the application instances receive mutually exclusive datasets.</simpara>
<simpara>While a scenario which using multiple instances for partitioned data processing may be complex to set up in a standalone case, Spring Cloud Dataflow can simplify the process significantly by populating both the input and output values correctly as well as relying on the runtime infrastructure to provide information about the instance index and instance count.</simpara>
</section>
</section>
</section>
</chapter>
<chapter xml:id="_testing">
<title>Testing</title>
<simpara>Spring Cloud Stream provides support for testing your microservice applications without connecting to a messaging system.
You can do that by using the <literal>TestSupportBinder</literal> provided by the <literal>spring-cloud-stream-test-support</literal> library, which can be added as a test dependency to the application:</simpara>
<programlisting language="xml" linenumbering="unnumbered">   &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-stream-test-support&lt;/artifactId&gt;
       &lt;scope&gt;test&lt;/scope&gt;
   &lt;/dependency&gt;</programlisting>
<note>
<simpara>The <literal>TestSupportBinder</literal> uses the Spring Boot autoconfiguration mechanism to supersede the other binders found on the classpath.
Therefore, when adding a binder as a dependency, make sure that the <literal>test</literal> scope is being used.</simpara>
</note>
<simpara>The <literal>TestSupportBinder</literal> allows users to interact with the bound channels and inspect what messages are sent and received by the application</simpara>
<simpara>For outbound message channels, the <literal>TestSupportBinder</literal> registers a single subscriber and retains the messages emitted by the application in a <literal>MessageCollector</literal>.
They can be retrieved during tests and have assertions made against them.</simpara>
<simpara>The user can also send messages to inbound message channels, so that the consumer application can consume the messages.
The following example shows how to test both input and output channels on a processor.</simpara>
<programlisting language="java" linenumbering="unnumbered">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment= SpringBootTest.WebEnvironment.RANDOM_PORT)
public class ExampleTest {

  @Autowired
  private Processor processor;

  @Autowired
  private MessageCollector messageCollector;

  @Test
  @SuppressWarnings("unchecked")
  public void testWiring() {
    Message&lt;String&gt; message = new GenericMessage&lt;&gt;("hello");
    processor.input().send(message);
    Message&lt;String&gt; received = (Message&lt;String&gt;) messageCollector.forChannel(processor.output()).poll();
    assertThat(received.getPayload(), equalTo("hello world"));
  }


  @SpringBootApplication
  @EnableBinding(Processor.class)
  public static class MyProcessor {

    @Autowired
    private Processor channels;

    @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
    public String transform(String in) {
      return in + " world";
    }
  }
}</programlisting>
<simpara>In the example above, we are creating an application that has an input and an output channel, bound through the <literal>Processor</literal> interface.
The bound interface is injected into the test so we can have access to both channels.
We are sending a message on the input channel and we are using the <literal>MessageCollector</literal> provided by Spring Cloud Stream&#8217;s test support to capture the message has been sent to the output channel as a result.
Once we have received the message, we can validate that the component functions correctly.</simpara>
<section xml:id="_disabling_the_test_binder_autoconfiguration">
<title>Disabling the test binder autoconfiguration</title>
<simpara>The intent behind the test binder superseding all the other binders on the classpath is to make it easy to test your applications without making changes to your production dependencies.
In some cases (e.g. integration tests) it is useful to use the actual production binders instead, and that requires disabling the test binder autoconfiguration.
In order to do so, you can exclude the <literal>org.springframework.cloud.stream.test.binder.TestSupportBinderAutoConfiguration</literal> class using one of the Spring Boot autoconfiguration exclusion mechanisms, as in the following example.</simpara>
<programlisting language="java" linenumbering="unnumbered">	@SpringBootApplication(exclude = TestSupportBinderAutoConfiguration.class)
	@EnableBinding(Processor.class)
	public static class MyProcessor {

		@Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
		public String transform(String in) {
			return in + " world";
		}
	}</programlisting>
<simpara>When autoconfiguration is disabled, the test binder is available on the classpath, and its <literal>defaultCandidate</literal> property is set to <literal>false</literal>, so that it does not interfere with the regular user configuration. It can be referenced under the name <literal>test</literal> e.g.:</simpara>
<screen>spring.cloud.stream.defaultBinder=test</screen>
</section>
</chapter>
<chapter xml:id="_health_indicator_5">
<title>Health Indicator</title>
<simpara>Spring Cloud Stream provides a health indicator for binders.
It is registered under the name of <literal>binders</literal> and can be enabled or disabled by setting the <literal>management.health.binders.enabled</literal> property.</simpara>
</chapter>
<chapter xml:id="_metrics_emitter">
<title>Metrics Emitter</title>
<simpara>Spring Cloud Stream provides a module called <literal>spring-cloud-stream-metrics</literal> that can be used to emit any available metric from <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html">Spring Boot metrics endpoint</link> to a named channel.
This module allow operators to collect metrics from stream applications without relying on polling their endpoints.</simpara>
<simpara>The module is activated when you set the destination name for metrics binding, e.g. <literal>spring.cloud.stream.bindings.applicationMetrics.destination=&lt;DESTINATION_NAME&gt;</literal>.
<literal>applicationMetrics</literal> can be configured in a similar fashion to any other producer binding.
The default <literal>contentType</literal> setting of <literal>applicationMetrics</literal> is <literal>application/json</literal>.</simpara>
<simpara>The following properties can be used for customizing the emission of metrics:</simpara>
<variablelist>
<varlistentry>
<term>spring.cloud.stream.metrics.key</term>
<listitem>
<simpara>The name of the metric being emitted. Should be an unique value per application.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default</term>
<listitem>
<simpara><literal>${spring.application.name:${vcap.application.name:${spring.config.name:application}}}</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.metrics.prefix</term>
<listitem>
<simpara>Prefix string to be prepended to the metrics key.</simpara>
<simpara>Default: ``</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.metrics.properties</term>
<listitem>
<simpara>Just like the <literal>includes</literal> option, it allows white listing application properties that will be added to the metrics payload</simpara>
<simpara>Default: null.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>A detailed overview of the metrics export process can be found in the <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html#production-ready-metric-writers">Spring Boot reference documentation</link>.
Spring Cloud Stream provides a metric exporter named <literal>application</literal> that can be configured via regular <link xl:href="https://github.com/spring-projects/spring-boot/blob/1.5.x/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/export/TriggerProperties.java">Spring Boot metrics configuration properties</link>.</simpara>
<simpara>The exporter can be configured either by using the global Spring Boot configuration settings for exporters, or by using exporter-specific properties.
For using the global configuration settings, the properties should be prefixed by <literal>spring.metric.export</literal> (e.g. <literal>spring.metric.export.includes=integration**</literal>).
These configuration options will apply to all exporters (unless they have been configured differently).
Alternatively, if it is intended to use configuration settings that are different from the other exporters (e.g. for restricting the number of metrics published), the Spring Cloud Stream provided metrics exporter can be configured using the prefix <literal>spring.metrics.export.triggers.application</literal> (e.g. <literal>spring.metrics.export.triggers.application.includes=integration**</literal>).</simpara>
<note>
<simpara>Due to Spring Boot&#8217;s <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-relaxed-binding">relaxed binding</link> the value of a property being included can be slightly different than the original value.</simpara>
<simpara>As a rule of thumb, the metric exporter will attempt to normalize all the properties in a consistent format using the dot notation (e.g. <literal>JAVA_HOME</literal> becomes <literal>java.home</literal>).</simpara>
<simpara>The goal of normalization is to make downstream consumers of those metrics capable of receiving property names consistently, regardless of how they are set on the monitored application (<literal>--spring.application.name</literal> or <literal>SPRING_APPLICATION_NAME</literal> would always yield <literal>spring.application.name</literal>).</simpara>
</note>
<simpara>Below is a sample of the data published to the channel in JSON format by the following command:</simpara>
<screen>java -jar time-source.jar \
    --spring.cloud.stream.bindings.applicationMetrics.destination=someMetrics \
    --spring.cloud.stream.metrics.properties=spring.application** \
    --spring.metrics.export.includes=integration.channel.input**,integration.channel.output**</screen>
<simpara>The resulting JSON is:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">{
   "name":"time-source",
   "metrics":[
      {
         "name":"integration.channel.output.errorRate.mean",
         "value":0.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.errorRate.max",
         "value":0.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.errorRate.min",
         "value":0.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.errorRate.stdev",
         "value":0.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.errorRate.count",
         "value":0.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendCount",
         "value":6.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendRate.mean",
         "value":0.994885872292989,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendRate.max",
         "value":1.006247080013156,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendRate.min",
         "value":1.0012035220116378,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendRate.stdev",
         "value":6.505181111084848E-4,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendRate.count",
         "value":6.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      }
   ],
   "createdTime":"2017-04-11T20:56:35.790Z",
   "properties":{
      "spring.application.name":"time-source",
      "spring.application.index":"0"
   }
}</programlisting>
</chapter>
<chapter xml:id="_samples">
<title>Samples</title>
<simpara>For Spring Cloud Stream samples, please refer to the <link xl:href="https://github.com/spring-cloud/spring-cloud-stream-samples">spring-cloud-stream-samples</link> repository on GitHub.</simpara>
</chapter>
<chapter xml:id="_getting_started">
<title>Getting Started</title>
<simpara>To get started with creating Spring Cloud Stream applications, visit the <link xl:href="https://start.spring.io">Spring Initializr</link> and create a new Maven project named "GreetingSource".
Select Spring Boot {supported-spring-boot-version} in the dropdown.
In the <emphasis>Search for dependencies</emphasis> text box type <literal>Stream Rabbit</literal> or <literal>Stream Kafka</literal> depending on what binder you want to use.</simpara>
<simpara>Next, create a new class, <literal>GreetingSource</literal>, in the same package as the <literal>GreetingSourceApplication</literal> class.
Give it the following code:</simpara>
<programlisting language="java" linenumbering="unnumbered">import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.integration.annotation.InboundChannelAdapter;

@EnableBinding(Source.class)
public class GreetingSource {

    @InboundChannelAdapter(Source.OUTPUT)
    public String greet() {
        return "hello world " + System.currentTimeMillis();
    }
}</programlisting>
<simpara>The <literal>@EnableBinding</literal> annotation is what triggers the creation of Spring Integration infrastructure components.
Specifically, it will create a Kafka connection factory, a Kafka outbound channel adapter, and the message channel defined inside the Source interface:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Source {

  String OUTPUT = "output";

  @Output(Source.OUTPUT)
  MessageChannel output();

}</programlisting>
<simpara>The auto-configuration also creates a default poller, so that the <literal>greet()</literal> method will be invoked once per second.
The standard Spring Integration <literal>@InboundChannelAdapter</literal> annotation sends a message to the source&#8217;s output channel, using the return value as the payload of the message.</simpara>
<simpara>To test-drive this setup, run a Kafka message broker.
An easy way to do this is to use a Docker image:</simpara>
<screen># On OS X
$ docker run -p 2181:2181 -p 9092:9092 --env ADVERTISED_HOST=`docker-machine ip \`docker-machine active\`` --env ADVERTISED_PORT=9092 spotify/kafka

# On Linux
$ docker run -p 2181:2181 -p 9092:9092 --env ADVERTISED_HOST=localhost --env ADVERTISED_PORT=9092 spotify/kafka</screen>
<simpara>Build the application:</simpara>
<screen>./mvnw clean package</screen>
<simpara>The consumer application is coded in a similar manner.
Go back to Initializr and create another project, named LoggingSink.
Then create a new class, <literal>LoggingSink</literal>, in the same package as the class <literal>LoggingSinkApplication</literal> and with the following code:</simpara>
<programlisting language="java" linenumbering="unnumbered">import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.cloud.stream.messaging.Sink;

@EnableBinding(Sink.class)
public class LoggingSink {

    @StreamListener(Sink.INPUT)
    public void log(String message) {
        System.out.println(message);
    }
}</programlisting>
<simpara>Build the application:</simpara>
<screen>./mvnw clean package</screen>
<simpara>To connect the GreetingSource application to the LoggingSink application, each application must share the same destination name.
Starting up both applications as shown below, you will see the consumer application printing "hello world" and a timestamp to the console:</simpara>
<screen>cd GreetingSource
java -jar target/GreetingSource-0.0.1-SNAPSHOT.jar --spring.cloud.stream.bindings.output.destination=mydest

cd LoggingSink
java -jar target/LoggingSink-0.0.1-SNAPSHOT.jar --server.port=8090 --spring.cloud.stream.bindings.input.destination=mydest</screen>
<simpara>(The different server port prevents collisions of the HTTP port used to service the Spring Boot Actuator endpoints in the two applications.)</simpara>
<simpara>The output of the LoggingSink application will look something like the following:</simpara>
<screen>[           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8090 (http)
[           main] com.example.LoggingSinkApplication       : Started LoggingSinkApplication in 6.828 seconds (JVM running for 7.371)
hello world 1458595076731
hello world 1458595077732
hello world 1458595078733
hello world 1458595079734
hello world 1458595080735</screen>
<section xml:id="_deploying_stream_applications_on_cloudfoundry">
<title>Deploying Stream applications on CloudFoundry</title>
<simpara>On CloudFoundry services are usually exposed via a special environment variable called <link xl:href="https://docs.cloudfoundry.org/devguide/deploy-apps/environment-variable.html#VCAP-SERVICES">VCAP_SERVICES</link>.</simpara>
<simpara>When configuring your binder connections, you can use the values from an environment variable as explained on the <link xl:href="https://docs.spring.io/spring-cloud-dataflow-server-cloudfoundry/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-ups">dataflow cloudfoundry server</link> docs.</simpara>
</section>
</chapter>
</part>
<part xml:id="_binder_implementations">
<title>Binder Implementations</title>
<chapter xml:id="_apache_kafka_binder">
<title>Apache Kafka Binder</title>

<section xml:id="_usage">
<title>Usage</title>
<simpara>For using the Apache Kafka binder, you just need to add it to your Spring Cloud Stream application, using the following Maven coordinates:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-stream-binder-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting>
<simpara>Alternatively, you can also use the Spring Cloud Stream Kafka Starter.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-stream-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting>
</section>
<section xml:id="_apache_kafka_binder_overview">
<title>Apache Kafka Binder Overview</title>
<simpara>A simplified diagram of how the Apache Kafka binder operates can be seen below.</simpara>
<figure>
<title>Kafka Binder</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/kafka-binder.png" contentwidth="300" width="50%" scalefit="1"/>
</imageobject>
<textobject><phrase>kafka binder</phrase></textobject>
</mediaobject>
</figure>
<simpara>The Apache Kafka Binder implementation maps each destination to an Apache Kafka topic.
The consumer group maps directly to the same Apache Kafka concept.
Partitioning also maps directly to Apache Kafka partitions as well.</simpara>
</section>
<section xml:id="_configuration_options_2">
<title>Configuration Options</title>
<simpara>This section contains the configuration options used by the Apache Kafka binder.</simpara>
<simpara>For common configuration options and properties pertaining to binder, refer to the <link linkend="binding-properties">core documentation</link>.</simpara>
<section xml:id="_kafka_binder_properties">
<title>Kafka Binder Properties</title>
<variablelist>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.brokers</term>
<listitem>
<simpara>A list of brokers to which the Kafka binder will connect.</simpara>
<simpara>Default: <literal>localhost</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.defaultBrokerPort</term>
<listitem>
<simpara>  <literal>brokers</literal> allows hosts specified with or without port information (e.g., <literal>host1,host2:port2</literal>).
This sets the default port when no port is configured in the broker list.</simpara>
<simpara>Default: <literal>9092</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.zkNodes</term>
<listitem>
<simpara>A list of ZooKeeper nodes to which the Kafka binder can connect.</simpara>
<simpara>Default: <literal>localhost</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.defaultZkPort</term>
<listitem>
<simpara>  <literal>zkNodes</literal> allows hosts specified with or without port information (e.g., <literal>host1,host2:port2</literal>).
This sets the default port when no port is configured in the node list.</simpara>
<simpara>Default: <literal>2181</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.configuration</term>
<listitem>
<simpara>  Key/Value map of client properties (both producers and consumer) passed to all clients created by the binder.
Due to the fact that these properties will be used by both producers and consumers, usage should be restricted to common properties, especially security settings.</simpara>
<simpara>Default: Empty map.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.headers</term>
<listitem>
<simpara>The list of custom headers that will be transported by the binder.</simpara>
<simpara>Default: empty.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.healthTimeout</term>
<listitem>
<simpara>The time to wait to get partition information in seconds; default 60.
Health will report as down if this timer expires.</simpara>
<simpara>Default: 10.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.offsetUpdateTimeWindow</term>
<listitem>
<simpara>  The frequency, in milliseconds, with which offsets are saved.
Ignored if <literal>0</literal>.</simpara>
<simpara>Default: <literal>10000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.offsetUpdateCount</term>
<listitem>
<simpara>  The frequency, in number of updates, which which consumed offsets are persisted.
Ignored if <literal>0</literal>.
Mutually exclusive with <literal>offsetUpdateTimeWindow</literal>.</simpara>
<simpara>Default: <literal>0</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.requiredAcks</term>
<listitem>
<simpara>The number of required acks on the broker.</simpara>
<simpara>Default: <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.minPartitionCount</term>
<listitem>
<simpara>  Effective only if <literal>autoCreateTopics</literal> or <literal>autoAddPartitions</literal> is set.
The global minimum number of partitions that the binder will configure on topics on which it produces/consumes data.
It can be superseded by the <literal>partitionCount</literal> setting of the producer or by the value of <literal>instanceCount</literal> * <literal>concurrency</literal> settings of the producer (if either is larger).</simpara>
<simpara>Default: <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.replicationFactor</term>
<listitem>
<simpara>The replication factor of auto-created topics if <literal>autoCreateTopics</literal> is active.</simpara>
<simpara>Default: <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.autoCreateTopics</term>
<listitem>
<simpara>  If set to <literal>true</literal>, the binder will create new topics automatically.
If set to <literal>false</literal>, the binder will rely on the topics being already configured.
In the latter case, if the topics do not exist, the binder will fail to start.
Of note, this setting is independent of the <literal>auto.topic.create.enable</literal> setting of the broker and it does not influence it: if the server is set to auto-create topics, they may be created as part of the metadata retrieval request, with default broker settings.</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.autoAddPartitions</term>
<listitem>
<simpara>  If set to <literal>true</literal>, the binder will create add new partitions if required.
If set to <literal>false</literal>, the binder will rely on the partition size of the topic being already configured.
If the partition count of the target topic is smaller than the expected value, the binder will fail to start.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.socketBufferSize</term>
<listitem>
<simpara>Size (in bytes) of the socket buffer to be used by the Kafka consumers.</simpara>
<simpara>Default: <literal>2097152</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_kafka_consumer_properties">
<title>Kafka Consumer Properties</title>
<simpara>The following properties are available for Kafka consumers only and
must be prefixed with <literal>spring.cloud.stream.kafka.bindings.&lt;channelName&gt;.consumer.</literal>.</simpara>
<variablelist>
<varlistentry>
<term>autoRebalanceEnabled</term>
<listitem>
<simpara>When <literal>true</literal>, topic partitions will be automatically rebalanced between the members of a consumer group.
When <literal>false</literal>, each consumer will be assigned a fixed set of partitions based on <literal>spring.cloud.stream.instanceCount</literal> and <literal>spring.cloud.stream.instanceIndex</literal>.
This requires both <literal>spring.cloud.stream.instanceCount</literal> and <literal>spring.cloud.stream.instanceIndex</literal> properties to be set appropriately on each launched instance.
The property <literal>spring.cloud.stream.instanceCount</literal> must typically be greater than 1 in this case.</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>autoCommitOffset</term>
<listitem>
<simpara>  Whether to autocommit offsets when a message has been processed.
If set to <literal>false</literal>, a header with the key <literal>kafka_acknowledgment</literal> of the type <literal>org.springframework.kafka.support.Acknowledgment</literal> header will be present in the inbound message.
Applications may use this header for acknowledging messages.
See the examples section for details.
When this property is set to <literal>false</literal>, Kafka binder will set the ack mode to <literal>org.springframework.kafka.listener.AbstractMessageListenerContainer.AckMode.MANUAL</literal>.</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>autoCommitOnError</term>
<listitem>
<simpara>  Effective only if <literal>autoCommitOffset</literal> is set to <literal>true</literal>.
If set to <literal>false</literal> it suppresses auto-commits for messages that result in errors, and will commit only for successful messages, allows a stream to automatically replay from the last successfully processed message, in case of persistent failures.
If set to <literal>true</literal>, it will always auto-commit (if auto-commit is enabled).
If not set (default), it effectively has the same value as <literal>enableDlq</literal>, auto-committing erroneous messages if they are sent to a DLQ, and not committing them otherwise.</simpara>
<simpara>Default: not set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>recoveryInterval</term>
<listitem>
<simpara>The interval between connection recovery attempts, in milliseconds.</simpara>
<simpara>Default: <literal>5000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>startOffset</term>
<listitem>
<simpara>  The starting offset for new groups.
Allowed values: <literal>earliest</literal>, <literal>latest</literal>.
If the consumer group is set explicitly for the consumer 'binding' (via <literal>spring.cloud.stream.bindings.&lt;channelName&gt;.group</literal>), then 'startOffset' is set to <literal>earliest</literal>; otherwise it is set to <literal>latest</literal> for the <literal>anonymous</literal> consumer group.</simpara>
<simpara>Default: null (equivalent to <literal>earliest</literal>).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>enableDlq</term>
<listitem>
<simpara>When set to true, it will send enable DLQ behavior for the consumer.
By default, messages that result in errors will be forwarded to a topic named <literal>error.&lt;destination&gt;.&lt;group&gt;</literal>.
The DLQ topic name can be configurable via the property <literal>dlqName</literal>.
This provides an alternative option to the more common Kafka replay scenario for the case when the number of errors is relatively small and replaying the entire original topic may be too cumbersome.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>configuration</term>
<listitem>
<simpara>Map with a key/value pair containing generic Kafka consumer properties.</simpara>
<simpara>Default: Empty map.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqName</term>
<listitem>
<simpara>The name of the DLQ topic to receive the error messages.</simpara>
<simpara>Default: null (If not specified, messages that result in errors will be forwarded to a topic named <literal>error.&lt;destination&gt;.&lt;group&gt;</literal>).</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_kafka_producer_properties">
<title>Kafka Producer Properties</title>
<simpara>The following properties are available for Kafka producers only and
must be prefixed with <literal>spring.cloud.stream.kafka.bindings.&lt;channelName&gt;.producer.</literal>.</simpara>
<variablelist>
<varlistentry>
<term>bufferSize</term>
<listitem>
<simpara>Upper limit, in bytes, of how much data the Kafka producer will attempt to batch before sending.</simpara>
<simpara>Default: <literal>16384</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>sync</term>
<listitem>
<simpara>Whether the producer is synchronous.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>batchTimeout</term>
<listitem>
<simpara>  How long the producer will wait before sending in order to allow more messages to accumulate in the same batch.
(Normally the producer does not wait at all, and simply sends all the messages that accumulated while the previous send was in progress.) A non-zero value may increase throughput at the expense of latency.</simpara>
<simpara>Default: <literal>0</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>messageKeyExpression</term>
<listitem>
<simpara> A SpEL expression evaluated against the outgoing message used to populate the key of the produced Kafka message.
For example <literal>headers.key</literal> or <literal>payload.myKey</literal>.</simpara>
<simpara>Default: <literal>none</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>configuration</term>
<listitem>
<simpara>Map with a key/value pair containing generic Kafka producer properties.</simpara>
<simpara>Default: Empty map.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>The Kafka binder will use the <literal>partitionCount</literal> setting of the producer as a hint to create a topic with the given partition count (in conjunction with the <literal>minPartitionCount</literal>, the maximum of the two being the value being used).
Exercise caution when configuring both <literal>minPartitionCount</literal> for a binder and <literal>partitionCount</literal> for an application, as the larger value will be used.
If a topic already exists with a smaller partition count and <literal>autoAddPartitions</literal> is disabled (the default), then the binder will fail to start.
If a topic already exists with a smaller partition count and <literal>autoAddPartitions</literal> is enabled, new partitions will be added.
If a topic already exists with a larger number of partitions than the maximum of (<literal>minPartitionCount</literal> and <literal>partitionCount</literal>), the existing partition count will be used.</simpara>
</note>
</section>
<section xml:id="_usage_examples">
<title>Usage examples</title>
<simpara>In this section, we illustrate the use of the above properties for specific scenarios.</simpara>
<section xml:id="_example_setting_literal_autocommitoffset_literal_false_and_relying_on_manual_acking">
<title>Example: Setting <literal>autoCommitOffset</literal> false and relying on manual acking.</title>
<simpara>This example illustrates how one may manually acknowledge offsets in a consumer application.</simpara>
<simpara>This example requires that <literal>spring.cloud.stream.kafka.bindings.input.consumer.autoCommitOffset</literal> is set to false.
Use the corresponding input channel name for your example.</simpara>
<screen>@SpringBootApplication
@EnableBinding(Sink.class)
public class ManuallyAcknowdledgingConsumer {

 public static void main(String[] args) {
     SpringApplication.run(ManuallyAcknowdledgingConsumer.class, args);
 }

 @StreamListener(Sink.INPUT)
 public void process(Message&lt;?&gt; message) {
     Acknowledgment acknowledgment = message.getHeaders().get(KafkaHeaders.ACKNOWLEDGMENT, Acknowledgment.class);
     if (acknowledgment != null) {
         System.out.println("Acknowledgment provided");
         acknowledgment.acknowledge();
     }
 }
}</screen>
</section>
<section xml:id="_example_security_configuration">
<title>Example: security configuration</title>
<simpara>Apache Kafka 0.9 supports secure connections between client and brokers.
To take advantage of this feature, follow the guidelines in the <link xl:href="https://kafka.apache.org/090/documentation.html#security_configclients">Apache Kafka Documentation</link> as well as the Kafka 0.9 <link xl:href="https://docs.confluent.io/2.0.0/kafka/security.html">security guidelines from the Confluent documentation</link>.
Use the <literal>spring.cloud.stream.kafka.binder.configuration</literal> option to set security properties for all clients created by the binder.</simpara>
<simpara>For example, for setting <literal>security.protocol</literal> to <literal>SASL_SSL</literal>, set:</simpara>
<screen>spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_SSL</screen>
<simpara>All the other security properties can be set in a similar manner.</simpara>
<simpara>When using Kerberos, follow the instructions in the <link xl:href="https://kafka.apache.org/090/documentation.html#security_sasl_clientconfig">reference documentation</link> for creating and referencing the JAAS configuration.</simpara>
<simpara>Spring Cloud Stream supports passing JAAS configuration information to the application using a JAAS configuration file and using Spring Boot properties.</simpara>
<section xml:id="_using_jaas_configuration_files">
<title>Using JAAS configuration files</title>
<simpara>The JAAS, and (optionally) krb5 file locations can be set for Spring Cloud Stream applications by using system properties.
Here is an example of launching a Spring Cloud Stream application with SASL and Kerberos using a JAAS configuration file:</simpara>
<screen> java -Djava.security.auth.login.config=/path.to/kafka_client_jaas.conf -jar log.jar \
   --spring.cloud.stream.kafka.binder.brokers=secure.server:9092 \
   --spring.cloud.stream.kafka.binder.zkNodes=secure.zookeeper:2181 \
   --spring.cloud.stream.bindings.input.destination=stream.ticktock \
   --spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_PLAINTEXT</screen>
</section>
<section xml:id="_using_spring_boot_properties">
<title>Using Spring Boot properties</title>
<simpara>As an alternative to having a JAAS configuration file, Spring Cloud Stream provides a mechanism for setting up the JAAS configuration for Spring Cloud Stream applications using Spring Boot properties.</simpara>
<simpara>The following properties can be used for configuring the login context of the Kafka client.</simpara>
<variablelist>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.jaas.loginModule</term>
<listitem>
<simpara>The login module name. Not necessary to be set in normal cases.</simpara>
<simpara>Default: <literal>com.sun.security.auth.module.Krb5LoginModule</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.jaas.controlFlag</term>
<listitem>
<simpara>The control flag of the login module.</simpara>
<simpara>Default: <literal>required</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.kafka.binder.jaas.options</term>
<listitem>
<simpara>Map with a key/value pair containing the login module options.</simpara>
<simpara>Default: Empty map.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Here is an example of launching a Spring Cloud Stream application with SASL and Kerberos using Spring Boot configuration properties:</simpara>
<screen> java --spring.cloud.stream.kafka.binder.brokers=secure.server:9092 \
   --spring.cloud.stream.kafka.binder.zkNodes=secure.zookeeper:2181 \
   --spring.cloud.stream.bindings.input.destination=stream.ticktock \
   --spring.cloud.stream.kafka.binder.autoCreateTopics=false \
   --spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_PLAINTEXT \
   --spring.cloud.stream.kafka.binder.jaas.options.useKeyTab=true \
   --spring.cloud.stream.kafka.binder.jaas.options.storeKey=true \
   --spring.cloud.stream.kafka.binder.jaas.options.keyTab=/etc/security/keytabs/kafka_client.keytab \
   --spring.cloud.stream.kafka.binder.jaas.options.principal=kafka-client-1@EXAMPLE.COM</screen>
<simpara>This represents the equivalent of the following JAAS file:</simpara>
<screen>KafkaClient {
    com.sun.security.auth.module.Krb5LoginModule required
    useKeyTab=true
    storeKey=true
    keyTab="/etc/security/keytabs/kafka_client.keytab"
    principal="kafka-client-1@EXAMPLE.COM";
};</screen>
<simpara>If the topics required already exist on the broker, or will be created by an administrator, autocreation can be turned off and only client JAAS properties need to be sent. As an alternative to setting <literal>spring.cloud.stream.kafka.binder.autoCreateTopics</literal> you can simply remove the broker dependency from the application. See <xref linkend="exclude-admin-utils"/> for details.</simpara>
<note>
<simpara>Do not mix JAAS configuration files and Spring Boot properties in the same application.
If the <literal>-Djava.security.auth.login.config</literal> system property is already present, Spring Cloud Stream will ignore the Spring Boot properties.</simpara>
</note>
<note>
<simpara>Exercise caution when using the <literal>autoCreateTopics</literal> and <literal>autoAddPartitions</literal> if using Kerberos.
Usually applications may use principals that do not have administrative rights in Kafka and Zookeeper, and relying on Spring Cloud Stream to create/modify topics may fail.
In secure environments, we strongly recommend creating topics and managing ACLs administratively using Kafka tooling.</simpara>
</note>
</section>
</section>
<section xml:id="_using_the_binder_with_apache_kafka_0_10">
<title>Using the binder with Apache Kafka 0.10</title>
<simpara>The default Kafka support in Spring Cloud Stream Kafka binder is for Kafka version 0.10.1.1. The binder also supports connecting to other 0.10 based versions and 0.9 clients.
In order to do this, when you create the project that contains your application, include <literal>spring-cloud-starter-stream-kafka</literal> as you normally would do for the default binder.
Then add these dependencies at the top of the <literal>&lt;dependencies&gt;</literal> section in the pom.xml file to override the dependencies.</simpara>
<simpara>Here is an example for downgrading your application to 0.10.0.1. Since it is still on the 0.10 line, the default <literal>spring-kafka</literal> and <literal>spring-integration-kafka</literal> versions can be retained.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt;
  &lt;version&gt;0.10.0.1&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
  &lt;version&gt;0.10.0.1&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>Here is another example of using 0.9.0.1 version.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
  &lt;version&gt;1.0.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
  &lt;artifactId&gt;spring-integration-kafka&lt;/artifactId&gt;
  &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt;
  &lt;version&gt;0.9.0.1&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
  &lt;version&gt;0.9.0.1&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<note>
<simpara>The versions above are provided only for the sake of the example.
For best results, we recommend using the most recent 0.10-compatible versions of the projects.</simpara>
</note>
</section>
<section xml:id="exclude-admin-utils">
<title>Excluding Kafka broker jar from the classpath of the binder based application</title>
<simpara>The Apache Kafka Binder uses the administrative utilities which are part of the Apache Kafka server library to create and reconfigure topics.
If the inclusion of the Apache Kafka server library and its dependencies is not necessary at runtime because the application will rely on the topics being configured administratively, the Kafka binder allows for Apache Kafka server dependency to be excluded from the application.</simpara>
<simpara>If you use non default versions for Kafka dependencies as advised above, all you have to do is not to include the kafka broker dependency.
If you use the default Kafka version, then ensure that you exclude the kafka broker jar from the <literal>spring-cloud-starter-stream-kafka</literal> dependency as following.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-stream-kafka&lt;/artifactId&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
      &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;</programlisting>
<simpara>If you exclude the Apache Kafka server dependency and the topic is not present on the server, then the Apache Kafka broker will create the topic if auto topic creation is enabled on the server.
Please keep in mind that if you are relying on this, then the Kafka server will use the default number of partitions and replication factors.
On the other hand, if auto topic creation is disabled on the server, then care must be taken before running the application to create the topic with the desired number of partitions.</simpara>
<simpara>If you want to have full control over how partitions are allocated, then leave the default settings as they are, i.e. do not exclude the kafka broker jar and ensure that <literal>spring.cloud.stream.kafka.binder.autoCreateTopics</literal> is set to <literal>true</literal>, which is the default.</simpara>
</section>
</section>
</section>
<section xml:id="_kafka_streams_binding_capabilities_of_spring_cloud_stream">
<title>Kafka Streams Binding Capabilities of Spring Cloud Stream</title>
<simpara>Spring Cloud Stream Kafka support also includes a binder specifically designed for Kafka Streams binding.
Using this binder, applications can be written that leverage the Kafka Streams API.
For more information on Kafka Streams, see <link xl:href="https://kafka.apache.org/documentation/streams/developer-guide">Kafka Streams API Developer Manual</link></simpara>
<simpara>Kafka Streams support in Spring Cloud Stream is based on the foundations provided by the Spring Kafka project. For details on that support, see <link xl:href="https://docs.spring.io/spring-kafka/reference/html/_reference.html#kafka-streams">Kafaka Streams Support in Spring Kafka</link>.</simpara>
<simpara>Here are the maven coordinates for the Spring Cloud Stream KStream binder artifact.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-stream-binder-kstream&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting>
<simpara>In addition to leveraging the Spring Cloud Stream programming model which is based on Spring Boot, one of the main other benefits that the KStream binder provides is the fact that it avoids the boilerplate configuration that one needs to write when using the Kafka Streams API directly.
High level streams DSL provided through the Kafka Streams API can be used through Spring Cloud Stream in the current support.</simpara>
<section xml:id="_usage_example_of_high_level_streams_dsl">
<title>Usage example of high level streams DSL</title>
<simpara>This application will listen from a Kafka topic and write the word count for each unique word that it sees in a 5 seconds time window.</simpara>
<screen>@SpringBootApplication
@EnableBinding(KStreamProcessor.class)
public class WordCountProcessorApplication {

	@StreamListener("input")
	@SendTo("output")
	public KStream&lt;?, String&gt; process(KStream&lt;?, String&gt; input) {
		return input
				.flatMapValues(value -&gt; Arrays.asList(value.toLowerCase().split("\\W+")))
				.map((key, word) -&gt; new KeyValue&lt;&gt;(word, word))
				.groupByKey(Serdes.String(), Serdes.String())
				.count(TimeWindows.of(5000), "store-name")
				.toStream()
				.map((w, c) -&gt; new KeyValue&lt;&gt;(null, "Count for " + w.key() + ": " + c));
	}

	public static void main(String[] args) {
		SpringApplication.run(WordCountProcessorApplication.class, args);
	}</screen>
<simpara>If you build it as Spring Boot runnable fat jar, you can run the above example in the following way:</simpara>
<screen>java -jar uber.jar  --spring.cloud.stream.bindings.input.destination=words --spring.cloud.stream.bindings.output.destination=counts</screen>
<simpara>This means that the application will listen from the incoming Kafka topic words and write to the output topic counts.</simpara>
<simpara>Spring Cloud Stream will ensure that the messages from both the incoming and outgoing topics are bound as KStream objects.
As one may observe, the developer can exclusively focus on the business aspects of the code, i.e. writing the logic required in the processor rather than setting up the streams specific configuration required by the Kafka Streams infrastructure.
All those boilerplate is handled by Spring Cloud Stream behind the scenes.</simpara>
</section>
<section xml:id="_support_for_interactive_queries">
<title>Support for interactive queries</title>
<simpara>If access to the <literal>KafkaStreams</literal> is needed for interactive queries, the internal <literal>KafkaStreams</literal> instance can be accessed via <literal>KStreamBuilderFactoryBean.getKafkaStreams()</literal>.
You can autowire the <literal>KStreamBuilderFactoryBean</literal> instance provided by the KStream binder. Then you can get <literal>KafkaStreams</literal> instance from it and retrieve the underlying store, execute queries on it, etc.</simpara>
</section>
<section xml:id="_kafka_streams_properties">
<title>Kafka Streams properties</title>
<variablelist>
<varlistentry>
<term>configuration</term>
<listitem>
<simpara>Map with a key/value pair containing properties pertaining to Kafka Streams API.
This property must be prefixed with <literal>spring.cloud.stream.kstream.binder.</literal>.</simpara>
<literallayout class="monospaced">Following are some examples of using this property.</literallayout>
</listitem>
</varlistentry>
</variablelist>
<screen>spring.cloud.stream.kstream.binder.configuration.key.serde=org.apache.kafka.common.serialization.Serdes$StringSerde
spring.cloud.stream.kstream.binder.configuration.value.serde=org.apache.kafka.common.serialization.Serdes$StringSerde
spring.cloud.stream.kstream.binder.configuration.commit.interval.ms=1000</screen>
<literallayout class="monospaced">For more information about all the properties that may go into streams configuration, see StreamsConfig JavaDocs.</literallayout>
<simpara>There can also be binding specific properties.</simpara>
<simpara>For instance, you can use a different Serde for your input or output destination.</simpara>
<screen>spring.cloud.stream.kstream.bindings.output.producer.keySerde=org.apache.kafka.common.serialization.Serdes$IntegerSerde
spring.cloud.stream.kstream.bindings.output.producer.valueSerde=org.apache.kafka.common.serialization.Serdes$LongSerde</screen>
<variablelist>
<varlistentry>
<term>timewindow.length</term>
<listitem>
<simpara>Many streaming applications written using Kafka Streams involve windowning operations.
If you specify this property, there is a <literal>org.apache.kafka.streams.kstream.TimeWindows</literal> bean automatically provided that can be autowired in applications.
This property must be prefixed with <literal>spring.cloud.stream.kstream.</literal>.
A bean of type <literal>org.apache.kafka.streams.kstream.TimeWindows</literal> is created only if this property is provided.</simpara>
<literallayout class="monospaced">Following is an example of using this property.
Values are provided in milliseconds.</literallayout>
</listitem>
</varlistentry>
</variablelist>
<screen>spring.cloud.stream.kstream.timeWindow.length=5000</screen>
<variablelist>
<varlistentry>
<term>timewindow.advanceBy</term>
<listitem>
<simpara>This property goes hand in hand with <literal>timewindow.length</literal> and has no effect on its own.
If you provide this property, the generated <literal>org.apache.kafka.streams.kstream.TimeWindows</literal> bean will automatically conatin this information.
This property must be prefixed with <literal>spring.cloud.stream.kstream.</literal>.</simpara>
<literallayout class="monospaced">Following is an example of using this property.
Values are provided in milliseconds.</literallayout>
</listitem>
</varlistentry>
</variablelist>
<screen>spring.cloud.stream.kstream.timeWindow.advanceBy=1000</screen>
</section>
</section>
<section xml:id="kafka-error-channels">
<title>Error Channels</title>
<simpara>Starting with <emphasis>version 1.3</emphasis>, the binder unconditionally sends exceptions to an error channel for each consumer destination, and can be configured to send async producer send failures to an error channel too.
See <xref linkend="binder-error-channels"/> for more information.</simpara>
<simpara>The payload of the <literal>ErrorMessage</literal> for a send failure is a <literal>KafkaSendFailureException</literal> with properties:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>failedMessage</literal> - the spring-messaging <literal>Message&lt;?&gt;</literal> that failed to be sent.</simpara>
</listitem>
<listitem>
<simpara><literal>record</literal> - the raw <literal>ProducerRecord</literal> that was created from the <literal>failedMessage</literal></simpara>
</listitem>
</itemizedlist>
<simpara>There is no automatic handling of these exceptions (such as sending to a <link linkend="kafka-dlq-processing">Dead-Letter queue</link>); you can consume these exceptions with your own Spring Integration flow.</simpara>
</section>
<section xml:id="kafka-metrics">
<title>Kafka Metrics</title>
<simpara>Kafka binder module exposes the following metrics:</simpara>
<simpara><literal>spring.cloud.stream.binder.kafka.someGroup.someTopic.lag</literal>  - this metric indicates how many messages have not been yet consumed from given binder&#8217;s topic by given consumer group.
For example if the value of the metric <literal>spring.cloud.stream.binder.kafka.myGroup.myTopic.lag</literal> is <literal>1000</literal>, then consumer group <literal>myGroup</literal> has <literal>1000</literal> messages to waiting to be consumed from topic <literal>myTopic</literal>.
This metric is particularly useful to provide auto-scaling feedback to PaaS platform of your choice.</simpara>
</section>
<section xml:id="kafka-dlq-processing">
<title>Dead-Letter Topic Processing</title>
<simpara>Because it can&#8217;t be anticipated how users would want to dispose of dead-lettered messages, the framework does not provide any standard mechanism to handle them.
If the reason for the dead-lettering is transient, you may wish to route the messages back to the original topic.
However, if the problem is a permanent issue, that could cause an infinite loop.
The following <literal>spring-boot</literal> application is an example of how to route those messages back to the original topic, but moves them to a third "parking lot" topic after three attempts.
The application is simply another spring-cloud-stream application that reads from the dead-letter topic.
It terminates when no messages are received for 5 seconds.</simpara>
<simpara>The examples assume the original destination is <literal>so8400out</literal> and the consumer group is <literal>so8400</literal>.</simpara>
<simpara>There are several considerations.</simpara>
<itemizedlist>
<listitem>
<simpara>Consider only running the rerouting when the main application is not running.
Otherwise, the retries for transient errors will be used up very quickly.</simpara>
</listitem>
<listitem>
<simpara>Alternatively, use a two-stage approach - use this application to route to a third topic, and another to route from there back to the main topic.</simpara>
</listitem>
<listitem>
<simpara>Since this technique uses a message header to keep track of retries, it won&#8217;t work with <literal>headerMode=raw</literal>.
In that case, consider adding some data to the payload (that can be ignored by the main application).</simpara>
</listitem>
<listitem>
<simpara><literal>x-retries</literal> has to be added to the <literal>headers</literal> property <literal>spring.cloud.stream.kafka.binder.headers=x-retries</literal> on both this, and the main application so that the header is transported between the applications.</simpara>
</listitem>
<listitem>
<simpara>Since kafka is publish/subscribe, replayed messages will be sent to each consumer group, even those that successfully processed a message the first time around.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>application.properties</title>
<para>
<screen>spring.cloud.stream.bindings.input.group=so8400replay
spring.cloud.stream.bindings.input.destination=error.so8400out.so8400

spring.cloud.stream.bindings.output.destination=so8400out
spring.cloud.stream.bindings.output.producer.partitioned=true

spring.cloud.stream.bindings.parkingLot.destination=so8400in.parkingLot
spring.cloud.stream.bindings.parkingLot.producer.partitioned=true

spring.cloud.stream.kafka.binder.configuration.auto.offset.reset=earliest

spring.cloud.stream.kafka.binder.headers=x-retries</screen>
</para>
</formalpara>
<formalpara>
<title>Application</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableBinding(TwoOutputProcessor.class)
public class ReRouteDlqKApplication implements CommandLineRunner {

    private static final String X_RETRIES_HEADER = "x-retries";

    public static void main(String[] args) {
        SpringApplication.run(ReRouteDlqKApplication.class, args).close();
    }

    private final AtomicInteger processed = new AtomicInteger();

    @Autowired
    private MessageChannel parkingLot;

    @StreamListener(Processor.INPUT)
    @SendTo(Processor.OUTPUT)
    public Message&lt;?&gt; reRoute(Message&lt;?&gt; failed) {
        processed.incrementAndGet();
        Integer retries = failed.getHeaders().get(X_RETRIES_HEADER, Integer.class);
        if (retries == null) {
            System.out.println("First retry for " + failed);
            return MessageBuilder.fromMessage(failed)
                    .setHeader(X_RETRIES_HEADER, new Integer(1))
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build();
        }
        else if (retries.intValue() &lt; 3) {
            System.out.println("Another retry for " + failed);
            return MessageBuilder.fromMessage(failed)
                    .setHeader(X_RETRIES_HEADER, new Integer(retries.intValue() + 1))
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build();
        }
        else {
            System.out.println("Retries exhausted for " + failed);
            parkingLot.send(MessageBuilder.fromMessage(failed)
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build());
        }
        return null;
    }

    @Override
    public void run(String... args) throws Exception {
        while (true) {
            int count = this.processed.get();
            Thread.sleep(5000);
            if (count == this.processed.get()) {
                System.out.println("Idle, terminating");
                return;
            }
        }
    }

    public interface TwoOutputProcessor extends Processor {

        @Output("parkingLot")
        MessageChannel parkingLot();

    }

}</programlisting>
</para>
</formalpara>
</section>
</chapter>
<chapter xml:id="_rabbitmq_binder">
<title>RabbitMQ Binder</title>

<section xml:id="_usage_2">
<title>Usage</title>
<simpara>For using the RabbitMQ binder, you just need to add it to your Spring Cloud Stream application, using the following Maven coordinates:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting>
<simpara>Alternatively, you can also use the Spring Cloud Stream RabbitMQ Starter.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting>
</section>
<section xml:id="_rabbitmq_binder_overview">
<title>RabbitMQ Binder Overview</title>
<simpara>A simplified diagram of how the RabbitMQ binder operates can be seen below.</simpara>
<figure>
<title>RabbitMQ Binder</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/rabbit-binder.png" contentwidth="300" width="50%" scalefit="1"/>
</imageobject>
<textobject><phrase>rabbit binder</phrase></textobject>
</mediaobject>
</figure>
<simpara>The RabbitMQ Binder implementation maps each destination to a <literal>TopicExchange</literal>.
For each consumer group, a <literal>Queue</literal> will be bound to that <literal>TopicExchange</literal>.
Each consumer instance have a corresponding RabbitMQ <literal>Consumer</literal> instance for its group&#8217;s <literal>Queue</literal>.
For partitioned producers/consumers the queues are suffixed with the partition index and use the partition index as routing key.</simpara>
<simpara>Using the <literal>autoBindDlq</literal> option, you can optionally configure the binder to create and configure dead-letter queues (DLQs) (and a dead-letter exchange <literal>DLX</literal>).
The dead letter queue has the name of the destination, appended with <literal>.dlq</literal>.
If retry is enabled (<literal>maxAttempts &gt; 1</literal>) failed messages will be delivered to the DLQ.
If retry is disabled (<literal>maxAttempts = 1</literal>), you should set <literal>requeueRejected</literal> to <literal>false</literal> (default) so that a failed message will be routed to the DLQ, instead of being requeued.
In addition, <literal>republishToDlq</literal> causes the binder to publish a failed message to the DLQ (instead of rejecting it); this enables additional information to be added to the message in headers, such as the stack trace in the <literal>x-exception-stacktrace</literal> header.
This option does not need retry enabled; you can republish a failed message after just one attempt.
Starting with <emphasis>version 1.2</emphasis>, you can configure the delivery mode of republished messages; see property <literal>republishDeliveryMode</literal>.</simpara>
<important>
<simpara>Setting <literal>requeueRejected</literal> to <literal>true</literal> will cause the message to be requeued and redelivered continually, which is likely not what you want unless the failure issue is transient.
In general, it&#8217;s better to enable retry within the binder by setting <literal>maxAttempts</literal> to greater than one, or set <literal>republishToDlq</literal> to <literal>true</literal>.</simpara>
</important>
<simpara>See <xref linkend="rabbit-binder-properties"/> for more information about these properties.</simpara>
<simpara>The framework does not provide any standard mechanism to consume dead-letter messages (or to re-route them back to the primary queue).
Some options are described in <xref linkend="rabbit-dlq-processing"/>.</simpara>
<note>
<simpara>When <emphasis role="strong">multiple</emphasis> RabbitMQ binders are used in a Spring Cloud Stream application, it is important to disable 'RabbitAutoConfiguration' to avoid the same configuration from <literal>RabbitAutoConfiguration</literal> being applied to the two binders.</simpara>
</note>
<simpara>Starting with <emphasis>version 1.3</emphasis>, the <literal>RabbitMessageChannelBinder</literal> creates an internal <literal>ConnectionFactory</literal> copy for the non-transactional producers to avoid dead locks on consumers when shared, cached connections are blocked because of <link xl:href="https://www.rabbitmq.com/memory.html">Memory Alarm</link> on Broker.</simpara>
</section>
<section xml:id="_configuration_options_3">
<title>Configuration Options</title>
<simpara>This section contains settings specific to the RabbitMQ Binder and bound channels.</simpara>
<simpara>For general binding configuration options and properties,
please refer to the <link xl:href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-core-docs/src/main/asciidoc/spring-cloud-stream-overview.adoc#configuration-options">Spring Cloud Stream core documentation</link>.</simpara>
<section xml:id="rabbit-binder-properties">
<title>RabbitMQ Binder Properties</title>
<simpara>By default, the RabbitMQ binder uses Spring Boot&#8217;s <literal>ConnectionFactory</literal>, and it therefore supports all Spring Boot configuration options for RabbitMQ.
(For reference, consult the <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties">Spring Boot documentation</link>.)
RabbitMQ configuration options use the <literal>spring.rabbitmq</literal> prefix.</simpara>
<simpara>In addition to Spring Boot options, the RabbitMQ binder supports the following properties:</simpara>
<variablelist>
<varlistentry>
<term>spring.cloud.stream.rabbit.binder.adminAddresses</term>
<listitem>
<simpara>  A comma-separated list of RabbitMQ management plugin URLs.
Only used when <literal>nodes</literal> contains more than one entry.
Each entry in this list must have a corresponding entry in <literal>spring.rabbitmq.addresses</literal>.</simpara>
<simpara>Default: empty.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.rabbit.binder.nodes</term>
<listitem>
<simpara>  A comma-separated list of RabbitMQ node names.
When more than one entry, used to locate the server address where a queue is located.
Each entry in this list must have a corresponding entry in <literal>spring.rabbitmq.addresses</literal>.</simpara>
<simpara>Default: empty.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>spring.cloud.stream.rabbit.binder.compressionLevel</term>
<listitem>
<simpara>  Compression level for compressed bindings.
See <literal>java.util.zip.Deflater</literal>.</simpara>
<simpara>Default: <literal>1</literal> (BEST_LEVEL).</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_rabbitmq_consumer_properties">
<title>RabbitMQ Consumer Properties</title>
<simpara>The following properties are available for Rabbit consumers only and
must be prefixed with <literal>spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer.</literal>.</simpara>
<variablelist>
<varlistentry>
<term>acknowledgeMode</term>
<listitem>
<simpara>The acknowledge mode.</simpara>
<simpara>Default: <literal>AUTO</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>autoBindDlq</term>
<listitem>
<simpara>Whether to automatically declare the DLQ and bind it to the binder DLX.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>bindingRoutingKey</term>
<listitem>
<simpara>The routing key with which to bind the queue to the exchange (if <literal>bindQueue</literal> is <literal>true</literal>).
for partitioned destinations <literal>-&lt;instanceIndex&gt;</literal> will be appended.</simpara>
<simpara>Default: <literal>#</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>bindQueue</term>
<listitem>
<simpara>Whether to bind the queue to the destination exchange; set to <literal>false</literal> if you have set up your own infrastructure and have previously created/bound the queue.</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>deadLetterQueueName</term>
<listitem>
<simpara>name of the DLQ</simpara>
<simpara>Default: <literal>prefix+destination.dlq</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>deadLetterExchange</term>
<listitem>
<simpara>a DLX to assign to the queue; if autoBindDlq is true</simpara>
<simpara>Default: 'prefix+DLX'</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>deadLetterRoutingKey</term>
<listitem>
<simpara>a dead letter routing key to assign to the queue; if autoBindDlq is true</simpara>
<simpara>Default: <literal>destination</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>declareExchange</term>
<listitem>
<simpara>Whether to declare the exchange for the destination.</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>delayedExchange</term>
<listitem>
<simpara>Whether to declare the exchange as a <literal>Delayed Message Exchange</literal> - requires the delayed message exchange plugin on the broker.
The <literal>x-delayed-type</literal> argument is set to the <literal>exchangeType</literal>.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqDeadLetterExchange</term>
<listitem>
<simpara>if a DLQ is declared, a DLX to assign to that queue</simpara>
<simpara>Default: <literal>none</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqDeadLetterRoutingKey</term>
<listitem>
<simpara>if a DLQ is declared, a dead letter routing key to assign to that queue; default none</simpara>
<simpara>Default: <literal>none</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqExpires</term>
<listitem>
<simpara>how long before an unused dead letter queue is deleted (ms)</simpara>
<simpara>Default: <literal>no expiration</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqLazy</term>
<listitem>
<simpara>Declare the dead letter queue with the <literal>x-queue-mode=lazy</literal> argument.
See <link xl:href="https://www.rabbitmq.com/lazy-queues.html">Lazy Queues</link>.
Consider using a policy instead of this setting because using a policy allows changing the setting without deleting the queue.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqMaxLength</term>
<listitem>
<simpara>maximum number of messages in the dead letter queue</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqMaxLengthBytes</term>
<listitem>
<simpara>maximum number of total bytes in the dead letter queue from all messages</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqMaxPriority</term>
<listitem>
<simpara>maximum priority of messages in the dead letter queue (0-255)</simpara>
<simpara>Default: <literal>none</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqTtl</term>
<listitem>
<simpara>default time to live to apply to the dead letter queue when declared (ms)</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>durableSubscription</term>
<listitem>
<simpara>  Whether subscription should be durable.
Only effective if <literal>group</literal> is also set.</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>exchangeAutoDelete</term>
<listitem>
<simpara>If <literal>declareExchange</literal> is true, whether the exchange should be auto-delete (removed after the last queue is removed).</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>exchangeDurable</term>
<listitem>
<simpara>If <literal>declareExchange</literal> is true, whether the exchange should be durable (survives broker restart).</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>exchangeType</term>
<listitem>
<simpara>The exchange type; <literal>direct</literal>, <literal>fanout</literal> or <literal>topic</literal> for non-partitioned destinations; <literal>direct</literal> or <literal>topic</literal> for partitioned destinations.</simpara>
<simpara>Default: <literal>topic</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>exclusive</term>
<listitem>
<simpara>Create an exclusive consumer; concurrency should be 1 when this is <literal>true</literal>; often used when strict ordering is required but enabling a hot standby instance to take over after a failure.
See <literal>recoveryInterval</literal>, which controls how often a standby instance will attempt to consume.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>expires</term>
<listitem>
<simpara>how long before an unused queue is deleted (ms)</simpara>
<simpara>Default: <literal>no expiration</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>failedDeclarationRetryInterval</term>
<listitem>
<simpara>The interval (ms) between attempts to consume from a queue if it is missing.</simpara>
<simpara>Default: 5000</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>headerPatterns</term>
<listitem>
<simpara>Patterns for headers to be mapped from inbound messages.</simpara>
<simpara>Default: <literal>['*']</literal> (all headers).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>lazy</term>
<listitem>
<simpara>Declare the queue with the <literal>x-queue-mode=lazy</literal> argument.
See <link xl:href="https://www.rabbitmq.com/lazy-queues.html">Lazy Queues</link>.
Consider using a policy instead of this setting because using a policy allows changing the setting without deleting the queue.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>maxConcurrency</term>
<listitem>
<simpara>the maximum number of consumers</simpara>
<simpara>Default: <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>maxLength</term>
<listitem>
<simpara>maximum number of messages in the queue</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>maxLengthBytes</term>
<listitem>
<simpara>maximum number of total bytes in the queue from all messages</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>maxPriority</term>
<listitem>
<simpara>maximum priority of messages in the queue (0-255)</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default</term>
<listitem>
<simpara><literal>none</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>missingQueuesFatal</term>
<listitem>
<simpara>If the queue cannot be found, treat the condition as fatal and stop the listener container.
Defaults to <literal>false</literal> so that the container keeps trying to consume from the queue, for example when using a cluster and the node hosting a non HA queue is down.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default</term>
<listitem>
<simpara><literal>false</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>prefetch</term>
<listitem>
<simpara>Prefetch count.</simpara>
<simpara>Default: <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>prefix</term>
<listitem>
<simpara>A prefix to be added to the name of the <literal>destination</literal> and queues.</simpara>
<simpara>Default: "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>queueDeclarationRetries</term>
<listitem>
<simpara>The number of times to retry consuming from a queue if it is missing.
Only relevant if <literal>missingQueuesFatal</literal> is <literal>true</literal>; otherwise the container keeps retrying indefinitely.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default</term>
<listitem>
<simpara><literal>3</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>queueNameGroupOnly</term>
<listitem>
<simpara>When true, consume from a queue with a name equal to the <literal>group</literal>; otherwise the queue name is <literal>destination.group</literal>.
This is useful, for example, when using Spring Cloud Stream to consume from an existing RabbitMQ queue.</simpara>
<simpara>Default: false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>recoveryInterval</term>
<listitem>
<simpara>The interval between connection recovery attempts, in milliseconds.</simpara>
<simpara>Default: <literal>5000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>requeueRejected</term>
<listitem>
<simpara>Whether delivery failures should be requeued when retry is disabled or republishToDlq is false.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>republishDeliveryMode</term>
<listitem>
<simpara>When <literal>republishToDlq</literal> is <literal>true</literal>, specify the delivery mode of the republished message.</simpara>
<simpara>Default: <literal>DeliveryMode.PERSISTENT</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>republishToDlq</term>
<listitem>
<simpara>  By default, messages which fail after retries are exhausted are rejected.
If a dead-letter queue (DLQ) is configured, RabbitMQ will route the failed message (unchanged) to the DLQ.
If set to <literal>true</literal>, the binder will republish failed messages to the DLQ with additional headers, including the exception message and stack trace from the cause of the final failure.</simpara>
<simpara>Default: false</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>transacted</term>
<listitem>
<simpara>Whether to use transacted channels.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ttl</term>
<listitem>
<simpara>default time to live to apply to the queue when declared (ms)</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>txSize</term>
<listitem>
<simpara>The number of deliveries between acks.</simpara>
<simpara>Default: <literal>1</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_rabbit_producer_properties">
<title>Rabbit Producer Properties</title>
<simpara>The following properties are available for Rabbit producers only and
must be prefixed with <literal>spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.producer.</literal>.</simpara>
<variablelist>
<varlistentry>
<term>autoBindDlq</term>
<listitem>
<simpara>Whether to automatically declare the DLQ and bind it to the binder DLX.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>batchingEnabled</term>
<listitem>
<simpara>Whether to enable message batching by producers.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>batchSize</term>
<listitem>
<simpara>The number of messages to buffer when batching is enabled.</simpara>
<simpara>Default: <literal>100</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>batchBufferLimit</term>
<listitem>
<simpara>Default: <literal>10000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>batchTimeout</term>
<listitem>
<simpara>Default: <literal>5000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>bindingRoutingKey</term>
<listitem>
<simpara>The routing key with which to bind the queue to the exchange (if <literal>bindQueue</literal> is <literal>true</literal>).
Only applies to non-partitioned destinations.
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>#</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>bindQueue</term>
<listitem>
<simpara>Whether to bind the queue to the destination exchange; set to <literal>false</literal> if you have set up your own infrastructure and have previously created/bound the queue.
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>compress</term>
<listitem>
<simpara>Whether data should be compressed when sent.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>deadLetterQueueName</term>
<listitem>
<simpara>name of the DLQ
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>prefix+destination.dlq</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>deadLetterExchange</term>
<listitem>
<simpara>a DLX to assign to the queue; if autoBindDlq is true
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: 'prefix+DLX'</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>deadLetterRoutingKey</term>
<listitem>
<simpara>a dead letter routing key to assign to the queue; if autoBindDlq is true
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>destination</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>declareExchange</term>
<listitem>
<simpara>Whether to declare the exchange for the destination.</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>delay</term>
<listitem>
<simpara>A SpEL expression to evaluate the delay to apply to the message (<literal>x-delay</literal> header) - has no effect if the exchange is not a delayed message exchange.</simpara>
<simpara>Default: No <literal>x-delay</literal> header is set.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>delayedExchange</term>
<listitem>
<simpara>Whether to declare the exchange as a <literal>Delayed Message Exchange</literal> - requires the delayed message exchange plugin on the broker.
The <literal>x-delayed-type</literal> argument is set to the <literal>exchangeType</literal>.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>deliveryMode</term>
<listitem>
<simpara>Delivery mode.</simpara>
<simpara>Default: <literal>PERSISTENT</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqDeadLetterExchange</term>
<listitem>
<simpara>if a DLQ is declared, a DLX to assign to that queue
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>none</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqDeadLetterRoutingKey</term>
<listitem>
<simpara>if a DLQ is declared, a dead letter routing key to assign to that queue; default none
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>none</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqExpires</term>
<listitem>
<simpara>how long before an unused dead letter queue is deleted (ms)
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>no expiration</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqLazy</term>
<listitem>
<simpara>Declare the dead letter queue with the <literal>x-queue-mode=lazy</literal> argument.
See <link xl:href="https://www.rabbitmq.com/lazy-queues.html">Lazy Queues</link>.
Consider using a policy instead of this setting because using a policy allows changing the setting without deleting the queue.
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqMaxLength</term>
<listitem>
<simpara>maximum number of messages in the dead letter queue
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqMaxLengthBytes</term>
<listitem>
<simpara>maximum number of total bytes in the dead letter queue from all messages
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqMaxPriority</term>
<listitem>
<simpara>maximum priority of messages in the dead letter queue (0-255)
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>none</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>dlqTtl</term>
<listitem>
<simpara>default time to live to apply to the dead letter queue when declared (ms)
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>exchangeAutoDelete</term>
<listitem>
<simpara>If <literal>declareExchange</literal> is true, whether the exchange should be auto-delete (removed after the last queue is removed).</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>exchangeDurable</term>
<listitem>
<simpara>If <literal>declareExchange</literal> is true, whether the exchange should be durable (survives broker restart).</simpara>
<simpara>Default: <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>exchangeType</term>
<listitem>
<simpara>The exchange type; <literal>direct</literal>, <literal>fanout</literal> or <literal>topic</literal> for non-partitioned destinations; <literal>direct</literal> or <literal>topic</literal> for partitioned destinations.</simpara>
<simpara>Default: <literal>topic</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>expires</term>
<listitem>
<simpara>how long before an unused queue is deleted (ms)
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>no expiration</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>headerPatterns</term>
<listitem>
<simpara>Patterns for headers to be mapped to outbound messages.</simpara>
<simpara>Default: <literal>['*']</literal> (all headers).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>lazy</term>
<listitem>
<simpara>Declare the queue with the <literal>x-queue-mode=lazy</literal> argument.
See <link xl:href="https://www.rabbitmq.com/lazy-queues.html">Lazy Queues</link>.
Consider using a policy instead of this setting because using a policy allows changing the setting without deleting the queue.
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>maxLength</term>
<listitem>
<simpara>maximum number of messages in the queue
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>maxLengthBytes</term>
<listitem>
<simpara>maximum number of total bytes in the queue from all messages
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>maxPriority</term>
<listitem>
<simpara>maximum priority of messages in the queue (0-255)
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default</term>
<listitem>
<simpara><literal>none</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>prefix</term>
<listitem>
<simpara>A prefix to be added to the name of the <literal>destination</literal> exchange.</simpara>
<simpara>Default: "".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>queueNameGroupOnly</term>
<listitem>
<simpara>When true, consume from a queue with a name equal to the <literal>group</literal>; otherwise the queue name is <literal>destination.group</literal>.
This is useful, for example, when using Spring Cloud Stream to consume from an existing RabbitMQ queue.
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: false.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>routingKeyExpression</term>
<listitem>
<simpara>A SpEL expression to determine the routing key to use when publishing messages.
For a fixed routing key, use a literal expression, e.g. <literal>routingKeyExpression='my.routingKey'</literal> in a properties file, or <literal>routingKeyExpression: '''my.routingKey'''</literal> in a YAML file.</simpara>
<simpara>Default: <literal>destination</literal> or <literal>destination-&lt;partition&gt;</literal> for partitioned destinations.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>transacted</term>
<listitem>
<simpara>Whether to use transacted channels.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ttl</term>
<listitem>
<simpara>default time to live to apply to the queue when declared (ms)
Only applies if <literal>requiredGroups</literal> are provided and then only to those groups.</simpara>
<simpara>Default: <literal>no limit</literal></simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>In the case of RabbitMQ, content type headers can be set by external applications.
Spring Cloud Stream supports them as part of an extended internal protocol used for any type of transport (including transports, such as Kafka, that do not normally support headers).</simpara>
</note>
</section>
</section>
<section xml:id="_retry_with_the_rabbitmq_binder">
<title>Retry With the RabbitMQ Binder</title>
<section xml:id="_overview">
<title>Overview</title>
<simpara>When retry is enabled within the binder, the listener container thread is suspended for any back off periods that are configured.
This might be important when strict ordering is required with a single consumer but for other use cases it prevents other messages from being processed on that thread.
An alternative to using binder retry is to set up dead lettering with time to live on the dead-letter queue (DLQ), as well as dead-letter configuration on the DLQ itself.
See <xref linkend="rabbit-binder-properties"/> for more information about the properties discussed here.
Example configuration to enable this feature:</simpara>
<itemizedlist>
<listitem>
<simpara>Set <literal>autoBindDlq</literal> to <literal>true</literal> - the binder will create a DLQ; you can optionally specify a name in <literal>deadLetterQueueName</literal></simpara>
</listitem>
<listitem>
<simpara>Set <literal>dlqTtl</literal> to the back off time you want to wait between redeliveries</simpara>
</listitem>
<listitem>
<simpara>Set the <literal>dlqDeadLetterExchange</literal> to the default exchange - expired messages from the DLQ will be routed to the original queue since the default <literal>deadLetterRoutingKey</literal> is the queue name (<literal>destination.group</literal>)</simpara>
</listitem>
</itemizedlist>
<simpara>To force a message to be dead-lettered, either throw an <literal>AmqpRejectAndDontRequeueException</literal>, or set <literal>requeueRejected</literal> to <literal>true</literal> and throw any exception.</simpara>
<simpara>The loop will continue without end, which is fine for transient problems but you may want to give up after some number of attempts.
Fortunately, RabbitMQ provides the <literal>x-death</literal> header which allows you to determine how many cycles have occurred.</simpara>
<simpara>To acknowledge a message after giving up, throw an <literal>ImmediateAcknowledgeAmqpException</literal>.</simpara>
</section>
<section xml:id="_putting_it_all_together">
<title>Putting it All Together</title>
<screen>---
spring.cloud.stream.bindings.input.destination=myDestination
spring.cloud.stream.bindings.input.group=consumerGroup
#disable binder retries
spring.cloud.stream.bindings.input.consumer.max-attempts=1
#dlx/dlq setup
spring.cloud.stream.rabbit.bindings.input.consumer.auto-bind-dlq=true
spring.cloud.stream.rabbit.bindings.input.consumer.dlq-ttl=5000
spring.cloud.stream.rabbit.bindings.input.consumer.dlq-dead-letter-exchange=
---</screen>
<simpara>This configuration creates an exchange <literal>myDestination</literal> with queue <literal>myDestination.consumerGroup</literal> bound to a topic exchange with a wildcard routing key <literal>#</literal>.
It creates a DLQ bound to a direct exchange <literal>DLX</literal> with routing key <literal>myDestination.consumerGroup</literal>.
When messages are rejected, they are routed to the DLQ.
After 5 seconds, the message expires and is routed to the original queue using the queue name as the routing key.</simpara>
<formalpara>
<title>Spring Boot application</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableBinding(Sink.class)
public class XDeathApplication {

    public static void main(String[] args) {
        SpringApplication.run(XDeathApplication.class, args);
    }

    @StreamListener(Sink.INPUT)
    public void listen(String in, @Header(name = "x-death", required = false) Map&lt;?,?&gt; death) {
        if (death != null &amp;&amp; death.get("count").equals(3L)) {
            // giving up - don't send to DLX
            throw new ImmediateAcknowledgeAmqpException("Failed after 4 attempts");
        }
        throw new AmqpRejectAndDontRequeueException("failed");
    }

}</programlisting>
</para>
</formalpara>
<simpara>Notice that the count property in the <literal>x-death</literal> header is a <literal>Long</literal>.</simpara>
</section>
</section>
<section xml:id="rabbit-error-channels">
<title>Error Channels</title>
<simpara>Starting with <emphasis>version 1.3</emphasis>, the binder unconditionally sends exceptions to an error channel for each consumer destination, and can be configured to send async producer send failures to an error channel too.
See <xref linkend="binder-error-channels"/> for more information.</simpara>
<simpara>With rabbitmq, there are two types of send failures:</simpara>
<itemizedlist>
<listitem>
<simpara>returned messages</simpara>
</listitem>
<listitem>
<simpara>negatively acknowledged <link xl:href="https://www.rabbitmq.com/confirms.html">Publisher Confirms</link></simpara>
</listitem>
</itemizedlist>
<simpara>The latter is rare; quoting the RabbitMQ documentation "[A nack] will only be delivered if an internal error occurs in the Erlang process responsible for a queue.".</simpara>
<simpara>As well as enabling producer error channels as described in <xref linkend="binder-error-channels"/>, the RabbitMQ binder will only send messages to the channels if the connection factory is appropriately configured:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ccf.setPublisherConfirms(true);</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ccf.setPublisherReturns(true);</literal></simpara>
</listitem>
</itemizedlist>
<simpara>When using spring boot configuration for the connection factory, set properties:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>spring.rabbitmq.publisher-confirms</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spring.rabbitmq.publisher-returns</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The payload of the <literal>ErrorMessage</literal> for a returned message is a <literal>ReturnedAmqpMessageException</literal> with properties:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>failedMessage</literal> - the spring-messaging <literal>Message&lt;?&gt;</literal> that failed to be sent.</simpara>
</listitem>
<listitem>
<simpara><literal>amqpMessage</literal> - the raw spring-amqp <literal>Message</literal></simpara>
</listitem>
<listitem>
<simpara><literal>replyCode</literal> - an integer value indicating the reason for the failure (e.g. 312 - No route)</simpara>
</listitem>
<listitem>
<simpara><literal>replyText</literal> - a text value indicating the reason for the failure e.g. <literal>NO_ROUTE</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>exchange</literal> - the exchange to which the message was published.</simpara>
</listitem>
<listitem>
<simpara><literal>routingKey</literal> - the routing key used when the message was published.</simpara>
</listitem>
</itemizedlist>
<simpara>For negatively acknowledged confirms, the payload is a <literal>NackedAmqpMessageException</literal> with properties:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>failedMessage</literal> - the spring-messaging <literal>Message&lt;?&gt;</literal> that failed to be sent.</simpara>
</listitem>
<listitem>
<simpara><literal>nackReason</literal> - a reason (if available; you may need to examine the broker logs for more information).</simpara>
</listitem>
</itemizedlist>
<simpara>There is no automatic handling of these exceptions (such as sending to a <link linkend="rabbit-dlq-processing">Dead-Letter queue</link>); you can consume these exceptions with your own Spring Integration flow.</simpara>
</section>
<section xml:id="rabbit-dlq-processing">
<title>Dead-Letter Queue Processing</title>
<simpara>Because it can&#8217;t be anticipated how users would want to dispose of dead-lettered messages, the framework does not provide any standard mechanism to handle them.
If the reason for the dead-lettering is transient, you may wish to route the messages back to the original queue.
However, if the problem is a permanent issue, that could cause an infinite loop.
The following <literal>spring-boot</literal> application is an example of how to route those messages back to the original queue, but moves them to a third "parking lot" queue after three attempts.
The second example utilizes the <link xl:href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/">RabbitMQ Delayed Message Exchange</link> to introduce a delay to the requeued message.
In this example, the delay increases for each attempt.
These examples use a <literal>@RabbitListener</literal> to receive messages from the DLQ, you could also use <literal>RabbitTemplate.receive()</literal> in a batch process.</simpara>
<simpara>The examples assume the original destination is <literal>so8400in</literal> and the consumer group is <literal>so8400</literal>.</simpara>
<section xml:id="_non_partitioned_destinations">
<title>Non-Partitioned Destinations</title>
<simpara>The first two examples are when the destination is <emphasis role="strong">not</emphasis> partitioned.</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
public class ReRouteDlqApplication {

    private static final String ORIGINAL_QUEUE = "so8400in.so8400";

    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

    private static final String X_RETRIES_HEADER = "x-retries";

    public static void main(String[] args) throws Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
        System.out.println("Hit enter to terminate");
        System.in.read();
        context.close();
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @RabbitListener(queues = DLQ)
    public void rePublish(Message failedMessage) {
        Integer retriesHeader = (Integer) failedMessage.getMessageProperties().getHeaders().get(X_RETRIES_HEADER);
        if (retriesHeader == null) {
            retriesHeader = Integer.valueOf(0);
        }
        if (retriesHeader &lt; 3) {
            failedMessage.getMessageProperties().getHeaders().put(X_RETRIES_HEADER, retriesHeader + 1);
            this.rabbitTemplate.send(ORIGINAL_QUEUE, failedMessage);
        }
        else {
            this.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    @Bean
    public Queue parkingLot() {
        return new Queue(PARKING_LOT);
    }

}</programlisting>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
public class ReRouteDlqApplication {

    private static final String ORIGINAL_QUEUE = "so8400in.so8400";

    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

    private static final String X_RETRIES_HEADER = "x-retries";

    private static final String DELAY_EXCHANGE = "dlqReRouter";

    public static void main(String[] args) throws Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
        System.out.println("Hit enter to terminate");
        System.in.read();
        context.close();
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @RabbitListener(queues = DLQ)
    public void rePublish(Message failedMessage) {
        Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
        Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
        if (retriesHeader == null) {
            retriesHeader = Integer.valueOf(0);
        }
        if (retriesHeader &lt; 3) {
            headers.put(X_RETRIES_HEADER, retriesHeader + 1);
            headers.put("x-delay", 5000 * retriesHeader);
            this.rabbitTemplate.send(DELAY_EXCHANGE, ORIGINAL_QUEUE, failedMessage);
        }
        else {
            this.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    @Bean
    public DirectExchange delayExchange() {
        DirectExchange exchange = new DirectExchange(DELAY_EXCHANGE);
        exchange.setDelayed(true);
        return exchange;
    }

    @Bean
    public Binding bindOriginalToDelay() {
        return BindingBuilder.bind(new Queue(ORIGINAL_QUEUE)).to(delayExchange()).with(ORIGINAL_QUEUE);
    }

    @Bean
    public Queue parkingLot() {
        return new Queue(PARKING_LOT);
    }

}</programlisting>
</section>
<section xml:id="_partitioned_destinations">
<title>Partitioned Destinations</title>
<simpara>With partitioned destinations, there is one DLQ for all partitions and we determine the original queue from the headers.</simpara>
<section xml:id="_republishtodlq_false">
<title>republishToDlq=false</title>
<simpara>When <literal>republishToDlq</literal> is <literal>false</literal>, RabbitMQ publishes the message to the DLX/DLQ with an <literal>x-death</literal> header containing information about the original destination.</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
public class ReRouteDlqApplication {

	private static final String ORIGINAL_QUEUE = "so8400in.so8400";

	private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

	private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

	private static final String X_DEATH_HEADER = "x-death";

	private static final String X_RETRIES_HEADER = "x-retries";

	public static void main(String[] args) throws Exception {
		ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
		System.out.println("Hit enter to terminate");
		System.in.read();
		context.close();
	}

	@Autowired
	private RabbitTemplate rabbitTemplate;

	@SuppressWarnings("unchecked")
	@RabbitListener(queues = DLQ)
	public void rePublish(Message failedMessage) {
		Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
		Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
		if (retriesHeader == null) {
			retriesHeader = Integer.valueOf(0);
		}
		if (retriesHeader &lt; 3) {
			headers.put(X_RETRIES_HEADER, retriesHeader + 1);
			List&lt;Map&lt;String, ?&gt;&gt; xDeath = (List&lt;Map&lt;String, ?&gt;&gt;) headers.get(X_DEATH_HEADER);
			String exchange = (String) xDeath.get(0).get("exchange");
			List&lt;String&gt; routingKeys = (List&lt;String&gt;) xDeath.get(0).get("routing-keys");
			this.rabbitTemplate.send(exchange, routingKeys.get(0), failedMessage);
		}
		else {
			this.rabbitTemplate.send(PARKING_LOT, failedMessage);
		}
	}

	@Bean
	public Queue parkingLot() {
		return new Queue(PARKING_LOT);
	}

}</programlisting>
</section>
<section xml:id="_republishtodlq_true">
<title>republishToDlq=true</title>
<simpara>When <literal>republishToDlq</literal> is <literal>true</literal>, the republishing recoverer adds the original exchange and routing key to headers.</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
public class ReRouteDlqApplication {

	private static final String ORIGINAL_QUEUE = "so8400in.so8400";

	private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

	private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

	private static final String X_RETRIES_HEADER = "x-retries";

	private static final String X_ORIGINAL_EXCHANGE_HEADER = RepublishMessageRecoverer.X_ORIGINAL_EXCHANGE;

	private static final String X_ORIGINAL_ROUTING_KEY_HEADER = RepublishMessageRecoverer.X_ORIGINAL_ROUTING_KEY;

	public static void main(String[] args) throws Exception {
		ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
		System.out.println("Hit enter to terminate");
		System.in.read();
		context.close();
	}

	@Autowired
	private RabbitTemplate rabbitTemplate;

	@RabbitListener(queues = DLQ)
	public void rePublish(Message failedMessage) {
		Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
		Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
		if (retriesHeader == null) {
			retriesHeader = Integer.valueOf(0);
		}
		if (retriesHeader &lt; 3) {
			headers.put(X_RETRIES_HEADER, retriesHeader + 1);
			String exchange = (String) headers.get(X_ORIGINAL_EXCHANGE_HEADER);
			String originalRoutingKey = (String) headers.get(X_ORIGINAL_ROUTING_KEY_HEADER);
			this.rabbitTemplate.send(exchange, originalRoutingKey, failedMessage);
		}
		else {
			this.rabbitTemplate.send(PARKING_LOT, failedMessage);
		}
	}

	@Bean
	public Queue parkingLot() {
		return new Queue(PARKING_LOT);
	}

}</programlisting>
</section>
</section>
</section>
</chapter>
</part>
<part xml:id="_spring_cloud_bus">
<title>Spring Cloud Bus</title>
<partintro>
<simpara>Spring Cloud Bus links nodes of a distributed system with a lightweight message broker. This can then be used to broadcast state changes (e.g. configuration changes) or other management instructions. A key idea is that the Bus is like a distributed Actuator for a Spring Boot application that is scaled out, but it can also be used as a communication channel between apps. Starters are provided for an AMQP broker as the transport or for Kafka, but the same basic feature set (and some more depending on the transport) is on the roadmap for other transports.</simpara>
<note>
<simpara>Spring Cloud is released under the non-restrictive Apache 2.0 license. If you would like to contribute to this section of the documentation or if you find an error, please find the source code and issue trackers in the project at <link xl:href="https://github.com/spring-cloud/spring-cloud-config/tree/master/docs/src/main/asciidoc">github</link>.</simpara>
</note>
</partintro>
<chapter xml:id="_quick_start_2">
<title>Quick Start</title>
<simpara>Spring Cloud Bus works by adding Spring Boot autconfiguration if it detects itself on the classpath. All you need to do to enable the bus is to add <literal>spring-cloud-starter-bus-amqp</literal> or <literal>spring-cloud-starter-bus-kafka</literal> to your dependency management and Spring Cloud takes care of the rest. Make sure the broker (RabbitMQ or Kafka) is available and configured: running on localhost you shouldn&#8217;t have to do anything, but if you are running remotely use Spring Cloud Connectors, or Spring Boot conventions to define the broker credentials, e.g. for Rabbit</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>spring:
  rabbitmq:
    host: mybroker.com
    port: 5672
    username: user
    password: secret</screen>
</para>
</formalpara>
<simpara>The bus currently supports sending messages to all nodes listening or all nodes for a particular service (as defined by Eureka).  More selector criteria may be added in the future (ie. only service X nodes in data center Y, etc&#8230;&#8203;). There are also some http endpoints under the <literal>/bus/*</literal> actuator namespace.  There are currently two implemented.  The first, <literal>/bus/env</literal>, sends key/value pairs to update each node&#8217;s Spring Environment.  The second, <literal>/bus/refresh</literal>, will reload each application&#8217;s configuration, just as if they had all been pinged on their <literal>/refresh</literal> endpoint.</simpara>
<note>
<simpara>The Bus starters cover Rabbit and Kafka, because those are the two most common implementations, but Spring Cloud Stream is quite flexible and binder will work combined with <literal>spring-cloud-bus</literal>.</simpara>
</note>
</chapter>
<chapter xml:id="_addressing_an_instance">
<title>Addressing an Instance</title>
<simpara>The HTTP endpoints accept a "destination" parameter, e.g. "/bus/refresh?destination=customers:9000", where the destination is an <literal>ApplicationContext</literal> ID. If the ID is owned by an instance on the Bus then it will process the message and all other instances will ignore it. Spring Boot sets the ID for you in the <literal>ContextIdApplicationContextInitializer</literal> to a combination of the <literal>spring.application.name</literal>, active profiles and <literal>server.port</literal> by default.</simpara>
</chapter>
<chapter xml:id="_addressing_all_instances_of_a_service">
<title>Addressing all instances of a service</title>
<simpara>The "destination" parameter is used in a Spring <literal>PathMatcher</literal> (with the path separator as a colon <literal>:</literal>) to determine if an instance will process the message.   Using the example from above, "/bus/refresh?destination=customers:**" will  target  all instances of the "customers" service regardless of the profiles and ports set as the <literal>ApplicationContext</literal> ID.</simpara>
</chapter>
<chapter xml:id="_application_context_id_must_be_unique">
<title>Application Context ID must be unique</title>
<simpara>The bus tries to eliminate processing an event twice, once from the original <literal>ApplicationEvent</literal> and once from the queue.  To do this, it checks the sending application context id againts the current application context id.  If multiple instances of a service have the same application context id, events will not be processed.  Running on a local machine, each service will be on a different port and that will be part of the application context id.  Cloud Foundry supplies an index to differentiate.  To ensure that the application context id is the unique, set <literal>spring.application.index</literal> to something unique for each instance of a service.  For example, in lattice, set <literal>spring.application.index=${INSTANCE_INDEX}</literal> in application.properties (or bootstrap.properties if using configserver).</simpara>
</chapter>
<chapter xml:id="_customizing_the_message_broker">
<title>Customizing the Message Broker</title>
<simpara>Spring Cloud Bus uses
<link xl:href="https://cloud.spring.io/spring-cloud-stream">Spring Cloud Stream</link> to
broadcast the messages so to get messages to flow you only need to
include the binder implementation of your choice in the
classpath. There are convenient starters specifically for the bus with
AMQP (RabbitMQ) and Kafka
(<literal>spring-cloud-starter-bus-[amqp,kafka]</literal>). Generally speaking
Spring Cloud Stream relies on Spring Boot autoconfiguration
conventions for configuring middleware, so for instance the AMQP
broker address can be changed with <literal>spring.rabbitmq.*</literal>
configuration properties. Spring Cloud Bus has a handful of native
configuration properties in <literal>spring.cloud.bus.*</literal>
(e.g. <literal>spring.cloud.bus.destination</literal> is the name of the topic to use
the the externall middleware). Normally the defaults will suffice.</simpara>
<simpara>To lean more about how to customize the message broker settings
consult the Spring Cloud Stream documentation.</simpara>
</chapter>
<chapter xml:id="_tracing_bus_events">
<title>Tracing Bus Events</title>
<simpara>Bus events (subclasses of <literal>RemoteApplicationEvent</literal>) can be traced by
setting <literal>spring.cloud.bus.trace.enabled=true</literal>. If you do this then the
Spring Boot <literal>TraceRepository</literal> (if it is present) will show each event
sent and all the acks from each service instance. Example (from the
<literal>/trace</literal> endpoint):</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "timestamp": "2015-11-26T10:24:44.411+0000",
  "info": {
    "signal": "spring.cloud.bus.ack",
    "type": "RefreshRemoteApplicationEvent",
    "id": "c4d374b7-58ea-4928-a312-31984def293b",
    "origin": "stores:8081",
    "destination": "*:**"
  }
  },
  {
  "timestamp": "2015-11-26T10:24:41.864+0000",
  "info": {
    "signal": "spring.cloud.bus.sent",
    "type": "RefreshRemoteApplicationEvent",
    "id": "c4d374b7-58ea-4928-a312-31984def293b",
    "origin": "customers:9000",
    "destination": "*:**"
  }
  },
  {
  "timestamp": "2015-11-26T10:24:41.862+0000",
  "info": {
    "signal": "spring.cloud.bus.ack",
    "type": "RefreshRemoteApplicationEvent",
    "id": "c4d374b7-58ea-4928-a312-31984def293b",
    "origin": "customers:9000",
    "destination": "*:**"
  }
}</programlisting>
<simpara>This trace shows that a <literal>RefreshRemoteApplicationEvent</literal> was sent from
<literal>customers:9000</literal>, broadcast to all services, and it was received
(acked) by <literal>customers:9000</literal> and <literal>stores:8081</literal>.</simpara>
<simpara>To handle the ack signals yourself you could add an <literal>@EventListener</literal>
for the <literal>AckRemoteApplicationEvent</literal> and <literal>SentApplicationEvent</literal> types
to your app (and enable tracing). Or you could tap into the
<literal>TraceRepository</literal> and mine the data from there.</simpara>
<note>
<simpara>Any Bus application can trace acks, but sometimes it will be
useful to do this in a central service that can do more complex
queries on the data. Or forward it to a specialized tracing service.</simpara>
</note>
</chapter>
<chapter xml:id="_broadcasting_your_own_events">
<title>Broadcasting Your Own Events</title>
<simpara>The Bus can carry any event of type <literal>RemoteApplicationEvent</literal>, but the
default transport is JSON and the deserializer needs to know which
types are going to be used ahead of time. To register a new type it
needs to be in a subpackage of <literal>org.springframework.cloud.bus.event</literal>.</simpara>
<simpara>To customise the event name you can use <literal>@JsonTypeName</literal> on your custom class
or rely on the default strategy which is to use the simple name of the class.
Note that both the producer and the consumer will need access to the class
definition.</simpara>
<section xml:id="_registering_events_in_custom_packages">
<title>Registering events in custom packages</title>
<simpara>If you cannot or don&#8217;t want to use a subpackage of <literal>org.springframework.cloud.bus.event</literal>
for your custom events, you must specify which packages to scan for events of
type <literal>RemoteApplicationEvent</literal> using <literal>@RemoteApplicationEventScan</literal>. Packages
specified with <literal>@RemoteApplicationEventScan</literal> include subpackages.</simpara>
<simpara>For example, if you have a custom event called <literal>FooEvent</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.acme;

public class FooEvent extends RemoteApplicationEvent {
    ...
}</programlisting>
<simpara>you can register this event with the deserializer in the following way:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.acme;

@Configuration
@RemoteApplicationEventScan
public class BusConfiguration {
    ...
}</programlisting>
<simpara>Without specifying a value, the package of the class where <literal>@RemoteApplicationEventScan</literal>
is used will be registered. In this example <literal>com.acme</literal> will be registered using the
package of <literal>BusConfiguration</literal>.</simpara>
<simpara>You can also explicitly specify the packages to scan using the <literal>value</literal>, <literal>basePackages</literal> or
<literal>basePackageClasses</literal> properties on <literal>@RemoteApplicationEventScan</literal>. For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.acme;

@Configuration
//@RemoteApplicationEventScan({"com.acme", "foo.bar"})
//@RemoteApplicationEventScan(basePackages = {"com.acme", "foo.bar", "fizz.buzz"})
@RemoteApplicationEventScan(basePackageClasses = BusConfiguration.class)
public class BusConfiguration {
    ...
}</programlisting>
<simpara>All examples of <literal>@RemoteApplicationEventScan</literal> above are equivalent,
in that the <literal>com.acme</literal> package will be registered by explicitly specifying the
packages on <literal>@RemoteApplicationEventScan</literal>. Note, you can specify multiple base
packages to scan.</simpara>
</section>
</chapter>
</part>
<part xml:id="_spring_cloud_sleuth">
<title>Spring Cloud Sleuth</title>
<partintro>
<simpara>Adrian Cole, Spencer Gibb, Marcin Grzejszczak, Dave Syer</simpara>
<simpara><emphasis role="strong">Edgware.SR2</emphasis></simpara>
</partintro>
<chapter xml:id="_introduction">
<title>Introduction</title>
<simpara>Spring Cloud Sleuth implements a distributed tracing solution for <link xl:href="https://cloud.spring.io">Spring Cloud</link>.</simpara>
<section xml:id="_terminology">
<title>Terminology</title>
<simpara>Spring Cloud Sleuth borrows <link xl:href="https://research.google.com/pubs/pub36356.html">Dapper&#8217;s</link> terminology.</simpara>
<simpara><emphasis role="strong">Span:</emphasis> The basic unit of work. For example, sending an RPC is a new span, as is sending a response to an
RPC. Span&#8217;s are identified by a unique 64-bit ID for the span and another 64-bit ID for the trace the span
is a part of.  Spans also have other data, such as descriptions, timestamped events, key-value
annotations (tags), the ID of the span that caused them, and process ID&#8217;s (normally IP address).</simpara>
<simpara>Spans are started and stopped, and they keep track of their timing information.  Once you create a
span, you must stop it at some point in the future.</simpara>
<tip>
<simpara>The initial span that starts a trace is called a <literal>root span</literal>. The value of span id
of that span is equal to trace id.</simpara>
</tip>
<simpara><emphasis role="strong">Trace:</emphasis> A set of spans forming a tree-like structure.  For example, if you are running a distributed
big-data store, a trace might be formed by a put request.</simpara>
<simpara><emphasis role="strong">Annotation:</emphasis>  is used to record existence of an event in time. Some of the core annotations used to define
the start and stop of a request are:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">cs</emphasis> - Client Sent - The client has made a request. This annotation depicts the start of the span.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">sr</emphasis> - Server Received -  The server side got the request and will start processing it.
If one subtracts the cs timestamp from this timestamp one will receive the network latency.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">ss</emphasis> - Server Sent -  Annotated upon completion of request processing (when the response
got sent back to the client). If one subtracts the sr timestamp from this timestamp one
will receive the time needed by the server side to process the request.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">cr</emphasis> - Client Received - Signifies the end of the span. The client has successfully received the
response from the server side. If one subtracts the cs timestamp from this timestamp one
will receive the whole time needed by the client to receive the response from the server.</simpara>
</listitem>
</itemizedlist>
<simpara>Visualization of what <emphasis role="strong">Span</emphasis> and <emphasis role="strong">Trace</emphasis> will look in a system together with the Zipkin annotations:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/trace-id.png"/>
</imageobject>
<textobject><phrase>Trace Info propagation</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Each color of a note signifies a span (7 spans - from <emphasis role="strong">A</emphasis> to <emphasis role="strong">G</emphasis>). If you have such information in the note:</simpara>
<screen>Trace Id = X
Span Id = D
Client Sent</screen>
<simpara>That means that the current span has <emphasis role="strong">Trace-Id</emphasis> set to <emphasis role="strong">X</emphasis>, <emphasis role="strong">Span-Id</emphasis> set to <emphasis role="strong">D</emphasis>. It also has emitted
 <emphasis role="strong">Client Sent</emphasis> event.</simpara>
<simpara>This is how the visualization of the parent / child relationship of spans would look like:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/parents.png"/>
</imageobject>
<textobject><phrase>Parent child relationship</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_purpose">
<title>Purpose</title>
<simpara>In the following sections the example from the image above will be taken into consideration.</simpara>
<section xml:id="_distributed_tracing_with_zipkin">
<title>Distributed tracing with Zipkin</title>
<simpara>Altogether there are <emphasis role="strong">7 spans</emphasis> . If you go to traces in Zipkin you will see this number in the second trace:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-traces.png"/>
</imageobject>
<textobject><phrase>Traces</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>However if you pick a particular trace then you will see <emphasis role="strong">4 spans</emphasis>:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-ui.png"/>
</imageobject>
<textobject><phrase>Traces Info propagation</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>When picking a particular trace you will see merged spans. That means that if there were 2 spans sent to
Zipkin with Server Received and Server Sent / Client Received and Client Sent
annotations then they will presented as a single span.</simpara>
</note>
<simpara>Why is there a difference between the 7 and 4 spans in this case?</simpara>
<itemizedlist>
<listitem>
<simpara>2 spans come from <literal>http:/start</literal> span. It has the Server Received (SR) and Server Sent (SS) annotations.</simpara>
</listitem>
<listitem>
<simpara>2 spans come from the RPC call from <literal>service1</literal> to <literal>service2</literal> to the <literal>http:/foo</literal> endpoint. It has the Client Sent (CS)
and Client Received (CR) annotations on <literal>service1</literal> side. It also has Server Received (SR) and Server Sent (SS) annotations
on the <literal>service2</literal> side. Physically there are 2 spans but they form 1 logical span related to an RPC call.</simpara>
</listitem>
<listitem>
<simpara>2 spans come from the RPC call from <literal>service2</literal> to <literal>service3</literal> to the <literal>http:/bar</literal> endpoint. It has the Client Sent (CS)
and Client Received (CR) annotations on <literal>service2</literal> side. It also has Server Received (SR) and Server Sent (SS) annotations
on the <literal>service3</literal> side. Physically there are 2 spans but they form 1 logical span related to an RPC call.</simpara>
</listitem>
<listitem>
<simpara>2 spans come from the RPC call from <literal>service2</literal> to <literal>service4</literal> to the <literal>http:/baz</literal> endpoint. It has the Client Sent (CS)
and Client Received (CR) annotations on <literal>service2</literal> side. It also has Server Received (SR) and Server Sent (SS) annotations
on the <literal>service4</literal> side. Physically there are 2 spans but they form 1 logical span related to an RPC call.</simpara>
</listitem>
</itemizedlist>
<simpara>So if we count the physical spans we have <emphasis role="strong">1</emphasis> from <literal>http:/start</literal>, <emphasis role="strong">2</emphasis> from <literal>service1</literal> calling <literal>service2</literal>, <emphasis role="strong">2</emphasis> form <literal>service2</literal>
calling <literal>service3</literal> and <emphasis role="strong">2</emphasis> from <literal>service2</literal> calling <literal>service4</literal>. Altogether <emphasis role="strong">7</emphasis> spans.</simpara>
<simpara>Logically we see the information of <emphasis role="strong">Total Spans: 4</emphasis> because we have <emphasis role="strong">1</emphasis> span related to the incoming request
to <literal>service1</literal> and <emphasis role="strong">3</emphasis> spans related to RPC calls.</simpara>
</section>
<section xml:id="_visualizing_errors">
<title>Visualizing errors</title>
<simpara>Zipkin allows you to visualize errors in your trace. When an exception was thrown and wasn&#8217;t caught then we&#8217;re
setting proper tags on the span which Zipkin can properly colorize. You could see in the list of traces one
  trace that was in red color. That&#8217;s because there was an exception thrown.</simpara>
<simpara>If you click that trace then you&#8217;ll see a similar picture</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-error-traces.png"/>
</imageobject>
<textobject><phrase>Error Traces</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Then if you click on one of the spans you&#8217;ll see the following</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-error-trace-screenshot.png"/>
</imageobject>
<textobject><phrase>Error Traces Info propagation</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>As you can see you can easily see the reason for an error and the whole stacktrace related to it.</simpara>
</section>
<section xml:id="_live_examples">
<title>Live examples</title>
<figure>
<title>Click Pivotal Web Services icon to see it live!</title>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/pws.png" contentwidth="150" contentdepth="74"/>
</imageobject>
<textobject><phrase>Zipkin deployed on Pivotal Web Services</phrase></textobject>
</mediaobject>
</figure>
<simpara>The dependency graph in Zipkin would look like this:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/dependencies.png"/>
</imageobject>
<textobject><phrase>Dependencies</phrase></textobject>
</mediaobject>
</informalfigure>
<figure>
<title>Click Pivotal Web Services icon to see it live!</title>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/pws.png" contentwidth="150" contentdepth="74"/>
</imageobject>
<textobject><phrase>Zipkin deployed on Pivotal Web Services</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_log_correlation">
<title>Log correlation</title>
<simpara>When grepping the logs of those four applications by trace id equal to e.g. <literal>2485ec27856c56f4</literal> one would get the following:</simpara>
<screen>service1.log:2016-02-26 11:15:47.561  INFO [service1,2485ec27856c56f4,2485ec27856c56f4,true] 68058 --- [nio-8081-exec-1] i.s.c.sleuth.docs.service1.Application   : Hello from service1. Calling service2
service2.log:2016-02-26 11:15:47.710  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Hello from service2. Calling service3 and then service4
service3.log:2016-02-26 11:15:47.895  INFO [service3,2485ec27856c56f4,1210be13194bfe5,true] 68060 --- [nio-8083-exec-1] i.s.c.sleuth.docs.service3.Application   : Hello from service3
service2.log:2016-02-26 11:15:47.924  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Got response from service3 [Hello from service3]
service4.log:2016-02-26 11:15:48.134  INFO [service4,2485ec27856c56f4,1b1845262ffba49d,true] 68061 --- [nio-8084-exec-1] i.s.c.sleuth.docs.service4.Application   : Hello from service4
service2.log:2016-02-26 11:15:48.156  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Got response from service4 [Hello from service4]
service1.log:2016-02-26 11:15:48.182  INFO [service1,2485ec27856c56f4,2485ec27856c56f4,true] 68058 --- [nio-8081-exec-1] i.s.c.sleuth.docs.service1.Application   : Got response from service2 [Hello from service2, response from service3 [Hello from service3] and from service4 [Hello from service4]]</screen>
<simpara>If you&#8217;re using a log aggregating tool like <link xl:href="https://www.elastic.co/products/kibana">Kibana</link>,
<link xl:href="https://www.splunk.com/">Splunk</link> etc. you can order the events that took place. An example of
Kibana would look like this:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/kibana.png"/>
</imageobject>
<textobject><phrase>Log correlation with Kibana</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If you want to use <link xl:href="https://www.elastic.co/guide/en/logstash/current/index.html">Logstash</link> here is the Grok pattern for Logstash:</simpara>
<screen>filter {
       # pattern matching logback pattern
       grok {
              match =&gt; { "message" =&gt; "%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:severity}\s+\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\]\s+%{DATA:pid}\s+---\s+\[%{DATA:thread}\]\s+%{DATA:class}\s+:\s+%{GREEDYDATA:rest}" }
       }
}</screen>
<note>
<simpara>If you want to use Grok together with the logs from Cloud Foundry you have to use this pattern:</simpara>
</note>
<screen>filter {
       # pattern matching logback pattern
       grok {
              match =&gt; { "message" =&gt; "(?m)OUT\s+%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:severity}\s+\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\]\s+%{DATA:pid}\s+---\s+\[%{DATA:thread}\]\s+%{DATA:class}\s+:\s+%{GREEDYDATA:rest}" }
       }
}</screen>
<section xml:id="_json_logback_with_logstash">
<title>JSON Logback with Logstash</title>
<simpara>Often you do not want to store your logs in a text file but in a JSON file that Logstash can immediately pick. To do that you have to do the following (for readability
we&#8217;re passing the dependencies in the <literal>groupId:artifactId:version</literal> notation.</simpara>
<simpara><emphasis role="strong">Dependencies setup</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Ensure that Logback is on the classpath (<literal>ch.qos.logback:logback-core</literal>)</simpara>
</listitem>
<listitem>
<simpara>Add Logstash Logback encode - example for version <literal>4.6</literal> : <literal>net.logstash.logback:logstash-logback-encoder:4.6</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Logback setup</emphasis></simpara>
<simpara>Below you can find an example of a Logback configuration (file named <link xl:href="https://github.com/spring-cloud-samples/sleuth-documentation-apps/blob/master/service1/src/main/resources/logback-spring.xml">logback-spring.xml</link>) that:</simpara>
<itemizedlist>
<listitem>
<simpara>logs information from the application in a JSON format to a <literal>build/${spring.application.name}.json</literal> file</simpara>
</listitem>
<listitem>
<simpara>has commented out two additional appenders - console and standard log file</simpara>
</listitem>
<listitem>
<simpara>has the same logging pattern as the one presented in the previous section</simpara>
</listitem>
</itemizedlist>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration&gt;
	&lt;include resource="org/springframework/boot/logging/logback/defaults.xml"/&gt;
	​
	&lt;springProperty scope="context" name="springAppName" source="spring.application.name"/&gt;
	&lt;!-- Example for logging into the build folder of your project --&gt;
	&lt;property name="LOG_FILE" value="${BUILD_FOLDER:-build}/${springAppName}"/&gt;​

	&lt;!-- You can override this to have a custom pattern --&gt;
	&lt;property name="CONSOLE_LOG_PATTERN"
			  value="%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}"/&gt;

	&lt;!-- Appender to log to console --&gt;
	&lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt;
		&lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt;
			&lt;!-- Minimum logging level to be presented in the console logs--&gt;
			&lt;level&gt;DEBUG&lt;/level&gt;
		&lt;/filter&gt;
		&lt;encoder&gt;
			&lt;pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/pattern&gt;
			&lt;charset&gt;utf8&lt;/charset&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;

	&lt;!-- Appender to log to file --&gt;​
	&lt;appender name="flatfile" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
		&lt;file&gt;${LOG_FILE}&lt;/file&gt;
		&lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
			&lt;fileNamePattern&gt;${LOG_FILE}.%d{yyyy-MM-dd}.gz&lt;/fileNamePattern&gt;
			&lt;maxHistory&gt;7&lt;/maxHistory&gt;
		&lt;/rollingPolicy&gt;
		&lt;encoder&gt;
			&lt;pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/pattern&gt;
			&lt;charset&gt;utf8&lt;/charset&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;
	​
	&lt;!-- Appender to log to file in a JSON format --&gt;
	&lt;appender name="logstash" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
		&lt;file&gt;${LOG_FILE}.json&lt;/file&gt;
		&lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
			&lt;fileNamePattern&gt;${LOG_FILE}.json.%d{yyyy-MM-dd}.gz&lt;/fileNamePattern&gt;
			&lt;maxHistory&gt;7&lt;/maxHistory&gt;
		&lt;/rollingPolicy&gt;
		&lt;encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder"&gt;
			&lt;providers&gt;
				&lt;timestamp&gt;
					&lt;timeZone&gt;UTC&lt;/timeZone&gt;
				&lt;/timestamp&gt;
				&lt;pattern&gt;
					&lt;pattern&gt;
						{
						"severity": "%level",
						"service": "${springAppName:-}",
						"trace": "%X{X-B3-TraceId:-}",
						"span": "%X{X-B3-SpanId:-}",
						"parent": "%X{X-B3-ParentSpanId:-}",
						"exportable": "%X{X-Span-Export:-}",
						"pid": "${PID:-}",
						"thread": "%thread",
						"class": "%logger{40}",
						"rest": "%message"
						}
					&lt;/pattern&gt;
				&lt;/pattern&gt;
			&lt;/providers&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;
	​
	&lt;root level="INFO"&gt;
		&lt;appender-ref ref="console"/&gt;
		&lt;!-- uncomment this to have also JSON logs --&gt;
		&lt;!--&lt;appender-ref ref="logstash"/&gt;--&gt;
		&lt;!--&lt;appender-ref ref="flatfile"/&gt;--&gt;
	&lt;/root&gt;
&lt;/configuration&gt;</programlisting>
<note>
<simpara>If you&#8217;re using a custom <literal>logback-spring.xml</literal> then you have to pass the <literal>spring.application.name</literal> in
<literal>bootstrap</literal> instead of <literal>application</literal> property file. Otherwise your custom logback file won&#8217;t read the property properly.</simpara>
</note>
</section>
</section>
<section xml:id="_propagating_span_context">
<title>Propagating Span Context</title>
<simpara>The span context is the state that must get propagated to any child Spans across process boundaries.
Part of the Span Context is the Baggage. The trace and span IDs are a required part of the span context.
Baggage is an optional part.</simpara>
<simpara>Baggage is a set of key:value pairs stored in the span context. Baggage travels together with the trace
and is attached to every span. Spring Cloud Sleuth will understand that a header is baggage related if the HTTP
 header is prefixed with <literal>baggage-</literal> and for messaging it starts with <literal>baggage_</literal>.</simpara>
<important>
<simpara>There&#8217;s currently no limitation of the count or size of baggage items. However, keep in mind that
too many can decrease system throughput or increase RPC latency. In extreme cases, it could crash the app due
to exceeding transport-level message or header capacity.</simpara>
</important>
<simpara>Example of setting baggage on a span:</simpara>
<programlisting language="java" linenumbering="unnumbered">Span initialSpan = this.tracer.nextSpan().name("span").start();
try (Tracer.SpanInScope ws = this.tracer.withSpanInScope(initialSpan)) {
	ExtraFieldPropagation.set("foo", "bar");
	ExtraFieldPropagation.set("UPPER_CASE", "someValue");</programlisting>
<section xml:id="_baggage_vs_span_tags">
<title>Baggage vs. Span Tags</title>
<simpara>Baggage travels with the trace (i.e. every child span contains the baggage of its parent). Zipkin has no knowledge of
baggage and will not even receive that information.</simpara>
<simpara>Tags are attached to a specific span - they are presented for that particular span only. However you
can search by tag to find the trace, where there exists a span having the searched tag value.</simpara>
<simpara>If you want to be able to lookup a span based on baggage, you should add corresponding entry as a tag in the root span.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Autowired Tracer tracer;

Span span = tracer.getCurrentSpan();
String baggageKey = "key";
String baggageValue = "foo";
span.setBaggageItem(baggageKey, baggageValue);
tracer.addTag(baggageKey, baggageValue);</programlisting>
</section>
</section>
</section>
<section xml:id="_adding_to_the_project">
<title>Adding to the project</title>
<important>
<simpara>To ensure that your application name is properly displayed in Zipkin
 set the <literal>spring.application.name</literal> property in <literal>bootstrap.yml</literal>.</simpara>
</important>
<section xml:id="_only_sleuth_log_correlation">
<title>Only Sleuth (log correlation)</title>
<simpara>If you want to profit only from Spring Cloud Sleuth without the Zipkin integration just add
the <literal>spring-cloud-starter-sleuth</literal> module to your project.</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencyManagement&gt; <co xml:id="CO1-1"/>
         &lt;dependencies&gt;
             &lt;dependency&gt;
                 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                 &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                 &lt;version&gt;${release.train.version}&lt;/version&gt;
                 &lt;type&gt;pom&lt;/type&gt;
                 &lt;scope&gt;import&lt;/scope&gt;
             &lt;/dependency&gt;
         &lt;/dependencies&gt;
   &lt;/dependencyManagement&gt;

   &lt;dependency&gt; <co xml:id="CO1-2"/>
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
   &lt;/dependency&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>In order not to pick versions by yourself it&#8217;s much better if you add the dependency management via
the Spring BOM</para>
</callout>
<callout arearefs="CO1-2">
<para>Add the dependency to <literal>spring-cloud-starter-sleuth</literal></para>
</callout>
</calloutlist>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">dependencyManagement { <co xml:id="CO2-1"/>
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${releaseTrainVersion}"
    }
}

dependencies { <co xml:id="CO2-2"/>
    compile "org.springframework.cloud:spring-cloud-starter-sleuth"
}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO2-1">
<para>In order not to pick versions by yourself it&#8217;s much better if you add the dependency management via
the Spring BOM</para>
</callout>
<callout arearefs="CO2-2">
<para>Add the dependency to <literal>spring-cloud-starter-sleuth</literal></para>
</callout>
</calloutlist>
</section>
<section xml:id="_sleuth_with_zipkin_via_http">
<title>Sleuth with Zipkin via HTTP</title>
<simpara>If you want both Sleuth and Zipkin just add the <literal>spring-cloud-starter-zipkin</literal> dependency.</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencyManagement&gt; <co xml:id="CO3-1"/>
         &lt;dependencies&gt;
             &lt;dependency&gt;
                 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                 &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                 &lt;version&gt;${release.train.version}&lt;/version&gt;
                 &lt;type&gt;pom&lt;/type&gt;
                 &lt;scope&gt;import&lt;/scope&gt;
             &lt;/dependency&gt;
         &lt;/dependencies&gt;
   &lt;/dependencyManagement&gt;

   &lt;dependency&gt; <co xml:id="CO3-2"/>
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
   &lt;/dependency&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-1">
<para>In order not to pick versions by yourself it&#8217;s much better if you add the dependency management via
the Spring BOM</para>
</callout>
<callout arearefs="CO3-2">
<para>Add the dependency to <literal>spring-cloud-starter-zipkin</literal></para>
</callout>
</calloutlist>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">dependencyManagement { <co xml:id="CO4-1"/>
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${releaseTrainVersion}"
    }
}

dependencies { <co xml:id="CO4-2"/>
    compile "org.springframework.cloud:spring-cloud-starter-zipkin"
}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO4-1">
<para>In order not to pick versions by yourself it&#8217;s much better if you add the dependency management via
the Spring BOM</para>
</callout>
<callout arearefs="CO4-2">
<para>Add the dependency to <literal>spring-cloud-starter-zipkin</literal></para>
</callout>
</calloutlist>
</section>
<section xml:id="_sleuth_with_zipkin_via_rabbitmq_or_kafka">
<title>Sleuth with Zipkin via RabbitMQ or Kafka</title>
<simpara>If you want to use RabbitMQ or Kafka instead of http, add the <literal>spring-rabbit</literal> or <literal>spring-kafka</literal>
dependencies. The default destination name is <literal>zipkin</literal>.</simpara>
<simpara><emphasis>Note: <literal>spring-cloud-sleuth-stream</literal> is deprecated and incompatible with these destinations</emphasis></simpara>
<simpara>If you want Sleuth over RabbitMQ add the <literal>spring-cloud-starter-zipkin</literal> and <literal>spring-rabbit</literal>
dependencies.</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencyManagement&gt; <co xml:id="CO5-1"/>
         &lt;dependencies&gt;
             &lt;dependency&gt;
                 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                 &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                 &lt;version&gt;${release.train.version}&lt;/version&gt;
                 &lt;type&gt;pom&lt;/type&gt;
                 &lt;scope&gt;import&lt;/scope&gt;
             &lt;/dependency&gt;
         &lt;/dependencies&gt;
   &lt;/dependencyManagement&gt;

   &lt;dependency&gt; <co xml:id="CO5-2"/>
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt; <co xml:id="CO5-3"/>
       &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;
       &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;
   &lt;/dependency&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO5-1">
<para>In order not to pick versions by yourself it&#8217;s much better if you add the dependency management via
the Spring BOM</para>
</callout>
<callout arearefs="CO5-2">
<para>Add the dependency to <literal>spring-cloud-starter-zipkin</literal> - that way all dependent dependencies will be downloaded</para>
</callout>
<callout arearefs="CO5-3">
<para>To automatically configure rabbit, simply add the spring-rabbit dependency</para>
</callout>
</calloutlist>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">dependencyManagement { <co xml:id="CO6-1"/>
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${releaseTrainVersion}"
    }
}

dependencies {
    compile "org.springframework.cloud:spring-cloud-starter-zipkin" <co xml:id="CO6-2"/>
    compile "org.springframework.amqp:spring-rabbit" <co xml:id="CO6-3"/>
}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO6-1">
<para>In order not to pick versions by yourself it&#8217;s much better if you add the dependency management via
the Spring BOM</para>
</callout>
<callout arearefs="CO6-2">
<para>Add the dependency to <literal>spring-cloud-starter-zipkin</literal> - that way all dependent dependencies will be downloaded</para>
</callout>
<callout arearefs="CO6-3">
<para>To automatically configure rabbit, simply add the spring-rabbit dependency</para>
</callout>
</calloutlist>
</section>
</section>
</chapter>
<chapter xml:id="_additional_resources">
<title>Additional resources</title>
<simpara><emphasis role="strong">Marcin Grzejszczak talking about Spring Cloud Sleuth and Zipkin</emphasis></simpara>

<simpara><link xl:href="https://www.youtube.com/watch?v=eQV71Mw1u1c">click here to see the video</link></simpara>
</chapter>
<chapter xml:id="_features_2">
<title>Features</title>
<itemizedlist>
<listitem>
<simpara>Adds trace and span ids to the Slf4J MDC, so you can extract all the logs from a given trace or span in a log aggregator. Example logs:</simpara>
<screen>2016-02-02 15:30:57.902  INFO [bar,6bfd228dc00d216b,6bfd228dc00d216b,false] 23030 --- [nio-8081-exec-3] ...
2016-02-02 15:30:58.372 ERROR [bar,6bfd228dc00d216b,6bfd228dc00d216b,false] 23030 --- [nio-8081-exec-3] ...
2016-02-02 15:31:01.936  INFO [bar,46ab0d418373cbc9,46ab0d418373cbc9,false] 23030 --- [nio-8081-exec-4] ...</screen>
<simpara>notice the <literal>[appname,traceId,spanId,exportable]</literal> entries from the MDC:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">spanId</emphasis> - the id of a specific operation that took place</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">appname</emphasis> - the name of the application that logged the span</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">traceId</emphasis> - the id of the latency graph that contains the span</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">exportable</emphasis> - whether the log should be exported to Zipkin or not. When would you like the span not to be
exportable? In the case in which you want to wrap some operation in a Span and have it written to the logs
only.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Provides an abstraction over common distributed tracing data models: traces, spans (forming a DAG), annotations,
key-value annotations. Loosely based on HTrace, but Zipkin (Dapper) compatible.</simpara>
</listitem>
<listitem>
<simpara>Sleuth records timing information to aid in latency analysis. Using sleuth, you can pinpoint causes of
latency in your applications. Sleuth is written to not log too much, and to not cause your production application to crash.</simpara>
<itemizedlist>
<listitem>
<simpara>propagates structural data about your call-graph in-band, and the rest out-of-band.</simpara>
</listitem>
<listitem>
<simpara>includes opinionated instrumentation of layers such as HTTP</simpara>
</listitem>
<listitem>
<simpara>includes sampling policy to manage volume</simpara>
</listitem>
<listitem>
<simpara>can report to a Zipkin system for query and visualization</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Instruments common ingress and egress points from Spring applications (servlet filter, async endpoints,
rest template, scheduled actions, message channels, zuul filters, feign client).</simpara>
</listitem>
<listitem>
<simpara>Sleuth includes default logic to join a trace across http or messaging boundaries. For example, http propagation
works via Zipkin-compatible request headers. This propagation logic is defined and customized via
<literal>SpanInjector</literal> and <literal>SpanExtractor</literal> implementations.</simpara>
</listitem>
<listitem>
<simpara>Sleuth gives you the possibility to propagate context (also known as baggage) between processes. That means that if you set on a Span
a baggage element then it will be sent downstream either via HTTP or messaging to other processes.</simpara>
</listitem>
<listitem>
<simpara>Provides a way to create / continue spans and add tags and logs via annotations.</simpara>
</listitem>
<listitem>
<simpara>Provides simple metrics of accepted / dropped spans.</simpara>
</listitem>
<listitem>
<simpara>If <literal>spring-cloud-sleuth-zipkin</literal> then the app will generate and collect Zipkin-compatible traces.
By default it sends them via HTTP to a Zipkin server on localhost (port 9411).
Configure the location of the service using <literal>spring.zipkin.baseUrl</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara>If you depend on <literal>spring-rabbit</literal> or <literal>spring-kafka</literal> your app will send traces to a broker instead of http.</simpara>
</listitem>
<listitem>
<simpara>Note: <literal>spring-cloud-sleuth-stream</literal> is deprecated and should no longer be used.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<important>
<simpara>If using Zipkin, configure the percentage of spans exported using <literal>spring.sleuth.sampler.percentage</literal>
(default 0.1, i.e. 10%). <emphasis role="strong">Otherwise you might think that Sleuth is not working cause it&#8217;s omitting some spans.</emphasis></simpara>
</important>
<note>
<simpara>the SLF4J MDC is always set and logback users will immediately see the trace and span ids in logs per the example
 above. Other logging systems have to configure their own formatter to get the same result. The default is
 <literal>logging.pattern.level</literal> set to <literal>%5p [${spring.zipkin.service.name:${spring.application.name:-}},%X{X-B3-TraceId:-},%X{X-B3-SpanId:-},%X{X-Span-Export:-}]</literal>
 (this is a Spring Boot feature for logback users).
 <emphasis role="strong">This means that if you&#8217;re not using SLF4J this pattern WILL NOT be automatically applied</emphasis>.</simpara>
</note>
</chapter>
<chapter xml:id="_sampling">
<title>Sampling</title>
<simpara>In distributed tracing the data volumes can be very high so sampling
can be important (you usually don&#8217;t need to export all spans to get a
good picture of what is happening). Spring Cloud Sleuth has a
<literal>Sampler</literal> strategy that you can implement to take control of the
sampling algorithm. Samplers do not stop span (correlation) ids from
being generated, but they do prevent the tags and events being
attached and exported. By default you get a strategy that continues to
trace if a span is already active, but new ones are always marked as
non-exportable. If all your apps run with this sampler you will see
traces in logs, but not in any remote store. For testing the default
is often enough, and it probably is all you need if you are only using
the logs (e.g. with an ELK aggregator). If you are exporting span data
to Zipkin or Spring Cloud Stream, there is also an <literal>AlwaysSampler</literal>
that exports everything and a <literal>PercentageBasedSampler</literal> that samples a
fixed fraction of spans.</simpara>
<note>
<simpara>the <literal>PercentageBasedSampler</literal> is the default if you are using
<literal>spring-cloud-sleuth-zipkin</literal> or <literal>spring-cloud-sleuth-stream</literal>. You can
configure the exports using <literal>spring.sleuth.sampler.percentage</literal>. The passed
value needs to be a double from <literal>0.0</literal> to <literal>1.0</literal> so it&#8217;s not a percentage.
For backwards compatibility reasons we&#8217;re not changing the property name.</simpara>
</note>
<simpara>A sampler can be installed just by creating a bean definition, e.g:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bean
public Sampler defaultSampler() {
	return new AlwaysSampler();
}</programlisting>
<tip>
<simpara>You can set the HTTP header <literal>X-B3-Flags</literal> to <literal>1</literal> or when doing messaging you can
set <literal>spanFlags</literal> header to <literal>1</literal>. Then the current span will be forced to be exportable
regardless of the sampling decision.</simpara>
</tip>
</chapter>
<chapter xml:id="_instrumentation">
<title>Instrumentation</title>
<simpara>Spring Cloud Sleuth instruments all your Spring application
automatically, so you shouldn&#8217;t have to do anything to activate
it. The instrumentation is added using a variety of technologies
according to the stack that is available, e.g. for a servlet web
application we use a <literal>Filter</literal>, and for Spring Integration we use
<literal>ChannelInterceptors</literal>.</simpara>
<simpara>You can customize the keys used in span tags. To limit the volume of
span data, by default an HTTP request will be tagged only with a
handful of metadata like the status code, host and URL. You can add
request headers by configuring <literal>spring.sleuth.keys.http.headers</literal> (a
list of header names).</simpara>
<note>
<simpara>Remember that tags are only collected and exported if there is a
<literal>Sampler</literal> that allows it (by default there is not, so there is no
danger of accidentally collecting too much data without configuring
something).</simpara>
</note>
<note>
<simpara>Currently the instrumentation in Spring Cloud Sleuth is eager - it means that
we&#8217;re actively trying to pass the tracing context between threads. Also timing events
are captured even when sleuth isn&#8217;t exporting data to a tracing system.
This approach may change in the future towards being lazy on this matter.</simpara>
</note>
</chapter>
<chapter xml:id="_span_lifecycle">
<title>Span lifecycle</title>
<simpara>You can do the following operations on the Span by means of <emphasis role="strong">org.springframework.cloud.sleuth.Tracer</emphasis> interface:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="creating-and-closing-spans">start</link> - when you start a span its name is assigned and start timestamp is recorded.</simpara>
</listitem>
<listitem>
<simpara><link linkend="creating-and-closing-spans">close</link> - the span gets finished (the end time of the span is recorded) and if
the span is <emphasis role="strong">exportable</emphasis> then it will be eligible for collection to Zipkin.
The span is also removed from the current thread.</simpara>
</listitem>
<listitem>
<simpara><link linkend="continuing-spans">continue</link> - a new instance of span will be created whereas it will be a copy of the
one that it continues.</simpara>
</listitem>
<listitem>
<simpara><link linkend="continuing-spans">detach</link> - the span doesn&#8217;t get stopped or closed. It only gets removed from the current thread.</simpara>
</listitem>
<listitem>
<simpara><link linkend="creating-spans-with-explicit-parent">create with explicit parent</link> - you can create a new span and set an explicit parent to it</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>Spring creates the instance of <literal>Tracer</literal> for you. In order to use it all you need is to just autowire it.</simpara>
</tip>
<section xml:id="creating-and-closing-spans">
<title>Creating and closing spans</title>
<simpara>You can manually create spans by using the <emphasis role="strong">Tracer</emphasis> interface.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Start a span. If there was a span present in this thread it will become
// the `newSpan`'s parent.
Span newSpan = this.tracer.createSpan("calculateTax");
try {
	// ...
	// You can tag a span
	this.tracer.addTag("taxValue", taxValue);
	// ...
	// You can log an event on a span
	newSpan.logEvent("taxCalculated");
} finally {
	// Once done remember to close the span. This will allow collecting
	// the span to send it to Zipkin
	this.tracer.close(newSpan);
}</programlisting>
<simpara>In this example we could see how to create a new instance of span. Assuming that there already
was a span present in this thread then it would become the parent of that span.</simpara>
<important>
<simpara>Always clean after you create a span! Don&#8217;t forget to close a span if you want to send it to Zipkin.</simpara>
</important>
<important>
<simpara>If your span contains a name greater than 50 chars, then that name will
be truncated to 50 chars. Your names have to be explicit and concrete. Big names lead to
latency issues and sometimes even thrown exceptions.</simpara>
</important>
</section>
<section xml:id="continuing-spans">
<title>Continuing spans</title>
<simpara>Sometimes you don&#8217;t want to create a new span but you want to continue one. Example of such a
situation might be (of course it all depends on the use-case):</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">AOP</emphasis> - If there was already a span created before an aspect was reached then you might not want to create a new span.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hystrix</emphasis> - executing a Hystrix command is most likely a logical part of the current processing. It&#8217;s in fact
only a technical implementation detail that you wouldn&#8217;t necessarily want to reflect in tracing as a separate being.</simpara>
</listitem>
</itemizedlist>
<simpara>The continued instance of span is equal to the one that it continues:</simpara>
<programlisting language="java" linenumbering="unnumbered">Span continuedSpan = this.tracer.continueSpan(spanToContinue);
assertThat(continuedSpan).isEqualTo(spanToContinue);</programlisting>
<simpara>To continue a span you can use the <emphasis role="strong">Tracer</emphasis> interface.</simpara>
<programlisting language="java" linenumbering="unnumbered">// let's assume that we're in a thread Y and we've received
// the `initialSpan` from thread X
Span continuedSpan = this.tracer.continueSpan(initialSpan);
try {
	// ...
	// You can tag a span
	this.tracer.addTag("taxValue", taxValue);
	// ...
	// You can log an event on a span
	continuedSpan.logEvent("taxCalculated");
} finally {
	// Once done remember to detach the span. That way you'll
	// safely remove it from the current thread without closing it
	this.tracer.detach(continuedSpan);
}</programlisting>
<important>
<simpara>Always clean after you create a span! Don&#8217;t forget to detach a span if some work was done started in one
 thread (e.g. thread X) and it&#8217;s waiting for other threads (e.g. Y, Z) to finish.
 Then the spans in the threads Y, Z should be detached at the end of their work. When the results are collected
 the span in thread X should be closed.</simpara>
</important>
</section>
<section xml:id="creating-spans-with-explicit-parent">
<title>Creating spans with an explicit parent</title>
<simpara>There is a possibility that you want to start a new span and provide an explicit parent of that span.
Let&#8217;s assume that the parent of a span is in one thread and you want to start a new span in another thread. The
<literal>startSpan</literal> method of the <literal>Tracer</literal> interface is the method you are looking for.</simpara>
<programlisting language="java" linenumbering="unnumbered">// let's assume that we're in a thread Y and we've received
// the `initialSpan` from thread X. `initialSpan` will be the parent
// of the `newSpan`
Span newSpan = this.tracer.createSpan("calculateCommission", initialSpan);
try {
	// ...
	// You can tag a span
	this.tracer.addTag("commissionValue", commissionValue);
	// ...
	// You can log an event on a span
	newSpan.logEvent("commissionCalculated");
} finally {
	// Once done remember to close the span. This will allow collecting
	// the span to send it to Zipkin. The tags and events set on the
	// newSpan will not be present on the parent
	this.tracer.close(newSpan);
}</programlisting>
<important>
<simpara>After having created such a span remember to close it. Otherwise you will see a lot of warnings in your logs
 related to the fact that you have a span present in the current thread other than the one you&#8217;re trying to close.
 What&#8217;s worse your spans won&#8217;t get closed properly thus will not get collected to Zipkin.</simpara>
</important>
</section>
</chapter>
<chapter xml:id="_naming_spans">
<title>Naming spans</title>
<simpara>Picking a span name is not a trivial task. Span name should depict an operation name. The name should
be low cardinality (e.g. not include identifiers).</simpara>
<simpara>Since there is a lot of instrumentation going on some of the span names will be
artificial like:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>controller-method-name</literal> when received by a Controller with a method name <literal>conrollerMethodName</literal></simpara>
</listitem>
<listitem>
<simpara><literal>async</literal> for asynchronous operations done via wrapped <literal>Callable</literal> and <literal>Runnable</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>@Scheduled</literal> annotated methods will return the simple name of the class.</simpara>
</listitem>
</itemizedlist>
<simpara>Fortunately, for the asynchronous processing you can provide explicit naming.</simpara>
<section xml:id="__spanname_annotation">
<title>@SpanName annotation</title>
<simpara>You can name the span explicitly via the <literal>@SpanName</literal> annotation.</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpanName("calculateTax")
class TaxCountingRunnable implements Runnable {

	@Override public void run() {
		// perform logic
	}
}</programlisting>
<simpara>In this case, when processed in the following manner:</simpara>
<programlisting language="java" linenumbering="unnumbered">Runnable runnable = new TraceRunnable(tracer, spanNamer, new TaxCountingRunnable());
Future&lt;?&gt; future = executorService.submit(runnable);
// ... some additional logic ...
future.get();</programlisting>
<simpara>The span will be named <literal>calculateTax</literal>.</simpara>
</section>
<section xml:id="_tostring_method">
<title>toString() method</title>
<simpara>It&#8217;s pretty rare to create separate classes for <literal>Runnable</literal> or <literal>Callable</literal>. Typically one creates an anonymous
instance of those classes. You can&#8217;t annotate such classes thus to override that, if there is no <literal>@SpanName</literal> annotation present,
we&#8217;re checking if the class has a custom implementation of the <literal>toString()</literal> method.</simpara>
<simpara>So executing such code:</simpara>
<programlisting language="java" linenumbering="unnumbered">Runnable runnable = new TraceRunnable(tracer, spanNamer, new Runnable() {
	@Override public void run() {
		// perform logic
	}

	@Override public String toString() {
		return "calculateTax";
	}
});
Future&lt;?&gt; future = executorService.submit(runnable);
// ... some additional logic ...
future.get();</programlisting>
<simpara>will lead in creating a span named <literal>calculateTax</literal>.</simpara>
</section>
</chapter>
<chapter xml:id="_managing_spans_with_annotations">
<title>Managing spans with annotations</title>
<section xml:id="_rationale">
<title>Rationale</title>
<simpara>The main arguments for this features are</simpara>
<itemizedlist>
<listitem>
<simpara>api-agnostic means to collaborate with a span</simpara>
<itemizedlist>
<listitem>
<simpara>use of annotations allows users to add to a span with no library dependency on a span api.
This allows Sleuth to change its core api less impact to user code.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>reduced surface area for basic span operations.</simpara>
<itemizedlist>
<listitem>
<simpara>without this feature one has to use the span api, which has lifecycle commands that
could be used incorrectly. By only exposing scope, tag and log functionality, users can
collaborate without accidentally breaking span lifecycle.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>collaboration with runtime generated code</simpara>
<itemizedlist>
<listitem>
<simpara>with libraries such as Spring Data / Feign the implementations of interfaces are generated
at runtime thus span wrapping of objects was tedious. Now you can provide annotations
 over interfaces and arguments of those interfaces</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_creating_new_spans">
<title>Creating new spans</title>
<simpara>If you really don&#8217;t want to take care of creating local spans manually you can profit from the
<literal>@NewSpan</literal> annotation. Also we give you the <literal>@SpanTag</literal> annotation to add tags in an automated
fashion.</simpara>
<simpara>Let&#8217;s look at some examples of usage.</simpara>
<programlisting language="java" linenumbering="unnumbered">@NewSpan
void testMethod();</programlisting>
<simpara>Annotating the method without any parameter will lead to a creation of a new span whose name
will be equal to annotated method name.</simpara>
<programlisting language="java" linenumbering="unnumbered">@NewSpan("customNameOnTestMethod4")
void testMethod4();</programlisting>
<simpara>If you provide the value in the annotation (either directly or via the <literal>name</literal> parameter) then
the created span will have the name as the provided value.</simpara>
<programlisting language="java" linenumbering="unnumbered">// method declaration
@NewSpan(name = "customNameOnTestMethod5")
void testMethod5(@SpanTag("testTag") String param);

// and method execution
this.testBean.testMethod5("test");</programlisting>
<simpara>You can combine both the name and a tag. Let&#8217;s focus on the latter. In this case whatever the value of
the annotated method&#8217;s parameter runtime value will be - that will be the value of the tag. In our sample
the tag key will be <literal>testTag</literal> and the tag value will be <literal>test</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@NewSpan(name = "customNameOnTestMethod3")
@Override
public void testMethod3() {
}</programlisting>
<simpara>You can place the <literal>@NewSpan</literal> annotation on both the class and an interface. If you override the
interface&#8217;s method and provide a different value of the <literal>@NewSpan</literal> annotation then the most
concrete one wins (in this case <literal>customNameOnTestMethod3</literal> will be set).</simpara>
</section>
<section xml:id="_continuing_spans">
<title>Continuing spans</title>
<simpara>If you want to just add tags and annotations to an existing span it&#8217;s enough
to use the <literal>@ContinueSpan</literal> annotation as presented below. Note that in contrast
with the <literal>@NewSpan</literal> annotation you can also add logs via the <literal>log</literal> parameter:</simpara>
<programlisting language="java" linenumbering="unnumbered">// method declaration
@ContinueSpan(log = "testMethod11")
void testMethod11(@SpanTag("testTag11") String param);

// method execution
this.testBean.testMethod11("test");</programlisting>
<simpara>That way the span will get continued and:</simpara>
<itemizedlist>
<listitem>
<simpara>logs with name <literal>testMethod11.before</literal> and <literal>testMethod11.after</literal> will be created</simpara>
</listitem>
<listitem>
<simpara>if an exception will be thrown a log <literal>testMethod11.afterFailure</literal> will also be created</simpara>
</listitem>
<listitem>
<simpara>tag with key <literal>testTag11</literal> and value <literal>test</literal> will be created</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_more_advanced_tag_setting">
<title>More advanced tag setting</title>
<simpara>There are 3 different ways to add tags to a span. All of them are controlled by the <literal>SpanTag</literal> annotation.
Precedence is:</simpara>
<itemizedlist>
<listitem>
<simpara>try with the bean of <literal>TagValueResolver</literal> type and provided name</simpara>
</listitem>
<listitem>
<simpara>if one hasn&#8217;t provided the bean name, try to evaluate an expression. We&#8217;re searching for a <literal>TagValueExpressionResolver</literal> bean.
The default implementation uses SPEL expression resolution.</simpara>
</listitem>
<listitem>
<simpara>if one hasn&#8217;t provided any expression to evaluate just return a <literal>toString()</literal> value of the parameter</simpara>
</listitem>
</itemizedlist>
<section xml:id="_custom_extractor">
<title>Custom extractor</title>
<simpara>The value of the tag for following method will be computed by an implementation of <literal>TagValueResolver</literal> interface.
Its class name has to be passed as the value of the <literal>resolver</literal> attribute.</simpara>
<simpara>Having such an annotated method:</simpara>
<programlisting language="java" linenumbering="unnumbered">@NewSpan
public void getAnnotationForTagValueResolver(@SpanTag(key = "test", resolver = TagValueResolver.class) String test) {
}</programlisting>
<simpara>and such a <literal>TagValueResolver</literal> bean implementation</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bean(name = "myCustomTagValueResolver")
public TagValueResolver tagValueResolver() {
	return parameter -&gt; "Value from myCustomTagValueResolver";
}</programlisting>
<simpara>Will lead to setting of a tag value equal to <literal>Value from myCustomTagValueResolver</literal>.</simpara>
</section>
<section xml:id="_resolving_expressions_for_value">
<title>Resolving expressions for value</title>
<simpara>Having such an annotated method:</simpara>
<programlisting language="java" linenumbering="unnumbered">@NewSpan
public void getAnnotationForTagValueExpression(@SpanTag(key = "test", expression = "length() + ' characters'") String test) {
}</programlisting>
<simpara>and no custom implementation of a <literal>TagValueExpressionResolver</literal> will lead to evaluation of the SPEL expression and a tag with value <literal>4 characters</literal> will be set on the span.
If you want to use some other expression resolution mechanism you can create your own implementation
of the bean.</simpara>
</section>
<section xml:id="_using_tostring_method">
<title>Using toString method</title>
<simpara>Having such an annotated method:</simpara>
<programlisting language="java" linenumbering="unnumbered">@NewSpan
public void getAnnotationForArgumentToString(@SpanTag("test") Long param) {
}</programlisting>
<simpara>if executed with a value of <literal>15</literal> will lead to setting of a tag with a String value of <literal>"15"</literal>.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="_customizations">
<title>Customizations</title>
<simpara>Thanks to the <literal>SpanInjector</literal> and <literal>SpanExtractor</literal> you can customize the way spans
are created and propagated.</simpara>
<simpara>There are currently two built-in ways to pass tracing information between processes:</simpara>
<itemizedlist>
<listitem>
<simpara>via Spring Integration</simpara>
</listitem>
<listitem>
<simpara>via HTTP</simpara>
</listitem>
</itemizedlist>
<simpara>Span ids are extracted from Zipkin-compatible (B3) headers (either <literal>Message</literal>
or HTTP headers), to start or join an existing trace. Trace information is
injected into any outbound requests so the next hop can extract them.</simpara>
<simpara>The key change in comparison to the previous versions of Sleuth is that Sleuth is implementing
the Open Tracing&#8217;s <literal>TextMap</literal> notion. In Sleuth it&#8217;s called <literal>SpanTextMap</literal>. Basically the idea
is that any means of communication (e.g. message, http request, etc.) can be abstracted via
a <literal>SpanTextMap</literal>. This abstraction defines how one can insert data into the carrier and
how to retrieve it from there. Thanks to this if you want to instrument a new HTTP library
that uses a <literal>FooRequest</literal> as a mean of sending HTTP requests then you have to create an
implementation of  a <literal>SpanTextMap</literal> that delegates calls to <literal>FooRequest</literal> in terms of retrieval
and insertion of HTTP headers.</simpara>
<section xml:id="_spring_integration">
<title>Spring Integration</title>
<simpara>For Spring Integration there are 2 interfaces responsible for creation of a Span from a <literal>Message</literal>.
These are:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>MessagingSpanTextMapExtractor</literal></simpara>
</listitem>
<listitem>
<simpara><literal>MessagingSpanTextMapInjector</literal></simpara>
</listitem>
</itemizedlist>
<simpara>You can override them by providing your own implementation.</simpara>
</section>
<section xml:id="_http">
<title>HTTP</title>
<simpara>For HTTP there are 2 interfaces responsible for creation of a Span from a <literal>Message</literal>.
These are:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>HttpSpanExtractor</literal></simpara>
</listitem>
<listitem>
<simpara><literal>HttpSpanInjector</literal></simpara>
</listitem>
</itemizedlist>
<simpara>You can override them by providing your own implementation.</simpara>
</section>
<section xml:id="_example">
<title>Example</title>
<simpara>Let&#8217;s assume that instead of the standard Zipkin compatible tracing HTTP header names
you have</simpara>
<itemizedlist>
<listitem>
<simpara>for trace id - <literal>correlationId</literal></simpara>
</listitem>
<listitem>
<simpara>for span id - <literal>mySpanId</literal></simpara>
</listitem>
</itemizedlist>
<simpara>This is a an example of a <literal>SpanExtractor</literal></simpara>
<programlisting language="java" linenumbering="unnumbered">static class CustomHttpSpanExtractor implements HttpSpanExtractor {

	@Override public Span joinTrace(SpanTextMap carrier) {
		Map&lt;String, String&gt; map = TextMapUtil.asMap(carrier);
		long traceId = Span.hexToId(map.get("correlationid"));
		long spanId = Span.hexToId(map.get("myspanid"));
		// extract all necessary headers
		Span.SpanBuilder builder = Span.builder().traceId(traceId).spanId(spanId);
		// build rest of the Span
		return builder.build();
	}
}

static class CustomHttpSpanInjector implements HttpSpanInjector {

	@Override
	public void inject(Span span, SpanTextMap carrier) {
		carrier.put("correlationId", span.traceIdString());
		carrier.put("mySpanId", Span.idToHex(span.getSpanId()));
	}
}</programlisting>
<simpara>And you could register it like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bean
HttpSpanInjector customHttpSpanInjector() {
	return new CustomHttpSpanInjector();
}

@Bean
HttpSpanExtractor customHttpSpanExtractor() {
	return new CustomHttpSpanExtractor();
}</programlisting>
<simpara>Spring Cloud Sleuth does not add trace/span related headers to the Http Response for security reasons. If you need the headers then a custom <literal>SpanInjector</literal>
that injects the headers into the Http Response and a Servlet filter which makes use of this can be added the following way:</simpara>
<programlisting language="java" linenumbering="unnumbered">static class CustomHttpServletResponseSpanInjector extends ZipkinHttpSpanInjector {

	@Override
	public void inject(Span span, SpanTextMap carrier) {
		super.inject(span, carrier);
		carrier.put(Span.TRACE_ID_NAME, span.traceIdString());
		carrier.put(Span.SPAN_ID_NAME, Span.idToHex(span.getSpanId()));
	}
}

static class HttpResponseInjectingTraceFilter extends GenericFilterBean {

	private final Tracer tracer;
	private final HttpSpanInjector spanInjector;

	public HttpResponseInjectingTraceFilter(Tracer tracer, HttpSpanInjector spanInjector) {
		this.tracer = tracer;
		this.spanInjector = spanInjector;
	}

	@Override
	public void doFilter(ServletRequest request, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
		HttpServletResponse response = (HttpServletResponse) servletResponse;
		Span currentSpan = this.tracer.getCurrentSpan();
		this.spanInjector.inject(currentSpan, new HttpServletResponseTextMap(response));
		filterChain.doFilter(request, response);
	}

	 class HttpServletResponseTextMap implements SpanTextMap {

		 private final HttpServletResponse delegate;

		 HttpServletResponseTextMap(HttpServletResponse delegate) {
			 this.delegate = delegate;
		 }

		 @Override
		 public Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() {
			 Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
			 for (String header : this.delegate.getHeaderNames()) {
				map.put(header, this.delegate.getHeader(header));
			 }
			 return map.entrySet().iterator();
		 }

		 @Override
		 public void put(String key, String value) {
			this.delegate.addHeader(key, value);
		 }
	 }
}</programlisting>
<simpara>And you could register them like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bean HttpSpanInjector customHttpServletResponseSpanInjector() {
	return new CustomHttpServletResponseSpanInjector();
}

@Bean
HttpResponseInjectingTraceFilter responseInjectingTraceFilter(Tracer tracer) {
	return new HttpResponseInjectingTraceFilter(tracer, customHttpServletResponseSpanInjector());
}</programlisting>
</section>
<section xml:id="_tracefilter">
<title>TraceFilter</title>
<simpara>You can also modify the behaviour of the <literal>TraceFilter</literal> - the component that is responsible
for processing the input HTTP request and adding tags basing on the HTTP response. You can customize
the tags, or modify the response headers by registering your own instance of the <literal>TraceFilter</literal> bean.</simpara>
<simpara>In the following example we will register the <literal>TraceFilter</literal> bean and we will add the
<literal>ZIPKIN-TRACE-ID</literal> response header containing the current Span&#8217;s trace id. Also we will
add to the Span a tag with key <literal>custom</literal> and a value <literal>tag</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bean
TraceFilter myTraceFilter(BeanFactory beanFactory, final Tracer tracer) {
	return new TraceFilter(beanFactory) {
		@Override protected void addResponseTags(HttpServletResponse response,
				Throwable e) {
			// execute the default behaviour
			super.addResponseTags(response, e);
			// for readability we're returning trace id in a hex form
			response.addHeader("ZIPKIN-TRACE-ID",
					Span.idToHex(tracer.getCurrentSpan().getTraceId()));
			// we can also add some custom tags
			tracer.addTag("custom", "tag");
		}
	};
}</programlisting>
</section>
<section xml:id="_custom_sa_tag_in_zipkin">
<title>Custom SA tag in Zipkin</title>
<simpara>Sometimes you want to create a manual Span that will wrap a call to an external service which is not instrumented.
What you can do is to create a span with the <literal>peer.service</literal> tag that will contain a value of the service that you want to call.
Below you can see an example of a call to Redis that is wrapped in such a span.</simpara>
<programlisting language="java" linenumbering="unnumbered">org.springframework.cloud.sleuth.Span newSpan = tracer.createSpan("redis");
try {
	newSpan.tag("redis.op", "get");
	newSpan.tag("lc", "redis");
	newSpan.logEvent(org.springframework.cloud.sleuth.Span.CLIENT_SEND);
	// call redis service e.g
	// return (SomeObj) redisTemplate.opsForHash().get("MYHASH", someObjKey);
} finally {
	newSpan.tag("peer.service", "redisService");
	newSpan.tag("peer.ipv4", "1.2.3.4");
	newSpan.tag("peer.port", "1234");
	newSpan.logEvent(org.springframework.cloud.sleuth.Span.CLIENT_RECV);
	tracer.close(newSpan);
}</programlisting>
<important>
<simpara>Remember not to add both <literal>peer.service</literal> tag and the <literal>SA</literal> tag! You have to add only <literal>peer.service</literal>.</simpara>
</important>
</section>
<section xml:id="_custom_service_name">
<title>Custom service name</title>
<simpara>By default Sleuth assumes that when you send a span to Zipkin, you want the span&#8217;s service name
 to be equal to <literal>spring.application.name</literal> value. That&#8217;s not always the case though. There
 are situations in which you want to explicitly provide a different service name for all spans coming
 from your application. To achieve that it&#8217;s enough to just pass the following property
 to your application to override that value (example for <literal>foo</literal> service name):</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring.zipkin.service.name: foo</programlisting>
</section>
<section xml:id="_customization_of_reported_spans">
<title>Customization of reported spans</title>
<simpara>Before reporting spans to e.g. Zipkin you can be interested in modifying that span in some way.
 You can achieve that by using the <literal>SpanAdjuster</literal> interface.</simpara>
<simpara>Example of usage:</simpara>
<simpara>In Sleuth we&#8217;re generating spans with a fixed name. Some users want to modify the name depending on values
of tags. Implementation of the <literal>SpanAdjuster</literal> interface can be used to alter that name. Example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">@Bean
SpanAdjuster customSpanAdjuster() {
    return span -&gt; span.toBuilder().name(scrub(span.getName())).build();
}</programlisting>
<simpara>This will lead in changing the name of the reported span just before it gets sent to Zipkin.</simpara>
<important>
<simpara>Your <literal>SpanReporter</literal> should inject the <literal>SpanAdjuster</literal> and
 allow span manipulation before the actual reporting is done.</simpara>
</important>
</section>
<section xml:id="_host_locator">
<title>Host locator</title>
<simpara>In order to define the host that is corresponding to a particular span we need to resolve the host name
and port. The default approach is to take it from server properties. If those for some reason are not set
then we&#8217;re trying to retrieve the host name from the network interfaces.</simpara>
<simpara>If you have the discovery client enabled and prefer to retrieve the host address from the registered
instance in a service registry then you have to set the property (it&#8217;s applicable for both HTTP and
Stream based span reporting).</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring.zipkin.locator.discovery.enabled: true</programlisting>
</section>
</chapter>
<chapter xml:id="_sending_spans_to_zipkin">
<title>Sending spans to Zipkin</title>
<simpara>By default if you add <literal>spring-cloud-starter-zipkin</literal> as a dependency to your project,
when the span is closed, it will be sent to Zipkin over HTTP. The communication
is asynchronous. You can configure the URL by setting the <literal>spring.zipkin.baseUrl</literal>
property as follows:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring.zipkin.baseUrl: https://192.168.99.100:9411/</programlisting>
<simpara>If you want to find Zipkin via service discovery it&#8217;s enough to pass the
Zipkin&#8217;s service id inside the URL (example for <literal>zipkinserver</literal> service id)</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring.zipkin.baseUrl: http://zipkinserver/</programlisting>
</chapter>
<chapter xml:id="_span_data_as_messages">
<title>Span Data as Messages</title>
<simpara>You can accumulate and send span data over
<link xl:href="https://cloud.spring.io/spring-cloud-stream">Spring Cloud Stream</link> by
including the <literal>spring-cloud-sleuth-stream</literal> jar as a dependency, and
adding a Channel Binder implementation
(e.g. <literal>spring-cloud-starter-stream-rabbit</literal> for RabbitMQ or
<literal>spring-cloud-starter-stream-kafka</literal> for Kafka). This will
automatically turn your app into a producer of messages with payload
type <literal>Spans</literal>. The channel name to which the spans will be sent
is called <literal>sleuth</literal>.</simpara>
<section xml:id="_zipkin_consumer">
<title>Zipkin Consumer</title>
<simpara>There is a special convenience annotation for setting up a message consumer
for the Span data and pushing it into a Zipkin <literal>SpanStore</literal>. This application</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableZipkinStreamServer
public class Consumer {
	public static void main(String[] args) {
		SpringApplication.run(Consumer.class, args);
	}
}</programlisting>
<simpara>will listen for the Span data on whatever transport you provide via a
Spring Cloud Stream <literal>Binder</literal> (e.g. include
<literal>spring-cloud-starter-stream-rabbit</literal> for RabbitMQ, and similar
starters exist for Redis and Kafka). If you add the following UI dependency</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;
&lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;</programlisting>
<simpara>Then you&#8217;ll have your app a
<link xl:href="https://github.com/openzipkin/zipkin">Zipkin server</link>, which hosts
the UI and api on port 9411.</simpara>
<simpara>The default <literal>SpanStore</literal> is in-memory (good for demos and getting
started quickly). For a more robust solution you can add MySQL and
<literal>spring-boot-starter-jdbc</literal> to your classpath and enable the JDBC
<literal>SpanStore</literal> via configuration, e.g.:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spring:
  rabbitmq:
    host: ${RABBIT_HOST:localhost}
  datasource:
    schema: classpath:/mysql.sql
    url: jdbc:mysql://${MYSQL_HOST:localhost}/test
    username: root
    password: root
# Switch this on to create the schema on startup:
    initialize: true
    continueOnError: true
  sleuth:
    enabled: false
zipkin:
  storage:
    type: mysql</programlisting>
<note>
<simpara>The <literal>@EnableZipkinStreamServer</literal> is also annotated with
<literal>@EnableZipkinServer</literal> so the process will also expose the standard
Zipkin server endpoints for collecting spans over HTTP, and for
querying in the Zipkin Web UI.</simpara>
</note>
</section>
<section xml:id="_custom_consumer">
<title>Custom Consumer</title>
<simpara>A custom consumer can also easily be implemented using
<literal>spring-cloud-sleuth-stream</literal> and binding to the <literal>SleuthSink</literal>. Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableBinding(SleuthSink.class)
@SpringBootApplication(exclude = SleuthStreamAutoConfiguration.class)
@MessageEndpoint
public class Consumer {

    @ServiceActivator(inputChannel = SleuthSink.INPUT)
    public void sink(Spans input) throws Exception {
        // ... process spans
    }
}</programlisting>
<note>
<simpara>the sample consumer application above explicitly excludes
<literal>SleuthStreamAutoConfiguration</literal> so it doesn&#8217;t send messages to itself,
but this is optional (you might actually want to trace requests into
the consumer app).</simpara>
</note>
<simpara>In order to customize the polling mechanism you can create a bean of <literal>PollerMetadata</literal> type
with name equal to <literal>StreamSpanReporter.POLLER</literal>. Here you can find an example of such a configuration.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
public static class CustomPollerConfiguration {

	@Bean(name = StreamSpanReporter.POLLER)
	PollerMetadata customPoller() {
		PollerMetadata poller = new PollerMetadata();
		poller.setMaxMessagesPerPoll(500);
		poller.setTrigger(new PeriodicTrigger(5000L));
		return poller;
	}
}</programlisting>
</section>
</chapter>
<chapter xml:id="_metrics">
<title>Metrics</title>
<simpara>Currently Spring Cloud Sleuth registers very simple metrics related to spans.
It&#8217;s using the <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html#production-ready-recording-metrics">Spring Boot&#8217;s metrics support</link>
to calculate the number of accepted and dropped spans. Each time a span gets
sent to Zipkin the number of accepted spans will increase. If there&#8217;s an error then
the number of dropped spans will get increased.</simpara>
</chapter>
<chapter xml:id="_integrations">
<title>Integrations</title>
<section xml:id="_runnable_and_callable">
<title>Runnable and Callable</title>
<simpara>If you&#8217;re wrapping your logic in <literal>Runnable</literal> or <literal>Callable</literal> it&#8217;s enough to wrap those classes in their Sleuth representative.</simpara>
<simpara>Example for <literal>Runnable</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">Runnable runnable = new Runnable() {
	@Override
	public void run() {
		// do some work
	}

	@Override
	public String toString() {
		return "spanNameFromToStringMethod";
	}
};
// Manual `TraceRunnable` creation with explicit "calculateTax" Span name
Runnable traceRunnable = new TraceRunnable(tracer, spanNamer, runnable, "calculateTax");
// Wrapping `Runnable` with `Tracer`. The Span name will be taken either from the
// `@SpanName` annotation or from `toString` method
Runnable traceRunnableFromTracer = tracer.wrap(runnable);</programlisting>
<simpara>Example for <literal>Callable</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">Callable&lt;String&gt; callable = new Callable&lt;String&gt;() {
	@Override
	public String call() throws Exception {
		return someLogic();
	}

	@Override
	public String toString() {
		return "spanNameFromToStringMethod";
	}
};
// Manual `TraceCallable` creation with explicit "calculateTax" Span name
Callable&lt;String&gt; traceCallable = new TraceCallable&lt;&gt;(tracer, spanNamer, callable, "calculateTax");
// Wrapping `Callable` with `Tracer`. The Span name will be taken either from the
// `@SpanName` annotation or from `toString` method
Callable&lt;String&gt; traceCallableFromTracer = tracer.wrap(callable);</programlisting>
<simpara>That way you will ensure that a new Span is created and closed for each execution.</simpara>
</section>
<section xml:id="_hystrix">
<title>Hystrix</title>
<section xml:id="_custom_concurrency_strategy">
<title>Custom Concurrency Strategy</title>
<simpara>We&#8217;re registering a custom <link xl:href="https://github.com/Netflix/Hystrix/wiki/Plugins#concurrencystrategy"><literal>HystrixConcurrencyStrategy</literal></link>
that wraps all <literal>Callable</literal> instances into their Sleuth representative -
the <literal>TraceCallable</literal>. The strategy either starts or continues a span depending on the fact whether tracing was already going
on before the Hystrix command was called. To disable the custom Hystrix Concurrency Strategy set the <literal>spring.sleuth.hystrix.strategy.enabled</literal> to <literal>false</literal>.</simpara>
</section>
<section xml:id="_manual_command_setting">
<title>Manual Command setting</title>
<simpara>Assuming that you have the following <literal>HystrixCommand</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">HystrixCommand&lt;String&gt; hystrixCommand = new HystrixCommand&lt;String&gt;(setter) {
	@Override
	protected String run() throws Exception {
		return someLogic();
	}
};</programlisting>
<simpara>In order to pass the tracing information you have to wrap the same logic in the Sleuth version of the <literal>HystrixCommand</literal> which is the
<literal>TraceCommand</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">TraceCommand&lt;String&gt; traceCommand = new TraceCommand&lt;String&gt;(tracer, traceKeys, setter) {
	@Override
	public String doRun() throws Exception {
		return someLogic();
	}
};</programlisting>
</section>
</section>
<section xml:id="_rxjava">
<title>RxJava</title>
<simpara>We&#8217;re registering a custom <link xl:href="https://github.com/ReactiveX/RxJava/wiki/Plugins#rxjavaschedulershook"><literal>RxJavaSchedulersHook</literal></link>
that wraps all <literal>Action0</literal> instances into their Sleuth representative -
the <literal>TraceAction</literal>. The hook either starts or continues a span depending on the fact whether tracing was already going
on before the Action was scheduled. To disable the custom RxJavaSchedulersHook set the <literal>spring.sleuth.rxjava.schedulers.hook.enabled</literal> to <literal>false</literal>.</simpara>
<simpara>You can define a list of regular expressions for thread names, for which you don&#8217;t want a Span to be created. Just provide a comma separated list
of regular expressions in the <literal>spring.sleuth.rxjava.schedulers.ignoredthreads</literal> property.</simpara>
</section>
<section xml:id="_http_integration">
<title>HTTP integration</title>
<simpara>Features from this section can be disabled by providing the <literal>spring.sleuth.web.enabled</literal> property with value equal to <literal>false</literal>.</simpara>
<section xml:id="_http_filter">
<title>HTTP Filter</title>
<simpara>Via the <literal>TraceFilter</literal> all sampled incoming requests result in creation of a Span. That Span&#8217;s name is <literal>http:</literal> + the path to which
 the request was sent. E.g. if the request was sent to <literal>/foo/bar</literal> then the name will be <literal>http:/foo/bar</literal>. You can configure which URIs you would
 like to skip via the <literal>spring.sleuth.web.skipPattern</literal> property. If you have <literal>ManagementServerProperties</literal> on classpath then
 its value of <literal>contextPath</literal> gets appended to the provided skip pattern.</simpara>
</section>
<section xml:id="_handlerinterceptor">
<title>HandlerInterceptor</title>
<simpara>Since we want the span names to be precise we&#8217;re using a <literal>TraceHandlerInterceptor</literal> that either wraps an
 existing <literal>HandlerInterceptor</literal> or is added directly to the list of existing <literal>HandlerInterceptors</literal>. The
 <literal>TraceHandlerInterceptor</literal> adds a special request attribute to the given <literal>HttpServletRequest</literal>. If the
 the <literal>TraceFilter</literal> doesn&#8217;t see this attribute set it will create a "fallback" span which is an additional
 span created on the server side so that the trace is presented properly in the UI. Seeing that most likely
 signifies that there is a missing instrumentation. In that case please file an issue in Spring Cloud Sleuth.</simpara>
</section>
<section xml:id="_async_servlet_support">
<title>Async Servlet support</title>
<simpara>If your controller returns a <literal>Callable</literal> or a <literal>WebAsyncTask</literal> Spring Cloud Sleuth will continue the existing span instead of creating a new one.</simpara>
</section>
</section>
<section xml:id="_http_client_integration">
<title>HTTP client integration</title>
<section xml:id="_synchronous_rest_template">
<title>Synchronous Rest Template</title>
<simpara>We&#8217;re injecting a <literal>RestTemplate</literal> interceptor that ensures that all the tracing information is passed to the requests. Each time a
call is made a new Span is created. It gets closed upon receiving the response. In order to block the synchronous <literal>RestTemplate</literal> features
just set <literal>spring.sleuth.web.client.enabled</literal> to <literal>false</literal>.</simpara>
<important>
<simpara>You have to register <literal>RestTemplate</literal> as a bean so that the interceptors will get injected.
If you create a <literal>RestTemplate</literal> instance with a <literal>new</literal> keyword then the instrumentation WILL NOT work.</simpara>
</important>
</section>
<section xml:id="_asynchronous_rest_template">
<title>Asynchronous Rest Template</title>
<important>
<simpara>A traced version of an <literal>AsyncRestTemplate</literal> bean is registered for you out of the box. If you
have your own bean you have to wrap it in a <literal>TraceAsyncRestTemplate</literal> representation. The best solution
is to only customize the <literal>ClientHttpRequestFactory</literal> and / or <literal>AsyncClientHttpRequestFactory</literal>.
<emphasis role="strong">If you have your own <literal>AsyncRestTemplate</literal> and you don&#8217;t wrap it your calls WILL NOT GET TRACED</emphasis>.</simpara>
</important>
<simpara>Custom instrumentation is set to create and close Spans upon sending and receiving requests. You can customize the <literal>ClientHttpRequestFactory</literal>
and the <literal>AsyncClientHttpRequestFactory</literal> by registering your beans. Remember to use tracing compatible implementations (e.g. don&#8217;t forget to
wrap <literal>ThreadPoolTaskScheduler</literal> in a <literal>TraceAsyncListenableTaskExecutor</literal>). Example of custom request factories:</simpara>
<programlisting language="java" linenumbering="unnumbered">@EnableAutoConfiguration
@Configuration
public static class TestConfiguration {

	@Bean
	ClientHttpRequestFactory mySyncClientFactory() {
		return new MySyncClientHttpRequestFactory();
	}

	@Bean
	AsyncClientHttpRequestFactory myAsyncClientFactory() {
		return new MyAsyncClientHttpRequestFactory();
	}
}</programlisting>
<simpara>To block the <literal>AsyncRestTemplate</literal> features set <literal>spring.sleuth.web.async.client.enabled</literal> to <literal>false</literal>.
To disable creation of the default <literal>TraceAsyncClientHttpRequestFactoryWrapper</literal> set <literal>spring.sleuth.web.async.client.factory.enabled</literal>
to <literal>false</literal>. If you don&#8217;t want to create <literal>AsyncRestClient</literal> at all set <literal>spring.sleuth.web.async.client.template.enabled</literal> to <literal>false</literal>.</simpara>
<section xml:id="_multiple_asynchronous_rest_templates">
<title>Multiple Asynchronous Rest Templates</title>
<simpara>Sometimes you need to use multiple implementations of Asynchronous Rest Template. In the following snippet you
can see an example of how to set up such a custom <literal>AsyncRestTemplate</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@EnableAutoConfiguration
static class Config {
	@Autowired Tracer tracer;
	@Autowired HttpTraceKeysInjector httpTraceKeysInjector;
	@Autowired HttpSpanInjector spanInjector;

	@Bean(name = "customAsyncRestTemplate")
	public AsyncRestTemplate traceAsyncRestTemplate(@Qualifier("customHttpRequestFactoryWrapper")
			TraceAsyncClientHttpRequestFactoryWrapper wrapper, ErrorParser errorParser) {
		return new TraceAsyncRestTemplate(wrapper, this.tracer, errorParser);
	}

	@Bean(name = "customHttpRequestFactoryWrapper")
	public TraceAsyncClientHttpRequestFactoryWrapper traceAsyncClientHttpRequestFactory() {
		return new TraceAsyncClientHttpRequestFactoryWrapper(this.tracer,
				this.spanInjector,
				asyncClientFactory(),
				clientHttpRequestFactory(),
				this.httpTraceKeysInjector);
	}

	private ClientHttpRequestFactory clientHttpRequestFactory() {
		ClientHttpRequestFactory clientHttpRequestFactory = new CustomClientHttpRequestFactory();
		//CUSTOMIZE HERE
		return clientHttpRequestFactory;
	}

	private AsyncClientHttpRequestFactory asyncClientFactory() {
		AsyncClientHttpRequestFactory factory = new CustomAsyncClientHttpRequestFactory();
		//CUSTOMIZE HERE
		return factory;
	}
}</programlisting>
</section>
</section>
<section xml:id="_traverson">
<title>Traverson</title>
<simpara>If you&#8217;re using the <link xl:href="https://docs.spring.io/spring-hateoas/docs/current/reference/html/#client.traverson">Traverson</link> library
it&#8217;s enough for you to inject a <literal>RestTemplate</literal> as a bean into your Traverson object. Since <literal>RestTemplate</literal>
is already intercepted, you will get full support of tracing in your client. Below you can find a pseudo code
of how to do that:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Autowired RestTemplate restTemplate;

Traverson traverson = new Traverson(URI.create("http://some/address"),
    MediaType.APPLICATION_JSON, MediaType.APPLICATION_JSON_UTF8).setRestOperations(restTemplate);
// use Traverson</programlisting>
</section>
</section>
<section xml:id="_feign">
<title>Feign</title>
<simpara>By default Spring Cloud Sleuth provides integration with feign via the <literal>TraceFeignClientAutoConfiguration</literal>. You can disable it entirely
by setting <literal>spring.sleuth.feign.enabled</literal> to false. If you do so then no Feign related instrumentation will take place.</simpara>
<simpara>Part of Feign instrumentation is done via a <literal>FeignBeanPostProcessor</literal>. You can disable it by providing the <literal>spring.sleuth.feign.processor.enabled</literal> equal to <literal>false</literal>.
If you set it like this then Spring Cloud Sleuth will not instrument any of your custom Feign components. All the default instrumentation
however will be still there.</simpara>
</section>
<section xml:id="_asynchronous_communication">
<title>Asynchronous communication</title>
<section xml:id="__async_annotated_methods">
<title>@Async annotated methods</title>
<simpara>In Spring Cloud Sleuth we&#8217;re instrumenting async related components so that the tracing information is passed between threads.
You can disable this behaviour by setting the value of <literal>spring.sleuth.async.enabled</literal> to <literal>false</literal>.</simpara>
<simpara>If you annotate your method with <literal>@Async</literal> then we&#8217;ll automatically create a new Span with the following characteristics:</simpara>
<itemizedlist>
<listitem>
<simpara>if the method is annotated with <literal>@SpanName</literal> then the value of the annotation will be the Span&#8217;s name</simpara>
</listitem>
<listitem>
<simpara>if the method is <emphasis role="strong">not</emphasis> annotated with <literal>@SpanName</literal> the Span name will be the annotated method name</simpara>
</listitem>
<listitem>
<simpara>the Span will be tagged with that method&#8217;s class name and the method name too</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="__scheduled_annotated_methods">
<title>@Scheduled annotated methods</title>
<simpara>In Spring Cloud Sleuth we&#8217;re instrumenting scheduled method execution so that the tracing information is passed between threads. You can disable this behaviour
by setting the value of <literal>spring.sleuth.scheduled.enabled</literal> to <literal>false</literal>.</simpara>
<simpara>If you annotate your method with <literal>@Scheduled</literal> then we&#8217;ll automatically create a new Span with the following characteristics:</simpara>
<itemizedlist>
<listitem>
<simpara>the Span name will be the annotated method name</simpara>
</listitem>
<listitem>
<simpara>the Span will be tagged with that method&#8217;s class name and the method name too</simpara>
</listitem>
</itemizedlist>
<simpara>If you want to skip Span creation for some <literal>@Scheduled</literal> annotated classes you can set the
<literal>spring.sleuth.scheduled.skipPattern</literal> with a regular expression that will match the fully qualified name of the
<literal>@Scheduled</literal> annotated class.</simpara>
<tip>
<simpara>If you are using <literal>spring-cloud-sleuth-stream</literal> and <literal>spring-cloud-netflix-hystrix-stream</literal> together, Span will be created for each Hystrix metrics and sent to Zipkin. This may be annoying. You can prevent this by setting <literal>spring.sleuth.scheduled.skipPattern=org.springframework.cloud.netflix.hystrix.stream.HystrixStreamTask</literal></simpara>
</tip>
</section>
<section xml:id="_executor_executorservice_and_scheduledexecutorservice">
<title>Executor, ExecutorService and ScheduledExecutorService</title>
<simpara>We&#8217;re providing <literal>LazyTraceExecutor</literal>, <literal>TraceableExecutorService</literal> and <literal>TraceableScheduledExecutorService</literal>. Those implementations
are creating Spans each time a new task is submitted, invoked or scheduled.</simpara>
<simpara>Here you can see an example of how to pass tracing information with <literal>TraceableExecutorService</literal> when working with <literal>CompletableFuture</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">CompletableFuture&lt;Long&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
	// perform some logic
	return 1_000_000L;
}, new TraceableExecutorService(executorService,
		// 'calculateTax' explicitly names the span - this param is optional
		tracer, traceKeys, spanNamer, "calculateTax"));</programlisting>
<important>
<simpara>Sleuth doesn&#8217;t work with <literal>parallelStream()</literal> out of the box. If you want
to have the tracing information propagated through the stream you have to use the
approach with <literal>supplyAsync(&#8230;&#8203;)</literal> as presented above.</simpara>
</important>
<section xml:id="_customization_of_executors">
<title>Customization of Executors</title>
<simpara>Sometimes you need to set up a custom instance of the <literal>AsyncExecutor</literal>. In the following snippet you
can see an example of how to set up such a custom <literal>Executor</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Configuration
@EnableAutoConfiguration
@EnableAsync
static class CustomExecutorConfig extends AsyncConfigurerSupport {

	@Autowired BeanFactory beanFactory;

	@Override public Executor getAsyncExecutor() {
		ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
		// CUSTOMIZE HERE
		executor.setCorePoolSize(7);
		executor.setMaxPoolSize(42);
		executor.setQueueCapacity(11);
		executor.setThreadNamePrefix("MyExecutor-");
		// DON'T FORGET TO INITIALIZE
		executor.initialize();
		return new LazyTraceExecutor(this.beanFactory, executor);
	}
}</programlisting>
</section>
</section>
</section>
<section xml:id="_messaging">
<title>Messaging</title>
<simpara>Spring Cloud Sleuth integrates with <link xl:href="https://projects.spring.io/spring-integration/">Spring Integration</link>. It creates spans for publish and
subscribe events. To disable Spring Integration instrumentation, set <literal>spring.sleuth.integration.enabled</literal> to false.</simpara>
<simpara>You can provide the <literal>spring.sleuth.integration.patterns</literal> pattern to explicitly
provide the names of channels that you want to include for tracing. By default all channels
are included.</simpara>
<important>
<simpara>When using the <literal>Executor</literal> to build a Spring Integration <literal>IntegrationFlow</literal> remember to use the <emphasis role="strong">untraced</emphasis> version of the <literal>Executor</literal>.
Decorating Spring Integration Executor Channel with <literal>TraceableExecutorService</literal> will cause the spans to be improperly closed.</simpara>
</important>
</section>
<section xml:id="_zuul_2">
<title>Zuul</title>
<simpara>We&#8217;re registering Zuul filters to propagate the tracing information (the request header is enriched with tracing data).
To disable Zuul support set the <literal>spring.sleuth.zuul.enabled</literal> property to <literal>false</literal>.</simpara>
</section>
</chapter>
<chapter xml:id="_running_examples">
<title>Running examples</title>
<simpara>You can find the running examples deployed in the <link xl:href="https://run.pivotal.io/">Pivotal Web Services</link>. Check them out in the following links:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://docssleuth-zipkin-server.cfapps.io/">Zipkin for apps presented in the samples to the top</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docsbrewing-zipkin-server.cfapps.io/">Zipkin for Brewery on PWS</link>, its <link xl:href="https://github.com/spring-cloud-samples/brewery">Github Code</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</part>
<part xml:id="_spring_cloud_consul">
<title>Spring Cloud Consul</title>
<partintro>
<simpara><emphasis role="strong">Edgware.SR2</emphasis></simpara>
<simpara>This project provides Consul integrations for Spring Boot apps through autoconfiguration
and binding to the Spring Environment and other Spring programming model idioms. With a few
simple annotations you can quickly enable and configure the common patterns inside your
application and build large distributed systems with Consul based components. The
patterns provided include Service Discovery, Control Bus and Configuration.
Intelligent Routing (Zuul) and Client Side Load Balancing (Ribbon), Circuit Breaker
(Hystrix) are provided by integration with Spring Cloud Netflix.</simpara>
</partintro>
<chapter xml:id="spring-cloud-consul-install">
<title>Install Consul</title>
<simpara>Please see the <link xl:href="https://www.consul.io/intro/getting-started/install.html">installation documentation</link> for instructions on how to install Consul.</simpara>
</chapter>
<chapter xml:id="spring-cloud-consul-agent">
<title>Consul Agent</title>
<simpara>A Consul Agent client must be available to all Spring Cloud Consul applications.  By default, the Agent client is expected to be at <literal>localhost:8500</literal>.  See the <link xl:href="https://consul.io/docs/agent/basics.html">Agent documentation</link> for specifics on how to start an Agent client and how to connect to a cluster of Consul Agent Servers.  For development, after you have installed consul, you may start a Consul Agent using the following command:</simpara>
<screen>./src/main/bash/local_run_consul.sh</screen>
<simpara>This will start an agent in server mode on port 8500, with the ui available at <link xl:href="http://localhost:8500">http://localhost:8500</link></simpara>
</chapter>
<chapter xml:id="spring-cloud-consul-discovery">
<title>Service Discovery with Consul</title>
<simpara>Service Discovery is one of the key tenets of a microservice based architecture. Trying to hand configure each client or some form of convention can be very difficult to do and can be very brittle.  Consul provides Service Discovery services via an <link xl:href="https://www.consul.io/docs/agent/http.html">HTTP API</link> and <link xl:href="https://www.consul.io/docs/agent/dns.html">DNS</link>.  Spring Cloud Consul leverages the HTTP API for service registration and discovery.  This does not prevent non-Spring Cloud applications from leveraging the DNS interface.  Consul Agents servers are run in a <link xl:href="https://www.consul.io/docs/internals/architecture.html">cluster</link> that communicates via a <link xl:href="https://www.consul.io/docs/internals/gossip.html">gossip protocol</link> and uses the <link xl:href="https://www.consul.io/docs/internals/consensus.html">Raft consensus protocol</link>.</simpara>
<section xml:id="_how_to_activate">
<title>How to activate</title>
<simpara>To activate Consul Service Discovery use the starter with group <literal>org.springframework.cloud</literal> and artifact id <literal>spring-cloud-starter-consul-discovery</literal>. See the <link xl:href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</link> for details on setting up your build system with the current Spring Cloud Release Train.</simpara>
</section>
<section xml:id="_registering_with_consul">
<title>Registering with Consul</title>
<simpara>When a client registers with Consul, it provides meta-data about itself such as host and port, id, name and tags.  An HTTP <link xl:href="https://www.consul.io/docs/agent/checks.html">Check</link> is created by default that Consul hits the <literal>/health</literal> endpoint every 10 seconds.  If the health check fails, the service instance is marked as critical.</simpara>
<simpara>Example Consul client:</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello world";
    }

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</programlisting>
<simpara>(i.e. utterly normal Spring Boot app).  If the Consul client is located somewhere other than <literal>localhost:8500</literal>, the configuration is required to locate the client. Example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>spring:
  cloud:
    consul:
      host: localhost
      port: 8500</screen>
</para>
</formalpara>
<caution>
<simpara>If you use <link linkend="spring-cloud-consul-config">Spring Cloud Consul Config</link>, the above values will need to be placed in <literal>bootstrap.yml</literal> instead of <literal>application.yml</literal>.</simpara>
</caution>
<simpara>The default service name, instance id and port, taken from the <literal>Environment</literal>, are <literal>${spring.application.name}</literal>, the Spring Context ID and <literal>${server.port}</literal> respectively.</simpara>
<simpara>To disable the Consul Discovery Client you can set <literal>spring.cloud.consul.discovery.enabled</literal> to <literal>false</literal>.</simpara>
<simpara>To disable the service registration you can set <literal>spring.cloud.consul.discovery.register</literal> to <literal>false</literal>.</simpara>
</section>
<section xml:id="_http_health_check">
<title>HTTP Health Check</title>
<simpara>The health check for a Consul instance defaults to "/health", which is the default locations of a useful endpoint in a Spring Boot Actuator application. You need to change these, even for an Actuator application if you use a non-default context path or servlet path (e.g. <literal>server.servletPath=/foo</literal>) or management endpoint path (e.g. <literal>management.context-path=/admin</literal>). The interval that Consul uses to check the health endpoint may also be configured.  "10s" and "1m" represent 10 seconds and 1 minute respectively.  Example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>spring:
  cloud:
    consul:
      discovery:
        healthCheckPath: ${management.context-path}/health
        healthCheckInterval: 15s</screen>
</para>
</formalpara>
<section xml:id="_metadata_and_consul_tags">
<title>Metadata and Consul tags</title>
<simpara>Consul does not yet support metadata on services. Spring Cloud&#8217;s <literal>ServiceInstance</literal> has a <literal>Map&lt;String, String&gt; metadata</literal> field. Spring Cloud Consul uses Consul tags to approximate metadata until Consul officially supports metadata. Tags with the form <literal>key=value</literal> will be split and used as a <literal>Map</literal> key and value respectively. Tags without the equal <literal>=</literal> sign, will be used as both the key and value.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>spring:
  cloud:
    consul:
      discovery:
        tags: foo=bar, baz</screen>
</para>
</formalpara>
<simpara>The above configuration will result in a map with <literal>foo&#8594;bar</literal> and <literal>baz&#8594;baz</literal>.</simpara>
</section>
<section xml:id="_making_the_consul_instance_id_unique">
<title>Making the Consul Instance ID Unique</title>
<simpara>By default a consul instance is registered with an ID that is equal to its Spring Application Context ID. By default, the Spring Application Context ID is <literal>${spring.application.name}:comma,separated,profiles:${server.port}</literal>. For most cases, this will allow multiple instances of one service to run on one machine.  If further uniqueness is required, Using Spring Cloud you can override this by providing a unique identifier in <literal>spring.cloud.consul.discovery.instanceId</literal>. For example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>spring:
  cloud:
    consul:
      discovery:
        instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}</screen>
</para>
</formalpara>
<simpara>With this metadata, and multiple service instances deployed on localhost, the random value will kick in there to make the instance unique. In Cloudfoundry the <literal>vcap.application.instance_id</literal> will be populated automatically in a Spring Boot application, so the random value will not be needed.</simpara>
</section>
</section>
<section xml:id="_looking_up_services">
<title>Looking up services</title>
<section xml:id="_using_ribbon">
<title>Using Ribbon</title>
<simpara>Spring Cloud has support for <link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign">Feign</link> (a REST client builder) and also <link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon">Spring <literal>RestTemplate</literal></link>
for looking up services using the logical service names/ids instead of physical URLs. Both Feign and the discovery-aware RestTemplate utilize <link xl:href="https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon">Ribbon</link> for client-side load balancing.</simpara>
<simpara>If you want to access service STORES using the RestTemplate simply declare:</simpara>
<screen>@LoadBalanced
@Bean
public RestTemplate loadbalancedRestTemplate() {
     new RestTemplate();
}</screen>
<simpara>and use it like this (notice how we use the STORES service name/id from Consul instead of a fully qualified domainname):</simpara>
<screen>@Autowired
RestTemplate restTemplate;

public String getFirstProduct() {
   return this.restTemplate.getForObject("https://STORES/products/1", String.class);
}</screen>
<simpara>If you have Consul clusters in multiple datacenters and you want to access a service in another datacenter a service name/id alone is not enough. In that case
you use property <literal>spring.cloud.consul.discovery.datacenters.STORES=dc-west</literal> where <literal>STORES</literal> is the service name/id and <literal>dc-west</literal> is the datacenter
where the STORES service lives.</simpara>
</section>
<section xml:id="_using_the_discoveryclient">
<title>Using the DiscoveryClient</title>
<simpara>You can also use the <literal>org.springframework.cloud.client.discovery.DiscoveryClient</literal> which provides a simple API for discovery clients that is not specific to Netflix, e.g.</simpara>
<screen>@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances("STORES");
    if (list != null &amp;&amp; list.size() &gt; 0 ) {
        return list.get(0).getUri();
    }
    return null;
}</screen>
</section>
</section>
</chapter>
<chapter xml:id="spring-cloud-consul-config">
<title>Distributed Configuration with Consul</title>
<simpara>Consul provides a <link xl:href="https://consul.io/docs/agent/http/kv.html">Key/Value Store</link> for storing configuration and other metadata.  Spring Cloud Consul Config is an alternative to the <link xl:href="https://github.com/spring-cloud/spring-cloud-config">Config Server and Client</link>.  Configuration is loaded into the Spring Environment during the special "bootstrap" phase.  Configuration is stored in the <literal>/config</literal> folder by default.  Multiple <literal>PropertySource</literal> instances are created based on the application&#8217;s name and the active profiles that mimicks the Spring Cloud Config order of resolving properties.  For example, an application with the name "testApp" and with the "dev" profile will have the following property sources created:</simpara>
<screen>config/testApp,dev/
config/testApp/
config/application,dev/
config/application/</screen>
<simpara>The most specific property source is at the top, with the least specific at the bottom.  Properties in the <literal>config/application</literal> folder are applicable to all applications using consul for configuration.  Properties in the <literal>config/testApp</literal> folder are only available to the instances of the service named "testApp".</simpara>
<simpara>Configuration is currently read on startup of the application.  Sending a HTTP POST to <literal>/refresh</literal> will cause the configuration to be reloaded. <xref linkend="spring-cloud-consul-config-watch"/> will also automatically detect changes and reload the application context.</simpara>
<section xml:id="_how_to_activate_2">
<title>How to activate</title>
<simpara>To get started with Consul Configuration use the starter with group <literal>org.springframework.cloud</literal> and artifact id <literal>spring-cloud-starter-consul-config</literal>. See the <link xl:href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</link> for details on setting up your build system with the current Spring Cloud Release Train.</simpara>
<simpara>This will enable auto-configuration that will setup Spring Cloud Consul Config.</simpara>
</section>
<section xml:id="_customizing">
<title>Customizing</title>
<simpara>Consul Config may be customized using the following properties:</simpara>
<formalpara>
<title>bootstrap.yml</title>
<para>
<screen>spring:
  cloud:
    consul:
      config:
        enabled: true
        prefix: configuration
        defaultContext: apps
        profileSeparator: '::'</screen>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><literal>enabled</literal> setting this value to "false" disables Consul Config</simpara>
</listitem>
<listitem>
<simpara><literal>prefix</literal> sets the base folder for configuration values</simpara>
</listitem>
<listitem>
<simpara><literal>defaultContext</literal> sets the folder name used by all applications</simpara>
</listitem>
<listitem>
<simpara><literal>profileSeparator</literal> sets the value of the separator used to separate the profile name in property sources with profiles</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="spring-cloud-consul-config-watch">
<title>Config Watch</title>
<simpara>The Consul Config Watch takes advantage of the ability of consul to <link xl:href="https://www.consul.io/docs/agent/watches.html#keyprefix">watch a key prefix</link>. The Config Watch makes a blocking Consul HTTP API call to determine if any relevant configuration data has changed for the current application. If there is new configuration data a Refresh Event is published. This is equivalent to calling the <literal>/refresh</literal> actuator endpoint.</simpara>
<simpara>To change the frequency of when the Config Watch is called change <literal>spring.cloud.consul.config.watch.delay</literal>. The default value is 1000, which is in milliseconds.</simpara>
<simpara>To disable the Config Watch set <literal>spring.cloud.consul.config.watch.enabled=false</literal>.</simpara>
</section>
<section xml:id="spring-cloud-consul-config-format">
<title>YAML or Properties with Config</title>
<simpara>It may be more convenient to store a blob of properties in YAML or Properties format as opposed to individual key/value pairs.  Set the <literal>spring.cloud.consul.config.format</literal> property to <literal>YAML</literal> or <literal>PROPERTIES</literal>. For example to use YAML:</simpara>
<formalpara>
<title>bootstrap.yml</title>
<para>
<screen>spring:
  cloud:
    consul:
      config:
        format: YAML</screen>
</para>
</formalpara>
<simpara>YAML must be set in the appropriate <literal>data</literal> key in consul. Using the defaults above the keys would look like:</simpara>
<screen>config/testApp,dev/data
config/testApp/data
config/application,dev/data
config/application/data</screen>
<simpara>You could store a YAML document in any of the keys listed above.</simpara>
<simpara>You can change the data key using <literal>spring.cloud.consul.config.data-key</literal>.</simpara>
</section>
<section xml:id="spring-cloud-consul-config-git2consul">
<title>git2consul with Config</title>
<simpara>git2consul is a Consul community project that loads files from a git repository to individual keys into Consul. By default the names of the keys are names of the files. YAML and Properties files are supported with file extensions of <literal>.yml</literal> and <literal>.properties</literal> respectively.  Set the <literal>spring.cloud.consul.config.format</literal> property to <literal>FILES</literal>. For example:</simpara>
<formalpara>
<title>bootstrap.yml</title>
<para>
<screen>spring:
  cloud:
    consul:
      config:
        format: FILES</screen>
</para>
</formalpara>
<simpara>Given the following keys in <literal>/config</literal>, the <literal>development</literal> profile and an application name of <literal>foo</literal>:</simpara>
<screen>.gitignore
application.yml
bar.properties
foo-development.properties
foo-production.yml
foo.properties
master.ref</screen>
<simpara>the following property sources would be created:</simpara>
<screen>config/foo-development.properties
config/foo.properties
config/application.yml</screen>
<simpara>The value of each key needs to be a properly formatted YAML or Properties file.</simpara>
</section>
<section xml:id="spring-cloud-consul-failfast">
<title>Fail Fast</title>
<simpara>It may be convenient in certain circumstances (like local development or certain test scenarios) to not fail if consul isn&#8217;t available for configuration. Setting <literal>spring.cloud.consul.config.failFast=false</literal> in <literal>bootstrap.yml</literal> will cause the configuration module to log a warning rather than throw an exception. This will allow the application to continue startup normally.</simpara>
</section>
</chapter>
<chapter xml:id="spring-cloud-consul-retry">
<title>Consul Retry</title>
<simpara>If you expect that the consul agent may occasionally be unavailable when
your app starts, you can ask it to keep trying after a failure. You need to add
<literal>spring-retry</literal> and <literal>spring-boot-starter-aop</literal> to your classpath. The default
behaviour is to retry 6 times with an initial backoff interval of 1000ms and an
exponential multiplier of 1.1 for subsequent backoffs. You can configure these
properties (and others) using <literal>spring.cloud.consul.retry.*</literal> configuration properties.
This works with both Spring Cloud Consul Config and Discovery registration.</simpara>
<tip>
<simpara>To take full control of the retry add a <literal>@Bean</literal> of type
<literal>RetryOperationsInterceptor</literal> with id "consulRetryInterceptor". Spring
Retry has a <literal>RetryInterceptorBuilder</literal> that makes it easy to create one.</simpara>
</tip>
</chapter>
<chapter xml:id="spring-cloud-consul-bus">
<title>Spring Cloud Bus with Consul</title>
<section xml:id="_how_to_activate_3">
<title>How to activate</title>
<simpara>To get started with the Consul Bus use the starter with group <literal>org.springframework.cloud</literal> and artifact id <literal>spring-cloud-starter-consul-bus</literal>. See the <link xl:href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</link> for details on setting up your build system with the current Spring Cloud Release Train.</simpara>
<simpara>See the <link xl:href="https://cloud.spring.io/spring-cloud-bus/">Spring Cloud Bus</link> documentation for the available actuator endpoints and howto send custom messages.</simpara>
</section>
</chapter>
<chapter xml:id="spring-cloud-consul-hystrix">
<title>Circuit Breaker with Hystrix</title>
<simpara>Applications can use the Hystrix Circuit Breaker provided by the Spring Cloud Netflix project by including this starter in the projects pom.xml: <literal>spring-cloud-starter-hystrix</literal>.  Hystrix doesn&#8217;t depend on the Netflix Discovery Client. The <literal>@EnableHystrix</literal> annotation should be placed on a configuration class (usually the main class). Then methods can be annotated with <literal>@HystrixCommand</literal> to be protected by a circuit breaker. See <link xl:href="https://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_clients">the documentation</link> for more details.</simpara>
</chapter>
<chapter xml:id="spring-cloud-consul-turbine">
<title>Hystrix metrics aggregation with Turbine and Consul</title>
<simpara>Turbine (provided by the Spring Cloud Netflix project), aggregates multiple instances Hystrix metrics streams, so the dashboard can display an aggregate view. Turbine uses the <literal>DiscoveryClient</literal> interface to lookup relevant instances. To use Turbine with Spring Cloud Consul, configure the Turbine application in a manner similar to the following examples:</simpara>
<formalpara>
<title>pom.xml</title>
<para>
<screen>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-netflix-turbine&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;</screen>
</para>
</formalpara>
<simpara>Notice that the Turbine dependency is not a starter. The turbine starter includes support for Netflix Eureka.</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>spring.application.name: turbine
applications: consulhystrixclient
turbine:
  aggregator:
    clusterConfig: ${applications}
  appConfig: ${applications}</screen>
</para>
</formalpara>
<simpara>The <literal>clusterConfig</literal> and <literal>appConfig</literal> sections must match, so it&#8217;s useful to put the comma-separated list of service ID&#8217;s into a separate configuration property.</simpara>
<formalpara>
<title>Turbine.java</title>
<para>
<screen>@EnableTurbine
@SpringBootApplication
public class Turbine {
    public static void main(String[] args) {
        SpringApplication.run(DemoturbinecommonsApplication.class, args);
    }
}</screen>
</para>
</formalpara>
</chapter>
</part>
<part xml:id="_spring_cloud_zookeeper">
<title>Spring Cloud Zookeeper</title>
<partintro>
<simpara>This project provides Zookeeper integrations for Spring Boot apps through autoconfiguration
and binding to the Spring Environment and other Spring programming model idioms. With a few
simple annotations you can quickly enable and configure the common patterns inside your
application and build large distributed systems with Zookeeper based components. The
patterns provided include Service Discovery and Configuration.
Intelligent Routing (Zuul) and Client Side Load Balancing (Ribbon), Circuit Breaker
(Hystrix) are provided by integration with Spring Cloud Netflix.</simpara>
</partintro>
<chapter xml:id="spring-cloud-zookeeper-install">
<title>Install Zookeeper</title>
<simpara>Please see the <link xl:href="https://zookeeper.apache.org/doc/current/zookeeperStarted.html">installation documentation</link> for instructions on how to install Zookeeper.</simpara>
</chapter>
<chapter xml:id="spring-cloud-zookeeper-discovery">
<title>Service Discovery with Zookeeper</title>
<simpara>Service Discovery is one of the key tenets of a microservice based architecture. Trying to hand configure each client or some form of convention can be very difficult to do and can be very brittle. <link xl:href="https://curator.apache.org">Curator</link>(A java library for Zookeeper) provides Service Discovery services via <link xl:href="https://curator.apache.org/curator-x-discovery/">Service Discovery Extension</link>. Spring Cloud Zookeeper leverages this extension for service registration and discovery.</simpara>
<section xml:id="_how_to_activate_4">
<title>How to activate</title>
<simpara>Including a dependency on <literal>org.springframework.cloud:spring-cloud-starter-zookeeper-discovery</literal> will enable auto-configuration that will setup Spring Cloud Zookeeper Discovery.</simpara>
<note>
<simpara>You still need to include <literal>org.springframework.boot:spring-boot-starter-web</literal> for web functionality.</simpara>
</note>
</section>
<section xml:id="_registering_with_zookeeper">
<title>Registering with Zookeeper</title>
<simpara>When a client registers with Zookeeper, it provides meta-data about itself such as host and port, id and name.</simpara>
<simpara>Example Zookeeper client:</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello world";
    }

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</programlisting>
<simpara>(i.e. utterly normal Spring Boot app).  If Zookeeper is located somewhere other than <literal>localhost:2181</literal>, the configuration is required to locate the server. Example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>spring:
  cloud:
    zookeeper:
      connect-string: localhost:2181</screen>
</para>
</formalpara>
<caution>
<simpara>If you use <link linkend="spring-cloud-zookeeper-config">Spring Cloud Zookeeper Config</link>, the above values will need to be placed in <literal>bootstrap.yml</literal> instead of <literal>application.yml</literal>.</simpara>
</caution>
<simpara>The default service name, instance id and port, taken from the <literal>Environment</literal>, are <literal>${spring.application.name}</literal>, the Spring Context ID and <literal>${server.port}</literal> respectively.</simpara>
<simpara>Having <literal>spring-cloud-starter-zookeeper-discovery</literal> on the classpath makes the app into both a Zookeeper "service" (i.e. it registers itself) and a "client" (i.e. it can query Zookeeper to locate other services).</simpara>
<simpara>If you would like to disable the Zookeeper Discovery Client you can set <literal>spring.cloud.zookeeper.discovery.enabled</literal> to <literal>false</literal>.</simpara>
</section>
<section xml:id="_using_the_discoveryclient_2">
<title>Using the DiscoveryClient</title>
<simpara>Spring Cloud has support for <link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign">Feign</link> (a REST client builder) and also <link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon">Spring <literal>RestTemplate</literal></link> using the logical service names instead of physical URLs.</simpara>
<simpara>You can also use the <literal>org.springframework.cloud.client.discovery.DiscoveryClient</literal> which provides a simple API for discovery clients that is not specific to Netflix, e.g.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances("STORES");
    if (list != null &amp;&amp; list.size() &gt; 0 ) {
        return list.get(0).getUri().toString();
    }
    return null;
}</programlisting>
</section>
</chapter>
<chapter xml:id="spring-cloud-zookeeper-netflix">
<title>Using Spring Cloud Zookeeper with Spring Cloud Netflix Components</title>
<simpara>Spring Cloud Netflix supplies useful tools that work regardless of which <literal>DiscoveryClient</literal> implementation is used. Feign, Turbine, Ribbon and Zuul all work with Spring Cloud Zookeeper.</simpara>
<section xml:id="_ribbon_with_zookeeper">
<title>Ribbon with Zookeeper</title>
<simpara>Spring Cloud Zookeeper provides an implementation of Ribbon&#8217;s <literal>ServerList</literal>. When the <literal>spring-cloud-starter-zookeeper-discovery</literal> is used, Ribbon is auto-configured to use the <literal>ZookeeperServerList</literal> by default.</simpara>
</section>
</chapter>
<chapter xml:id="spring-cloud-zookeeper-service-registry">
<title>Spring Cloud Zookeeper and Service Registry</title>
<simpara>Spring Cloud Zookeeper implements the <literal>ServiceRegistry</literal> interface allowing developers to register arbitrary service in a programmatic way.</simpara>
<simpara>The <literal>ServiceInstanceRegistration</literal> class offers a <literal>builder()</literal> method to create a <literal>Registration</literal> object that can be used by the <literal>ServiceRegistry</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Autowired
private ZookeeperServiceRegistry serviceRegistry;

public void registerThings() {
    ZookeeperRegistration registration = ServiceInstanceRegistration.builder()
            .defaultUriSpec()
            .address("anyUrl")
            .port(10)
            .name("/a/b/c/d/anotherservice")
            .build();
    this.serviceRegistry.register(registration);
}</programlisting>
<section xml:id="_instance_status">
<title>Instance Status</title>
<simpara>Netflix Eureka supports having instances registered with the server that are <literal>OUT_OF_SERVICE</literal> and not returned as active service instances. This is very useful for behaviors such as blue/green deployments. The Curator Service Discovery recipe does not support this behavior. Taking advantage of the flexible payload has let Spring Cloud Zookeeper implement <literal>OUT_OF_SERVICE</literal> by updating some specific metadata and then filtering on that metadata in the Ribbon <literal>ZookeeperServerList</literal>. The <literal>ZookeeperServerList</literal> filters out all non-null instance statuses that do not equal <literal>UP</literal>. If the instance status field is empty, it is considered <literal>UP</literal> for backwards compatibility. To change the status of an instance POST <literal>OUT_OF_SERVICE</literal> to the <literal>ServiceRegistry</literal> instance status actuator endpoint.</simpara>
<literallayout class="monospaced">----
$ echo -n OUT_OF_SERVICE | http POST http://localhost:8081/service-registry/instance-status
----</literallayout>
<literallayout class="monospaced">NOTE: The above example uses the `http` command from https://httpie.org</literallayout>
</section>
</chapter>
<chapter xml:id="spring-cloud-zookeeper-dependencies">
<title>Zookeeper Dependencies</title>
<section xml:id="_using_the_zookeeper_dependencies">
<title>Using the Zookeeper Dependencies</title>
<simpara>Spring Cloud Zookeeper gives you a possibility to provide dependencies of your application as properties. As dependencies you can understand other applications that are registered
in Zookeeper and which you would like to call via <link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign">Feign</link> (a REST client builder)
and also <link xl:href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon">Spring <literal>RestTemplate</literal></link>.</simpara>
<simpara>You can also benefit from the Zookeeper Dependency Watchers functionality that lets you control and monitor what is the state of your dependencies and decide what to do with that.</simpara>
</section>
<section xml:id="_how_to_activate_zookeeper_dependencies">
<title>How to activate Zookeeper Dependencies</title>
<itemizedlist>
<listitem>
<simpara>Including a dependency on <literal>org.springframework.cloud:spring-cloud-starter-zookeeper-discovery</literal> will enable auto-configuration that will setup Spring Cloud Zookeeper Dependencies.</simpara>
</listitem>
<listitem>
<simpara>If you have to have the <literal>spring.cloud.zookeeper.dependencies</literal> section properly set up - check the subsequent section for more details then the feature is active</simpara>
</listitem>
<listitem>
<simpara>You can have the dependencies turned off even if you&#8217;ve provided the dependencies in your properties. Just set the property <literal>spring.cloud.zookeeper.dependency.enabled</literal> to false (defaults to <literal>true</literal>).</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_setting_up_zookeeper_dependencies">
<title>Setting up Zookeeper Dependencies</title>
<simpara>Let&#8217;s take a closer look at an example of dependencies representation:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<screen>spring.application.name: yourServiceName
spring.cloud.zookeeper:
  dependencies:
    newsletter:
      path: /path/where/newsletter/has/registered/in/zookeeper
      loadBalancerType: ROUND_ROBIN
      contentTypeTemplate: application/vnd.newsletter.$version+json
      version: v1
      headers:
        header1:
            - value1
        header2:
            - value2
      required: false
      stubs: org.springframework:foo:stubs
    mailing:
      path: /path/where/mailing/has/registered/in/zookeeper
      loadBalancerType: ROUND_ROBIN
      contentTypeTemplate: application/vnd.mailing.$version+json
      version: v1
      required: true</screen>
</para>
</formalpara>
<simpara>Let&#8217;s now go through each part of the dependency one by one. The root property name is <literal>spring.cloud.zookeeper.dependencies</literal>.</simpara>
<section xml:id="_aliases">
<title>Aliases</title>
<simpara>Below the root property you have to represent each dependency has by an alias due to the constraints of Ribbon (the application id has to be placed in the URL
thus you can&#8217;t pass any complex path like /foo/bar/name). The alias will be the name that you will use instead of serviceId for <literal>DiscoveryClient</literal>, <literal>Feign</literal> or <literal>RestTemplate</literal>.</simpara>
<simpara>In the aforementioned examples the aliases are <literal>newsletter</literal> and <literal>mailing</literal>. Example of Feign usage with <literal>newsletter</literal> would be:</simpara>
<screen>@FeignClient("newsletter")
public interface NewsletterService {
        @RequestMapping(method = RequestMethod.GET, value = "/newsletter")
        String getNewsletters();
}</screen>
</section>
<section xml:id="_path">
<title>Path</title>
<simpara>Represented by <literal>path</literal> yaml property.</simpara>
<simpara>Path is the path under which the dependency is registered under Zookeeper. Like presented before Ribbon operates on URLs thus this path is not compliant with its requirement.
That is why Spring Cloud Zookeeper maps the alias to the proper path.</simpara>
</section>
<section xml:id="_load_balancer_type">
<title>Load balancer type</title>
<simpara>Represented by <literal>loadBalancerType</literal> yaml property.</simpara>
<simpara>If you know what kind of load balancing strategy has to be applied when calling this particular dependency then you can provide it in the yaml file and it will be automatically applied.
You can choose one of the following load balancing strategies</simpara>
<itemizedlist>
<listitem>
<simpara>STICKY - once chosen the instance will always be called</simpara>
</listitem>
<listitem>
<simpara>RANDOM - picks an instance randomly</simpara>
</listitem>
<listitem>
<simpara>ROUND_ROBIN - iterates over instances over and over again</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_content_type_template_and_version">
<title>Content-Type template and version</title>
<simpara>Represented by <literal>contentTypeTemplate</literal> and <literal>version</literal> yaml property.</simpara>
<simpara>If you version your api via the <literal>Content-Type</literal> header then you don&#8217;t want to add this header to each of your requests. Also if you want to call a new version of the API you don&#8217;t want to
roam around your code to bump up the API version. That&#8217;s why you can provide a <literal>contentTypeTemplate</literal> with a special <literal>$version</literal> placeholder. That placeholder will be filled by the value of the
<literal>version</literal> yaml property. Let&#8217;s take a look at an example.</simpara>
<simpara>Having the following <literal>contentTypeTemplate</literal>:</simpara>
<screen>application/vnd.newsletter.$version+json</screen>
<simpara>and the following <literal>version</literal>:</simpara>
<screen>v1</screen>
<simpara>Will result in setting up of a <literal>Content-Type</literal> header for each request:</simpara>
<screen>application/vnd.newsletter.v1+json</screen>
</section>
<section xml:id="_default_headers">
<title>Default headers</title>
<simpara>Represented by <literal>headers</literal> map in yaml</simpara>
<simpara>Sometimes each call to a dependency requires setting up of some default headers. In order not to do that in code you can set them up in the yaml file.
Having the following <literal>headers</literal> section:</simpara>
<screen>headers:
    Accept:
        - text/html
        - application/xhtml+xml
    Cache-Control:
        - no-cache</screen>
<simpara>Results in adding the <literal>Accept</literal> and <literal>Cache-Control</literal> headers with appropriate list of values in your HTTP request.</simpara>
</section>
<section xml:id="_obligatory_dependencies">
<title>Obligatory dependencies</title>
<simpara>Represented by <literal>required</literal> property in yaml</simpara>
<simpara>If one of your dependencies is required to be up and running when your application is booting then it&#8217;s enough to set up the <literal>required: true</literal> property in the yaml file.</simpara>
<simpara>If your application can&#8217;t localize the required dependency during boot time it will throw an exception and the Spring Context will fail to set up.
In other words your application won&#8217;t be able to start if the required dependency is not registered in Zookeeper.</simpara>
<simpara>You can read more about Spring Cloud Zookeeper Presence Checker in the following sections.</simpara>
</section>
<section xml:id="_stubs">
<title>Stubs</title>
<simpara>You can provide a colon separated path to the JAR containing stubs of the dependency. Example</simpara>
<screen>stubs: org.springframework:foo:stubs</screen>
<simpara>means that for a particular dependencies can be found under:</simpara>
<itemizedlist>
<listitem>
<simpara>groupId: <literal>org.springframework</literal></simpara>
</listitem>
<listitem>
<simpara>artifactId: <literal>foo</literal></simpara>
</listitem>
<listitem>
<simpara>classifier: <literal>stubs</literal> - this is the default value</simpara>
</listitem>
</itemizedlist>
<simpara>This is actually equal to</simpara>
<screen>stubs: org.springframework:foo</screen>
<simpara>since <literal>stubs</literal> is the default classifier.</simpara>
</section>
</section>
<section xml:id="_configuring_spring_cloud_zookeeper_dependencies">
<title>Configuring Spring Cloud Zookeeper Dependencies</title>
<simpara>There is a bunch of properties that you can set to enable / disable parts of Zookeeper Dependencies functionalities.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>spring.cloud.zookeeper.dependencies</literal> - if you don&#8217;t set this property you won&#8217;t benefit from Zookeeper Dependencies</simpara>
</listitem>
<listitem>
<simpara><literal>spring.cloud.zookeeper.dependency.ribbon.enabled</literal> (enabled by default) - Ribbon requires explicit global configuration or a particular one for a dependency. By turning on this property
runtime load balancing strategy resolution is possible and you can profit from the <literal>loadBalancerType</literal> section of the Zookeeper Dependencies. The configuration that needs this property
has an implementation of <literal>LoadBalancerClient</literal> that delegates to the <literal>ILoadBalancer</literal> presented in the next bullet</simpara>
</listitem>
<listitem>
<simpara><literal>spring.cloud.zookeeper.dependency.ribbon.loadbalancer</literal> (enabled by default) - thanks to this property the custom <literal>ILoadBalancer</literal> knows that the part of the URI passed to Ribbon might
actually be the alias that has to be resolved to a proper path in Zookeeper. Without this property you won&#8217;t be able to register applications under nested paths.</simpara>
</listitem>
<listitem>
<simpara><literal>spring.cloud.zookeeper.dependency.headers.enabled</literal> (enabled by default) - this property registers such a <literal>RibbonClient</literal> that automatically will append appropriate headers and content
types with version as presented in the Dependency configuration. Without this setting of those two parameters will not be operational.</simpara>
</listitem>
<listitem>
<simpara><literal>spring.cloud.zookeeper.dependency.resttemplate.enabled</literal> (enabled by default) - when enabled will modify the request headers of <literal>@LoadBalanced</literal> annotated <literal>RestTemplate</literal> so that it passes
headers and content type with version set in Dependency configuration. Wihtout this setting of those two parameters will not be operational.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="spring-cloud-zookeeper-dependency-watcher">
<title>Spring Cloud Zookeeper Dependency Watcher</title>
<simpara>The Dependency Watcher mechanism allows you to register listeners to your dependencies. The functionality is in fact an implementation of the <literal>Observator</literal> pattern. When a dependency changes
its state (UP or DOWN) then some custom logic can be applied.</simpara>
<section xml:id="_how_to_activate_5">
<title>How to activate</title>
<simpara>Spring Cloud Zookeeper Dependencies functionality needs to be enabled to profit from Dependency Watcher mechanism.</simpara>
</section>
<section xml:id="_registering_a_listener">
<title>Registering a listener</title>
<simpara>In order to register a listener you have to implement an interface <literal>org.springframework.cloud.zookeeper.discovery.watcher.DependencyWatcherListener</literal> and register it as a bean.
The interface gives you one method:</simpara>
<screen>    void stateChanged(String dependencyName, DependencyState newState);</screen>
<simpara>If you want to register a listener for a particular dependency then the <literal>dependencyName</literal> would be the discriminator for your concrete implementation. <literal>newState</literal> will provide you with information
 whether your dependency has changed to <literal>CONNECTED</literal> or <literal>DISCONNECTED</literal>.</simpara>
</section>
<section xml:id="_presence_checker">
<title>Presence Checker</title>
<simpara>Bound with Dependency Watcher is the functionality called Presence Checker. It allows you to provide custom behaviour upon booting of your application to react accordingly to the state
of your dependencies.</simpara>
<simpara>The default implementation of the abstract <literal>org.springframework.cloud.zookeeper.discovery.watcher.presence.DependencyPresenceOnStartupVerifier</literal> class is the
<literal>org.springframework.cloud.zookeeper.discovery.watcher.presence.DefaultDependencyPresenceOnStartupVerifier</literal> which works in the following way.</simpara>
<itemizedlist>
<listitem>
<simpara>If the dependency is marked us <literal>required</literal> and it&#8217;s not in Zookeeper then upon booting your application will throw an exception and shutdown</simpara>
</listitem>
<listitem>
<simpara>If dependency is not <literal>required</literal> the <literal>org.springframework.cloud.zookeeper.discovery.watcher.presence.LogMissingDependencyChecker</literal> will log that application is missing at <literal>WARN</literal> level</simpara>
</listitem>
</itemizedlist>
<simpara>The functionality can be overriden since the <literal>DefaultDependencyPresenceOnStartupVerifier</literal> is registered only when there is no bean of <literal>DependencyPresenceOnStartupVerifier</literal>.</simpara>
</section>
</chapter>
<chapter xml:id="spring-cloud-zookeeper-config">
<title>Distributed Configuration with Zookeeper</title>
<simpara>Zookeeper provides a <link xl:href="https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_dataModelNameSpace">hierarchical namespace</link> that allows clients to store arbitrary data, such as configuration data.  Spring Cloud Zookeeper Config is an alternative to the <link xl:href="https://github.com/spring-cloud/spring-cloud-config">Config Server and Client</link>.  Configuration is loaded into the Spring Environment during the special "bootstrap" phase.  Configuration is stored in the <literal>/config</literal> namespace by default.  Multiple <literal>PropertySource</literal> instances are created based on the application&#8217;s name and the active profiles that mimicks the Spring Cloud Config order of resolving properties.  For example, an application with the name "testApp" and with the "dev" profile will have the following property sources created:</simpara>
<screen>config/testApp,dev
config/testApp
config/application,dev
config/application</screen>
<simpara>The most specific property source is at the top, with the least specific at the bottom.  Properties is the <literal>config/application</literal> namespace are applicable to all applications using zookeeper for configuration.  Properties in the <literal>config/testApp</literal> namespace are only available to the instances of the service named "testApp".</simpara>
<simpara>Configuration is currently read on startup of the application.  Sending a HTTP POST to <literal>/refresh</literal> will cause the configuration to be reloaded.  Watching the configuration namespace (which Zookeeper supports) is not currently implemented, but will be a future addition to this project.</simpara>
<section xml:id="_how_to_activate_6">
<title>How to activate</title>
<simpara>Including a dependency on <literal>org.springframework.cloud:spring-cloud-starter-zookeeper-config</literal> will enable auto-configuration that will setup Spring Cloud Zookeeper Config.</simpara>
</section>
<section xml:id="_customizing_2">
<title>Customizing</title>
<simpara>Zookeeper Config may be customized using the following properties:</simpara>
<formalpara>
<title>bootstrap.yml</title>
<para>
<screen>spring:
  cloud:
    zookeeper:
      config:
        enabled: true
        root: configuration
        defaultContext: apps
        profileSeparator: '::'</screen>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><literal>enabled</literal> setting this value to "false" disables Zookeeper Config</simpara>
</listitem>
<listitem>
<simpara><literal>root</literal> sets the base namespace for configuration values</simpara>
</listitem>
<listitem>
<simpara><literal>defaultContext</literal> sets the name used by all applications</simpara>
</listitem>
<listitem>
<simpara><literal>profileSeparator</literal> sets the value of the separator used to separate the profile name in property sources with profiles</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_acls">
<title>ACLs</title>
<simpara>You can add authentication information for Zookeeper ACLs by calling the addAuthInfo method of a
CuratorFramework bean. One way to accomplish this is by providing your own CuratorFramework bean:</simpara>
<programlisting language="java" linenumbering="unnumbered">@BoostrapConfiguration
public class CustomCuratorFrameworkConfig {

  @Bean
  public CuratorFramework curatorFramework() {
    CuratorFramework curator = new CuratorFramework();
    curator.addAuthInfo("digest", "user:password".getBytes());
    return curator;
  }

}</programlisting>
<simpara>Consult <link xl:href="https://github.com/spring-cloud/spring-cloud-zookeeper/blob/master/spring-cloud-zookeeper-core/src/main/java/org/springframework/cloud/zookeeper/ZookeeperAutoConfiguration.java">the ZookeeperAutoConfiguration class</link>
to see how the CuratorFramework bean is configured by default.</simpara>
<simpara>Alternatively, you can add your credentials from a class that depends on the existing
CuratorFramework bean:</simpara>
<programlisting language="java" linenumbering="unnumbered">@BoostrapConfiguration
public class DefaultCuratorFrameworkConfig {

  public ZookeeperConfig(CuratorFramework curator) {
    curator.addAuthInfo("digest", "user:password".getBytes());
  }

}</programlisting>
<simpara>This must occur during the boostrapping phase. You can register configuration classes to run
during this phase by annotating them with <literal>@BootstrapConfiguration</literal> and including them in a
comma-separated list set as the value of the property
<literal>org.springframework.cloud.bootstrap.BootstrapConfiguration</literal> in the file
<literal>resources/META-INF/spring.factories</literal>:</simpara>
<formalpara>
<title>resources/META-INF/spring.factories</title>
<para>
<screen>org.springframework.cloud.bootstrap.BootstrapConfiguration=\
my.project.CustomCuratorFrameworkConfig,\
my.project.DefaultCuratorFrameworkConfig</screen>
</para>
</formalpara>
<simpara>Unresolved directive in spring-cloud.adoc - include::../../../../cli/docs/src/main/asciidoc/spring-cloud-cli.adoc[]</simpara>
</section>
</chapter>
</part>
<part xml:id="_spring_cloud_security">
<title>Spring Cloud Security</title>
<partintro>
<simpara>Spring Cloud Security offers a set of primitives for building secure
applications and services with minimum fuss. A declarative model which
can be heavily configured externally (or centrally) lends itself to
the implementation of large systems of co-operating, remote components,
usually with a central indentity management service. It is also extremely
easy to use in a service platform like Cloud Foundry. Building on
Spring Boot and Spring Security OAuth2 we can quickly create systems that
implement common patterns like single sign on, token relay and token
exchange.</simpara>
<note>
<simpara>Spring Cloud is released under the non-restrictive Apache 2.0 license. If you would like to contribute to this section of the documentation or if you find an error, please find the source code and issue trackers in the project at <link xl:href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/asciidoc">github</link>.</simpara>
</note>
</partintro>
<chapter xml:id="_quickstart">
<title>Quickstart</title>
<section xml:id="_oauth2_single_sign_on">
<title>OAuth2 Single Sign On</title>
<simpara>Here&#8217;s a Spring Cloud "Hello World" app with HTTP Basic
authentication and a single user account:</simpara>
<formalpara>
<title>app.groovy</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@Grab('spring-boot-starter-security')
@Controller
class Application {

  @RequestMapping('/')
  String home() {
    'Hello World'
  }

}</programlisting>
</para>
</formalpara>
<simpara>You can run it with <literal>spring run app.groovy</literal> and watch the logs for the password (username is "user"). So far this is just the default for a Spring Boot app.</simpara>
<simpara>Here&#8217;s a Spring Cloud app with OAuth2 SSO:</simpara>
<formalpara>
<title>app.groovy</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@Controller
@EnableOAuth2Sso
class Application {

  @RequestMapping('/')
  String home() {
    'Hello World'
  }

}</programlisting>
</para>
</formalpara>
<simpara>Spot the difference? This app will actually behave exactly the same as
the previous one, because it doesn&#8217;t know it&#8217;s OAuth2 credentals
yet.</simpara>
<simpara>You can register an app in github quite easily, so try that if you
want a production app on your own domain. If you are happy to test on
localhost:8080, then set up these properties in your application
configuration:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">security:
  oauth2:
    client:
      clientId: bd1c0a783ccdd1c9b9e4
      clientSecret: 1a9030fbca47a5b2c28e92f19050bb77824b5ad1
      accessTokenUri: https://github.com/login/oauth/access_token
      userAuthorizationUri: https://github.com/login/oauth/authorize
      clientAuthenticationScheme: form
    resource:
      userInfoUri: https://api.github.com/user
      preferTokenInfo: false</programlisting>
</para>
</formalpara>
<simpara>run the app above and it will redirect to github for authorization. If
you are already signed into github you won&#8217;t even notice that it has
authenticated.  These credentials will only work if your app is
running on port 8080.</simpara>
<simpara>To limit the scope that the client asks for when it obtains an access token
you can set <literal>security.oauth2.client.scope</literal> (comma separated or an array in YAML). By
default the scope is empty and it is up to to Authorization Server to
decide what the defaults should be, usually depending on the settings in
the client registration that it holds.</simpara>
<note>
<simpara>The examples above are all Groovy scripts. If you want to write the
same code in Java (or Groovy) you need to add Spring Security OAuth2
to the classpath (e.g. see the
<link xl:href="https://github.com/spring-cloud-samples/sso">sample here</link>).</simpara>
</note>
</section>
<section xml:id="_oauth2_protected_resource">
<title>OAuth2 Protected Resource</title>
<simpara>You want to protect an API resource with an OAuth2 token? Here&#8217;s a
simple example (paired with the client above):</simpara>
<formalpara>
<title>app.groovy</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@Grab('spring-cloud-starter-security')
@RestController
@EnableResourceServer
class Application {

  @RequestMapping('/')
  def home() {
    [message: 'Hello World']
  }

}</programlisting>
</para>
</formalpara>
<simpara>and</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">security:
  oauth2:
    resource:
      userInfoUri: https://api.github.com/user
      preferTokenInfo: false</programlisting>
</para>
</formalpara>
</section>
</chapter>
<chapter xml:id="_more_detail">
<title>More Detail</title>
<section xml:id="_single_sign_on">
<title>Single Sign On</title>
<note>
<simpara>All of the OAuth2 SSO and resource server features moved to Spring Boot
in version 1.3. You can find documentation in the
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/">Spring Boot user guide</link>.</simpara>
</note>
</section>
<section xml:id="_token_relay">
<title>Token Relay</title>
<simpara>A Token Relay is where an OAuth2 consumer acts as a Client and
forwards the incoming token to outgoing resource requests. The
consumer can be a pure Client (like an SSO application) or a Resource
Server.</simpara>
<section xml:id="_client_token_relay">
<title>Client Token Relay</title>
<simpara>If your app is a user facing OAuth2 client (i.e. has declared
<literal>@EnableOAuth2Sso</literal> or <literal>@EnableOAuth2Client</literal>) then it has an
<literal>OAuth2ClientContext</literal> in request scope from Spring Boot. You can
create your own <literal>OAuth2RestTemplate</literal> from this context and an
autowired <literal>OAuth2ProtectedResourceDetails</literal>, and then the context will
always forward the access token downstream, also refreshing the access
token automatically if it expires. (These are features of Spring
Security and Spring Boot.)</simpara>
<note>
<simpara>Spring Boot (1.4.1) does not create an
<literal>OAuth2ProtectedResourceDetails</literal> automatically if you are using
<literal>client_credentials</literal> tokens. In that case you need to create your own
<literal>ClientCredentialsResourceDetails</literal> and configure it with
<literal>@ConfigurationProperties("security.oauth2.client")</literal>.</simpara>
</note>
</section>
<section xml:id="_client_token_relay_in_zuul_proxy">
<title>Client Token Relay in Zuul Proxy</title>
<simpara>If your app also has a
<link xl:href="https://cloud.spring.io/spring-cloud.html#netflix-zuul-reverse-proxy">Spring
Cloud Zuul</link> embedded reverse proxy (using <literal>@EnableZuulProxy</literal>) then you
can ask it to forward OAuth2 access tokens downstream to the services
it is proxying. Thus the SSO app above can be enhanced simply like
this:</simpara>
<formalpara>
<title>app.groovy</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@Controller
@EnableOAuth2Sso
@EnableZuulProxy
class Application {

}</programlisting>
</para>
</formalpara>
<simpara>and it will (in addition to logging the user in and grabbing a token)
pass the authentication token downstream to the <literal>/proxy/*</literal>
services. If those services are implemented with
<literal>@EnableResourceServer</literal> then they will get a valid token in the
correct header.</simpara>
<simpara>How does it work? The <literal>@EnableOAuth2Sso</literal> annotation pulls in
<literal>spring-cloud-starter-security</literal> (which you could do manually in a
traditional app), and that in turn triggers some autoconfiguration for
a <literal>ZuulFilter</literal>, which itself is activated because Zuul is on the
classpath (via <literal>@EnableZuulProxy</literal>). The
<link xl:href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/proxy/OAuth2TokenRelayFilter.java">filter</link>
just extracts an access token from the currently authenticated user,
and puts it in a request header for the downstream requests.</simpara>
</section>
<section xml:id="_resource_server_token_relay">
<title>Resource Server Token Relay</title>
<simpara>If your app has <literal>@EnableResourceServer</literal> you might want to relay the
incoming token downstream to other services. If you use a
<literal>RestTemplate</literal> to contact the downstream services then this is just a
matter of how to create the template with the right context.</simpara>
<simpara>If your service uses <literal>UserInfoTokenServices</literal> to authenticate incoming
tokens (i.e. it is using the <literal>security.oauth2.user-info-uri</literal>
configuration), then you can simply create an <literal>OAuth2RestTemplate</literal>
using an autowired <literal>OAuth2ClientContext</literal> (it will be populated by the
authentication process before it hits the backend code). Equivalently
(with Spring Boot 1.4), you could inject a
<literal>UserInfoRestTemplateFactory</literal> and grab its <literal>OAuth2RestTemplate</literal> in
your configuration. For example:</simpara>
<formalpara>
<title>MyConfiguration.java</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@Bean
public OAuth2RestTemplate restTemplate(UserInfoRestTemplateFactory factory) {
    return factory.getUserInfoRestTemplate();
}</programlisting>
</para>
</formalpara>
<simpara>This rest template will then have the same <literal>OAuth2ClientContext</literal>
(request-scoped) that is used by the authentication filter, so you can
use it to send requests with the same access token.</simpara>
<simpara>If your app is not using <literal>UserInfoTokenServices</literal> but is still a client
(i.e. it declares <literal>@EnableOAuth2Client</literal> or <literal>@EnableOAuth2Sso</literal>), then
with Spring Security Cloud any <literal>OAuth2RestOperations</literal> that the user
creates from an <literal>@Autowired</literal> <literal>@OAuth2Context</literal> will also forward
tokens. This feature is implemented by default as an MVC handler
interceptor, so it only works in Spring MVC. If you are not using MVC
you could use a custom filter or AOP interceptor wrapping an
<literal>AccessTokenContextRelay</literal> to provide the same feature.</simpara>
<simpara>Here&#8217;s a basic
example showing the use of an autowired rest template created
elsewhere ("foo.com" is a Resource Server accepting the same tokens as
the surrounding app):</simpara>
<formalpara>
<title>MyController.java</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@Autowired
private OAuth2RestOperations restTemplate;

@RequestMapping("/relay")
public String relay() {
    ResponseEntity&lt;String&gt; response =
      restTemplate.getForEntity("https://foo.com/bar", String.class);
    return "Success! (" + response.getBody() + ")";
}</programlisting>
</para>
</formalpara>
<simpara>If you don&#8217;t want to forward tokens (and that is a valid
choice, since you might want to act as yourself, rather than the
client that sent you the token), then you only need to create your own
<literal>OAuth2Context</literal> instead of autowiring the default one.</simpara>
<simpara>Feign clients will also pick up an interceptor that uses the
<literal>OAuth2ClientContext</literal> if it is available, so they should also do a
token relay anywhere where a <literal>RestTemplate</literal> would.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="_configuring_authentication_downstream_of_a_zuul_proxy">
<title>Configuring Authentication Downstream of a Zuul Proxy</title>
<simpara>You can control the authorization behaviour downstream of an
<literal>@EnableZuulProxy</literal> through the <literal>proxy.auth.*</literal> settings. Example:</simpara>
<formalpara>
<title>application.yml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">proxy:
  auth:
    routes:
      customers: oauth2
      stores: passthru
      recommendations: none</programlisting>
</para>
</formalpara>
<simpara>In this example the "customers" service gets an OAuth2 token relay,
the "stores" service gets a passthrough (the authorization header is
just passed downstream), and the "recommendations" service has its
authorization header removed. The default behaviour is to do a token
relay if there is a token available, and passthru otherwise.</simpara>
<simpara>See
<link xl:href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/proxy/ProxyAuthenticationProperties">
ProxyAuthenticationProperties</link> for full details.</simpara>
</chapter>
</part>
<part xml:id="_spring_cloud_for_cloud_foundry">
<title>Spring Cloud for Cloud Foundry</title>
<partintro>
<simpara>Spring Cloud for Cloudfoundry makes it easy to run
<link xl:href="https://github.com/spring-cloud">Spring Cloud</link> apps in
<link xl:href="https://github.com/cloudfoundry">Cloud Foundry</link> (the Platform as a
Service). Cloud Foundry has the notion of a "service", which is
middlware that you "bind" to an app, essentially providing it with an
environment variable containing credentials (e.g. the location and
username to use for the service).</simpara>
<simpara>The <literal>spring-cloud-cloudfoundry-web</literal> project provides basic support for
some enhanced features of webapps in Cloud Foundry: binding
automatically to single-sign-on services and optionally enabling
sticky routing for discovery.</simpara>
<simpara>The <literal>spring-cloud-cloudfoundry-discovery</literal> project provides an
implementation of Spring Cloud Commons <literal>DiscoveryClient</literal> so you can
<literal>@EnableDiscoveryClient</literal> and provide your credentials as
<literal>spring.cloud.cloudfoundry.discovery.[email,password]</literal> and then you
can use the <literal>DiscoveryClient</literal> directly or via a <literal>LoadBalancerClient</literal>
(also <literal>*.url</literal> if you are not connecting to
<link xl:href="https://run.pivotal.io">Pivotal Web Services</link>).</simpara>
<simpara>The first time you use it the discovery client might be slow owing to
the fact that it has to get an access token from Cloud Foundry.</simpara>
</partintro>
<chapter xml:id="_discovery">
<title>Discovery</title>
<simpara>Here&#8217;s a Spring Cloud app with Cloud Foundry discovery:</simpara>
<formalpara>
<title>app.groovy</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@Grab('org.springframework.cloud:spring-cloud-cloudfoundry')
@RestController
@EnableDiscoveryClient
class Application {

  @Autowired
  DiscoveryClient client

  @RequestMapping('/')
  String home() {
    'Hello from ' + client.getLocalServiceInstance()
  }

}</programlisting>
</para>
</formalpara>
<simpara>If you run it without any service bindings:</simpara>
<screen>$ spring jar app.jar app.groovy
$ cf push -p app.jar</screen>
<simpara>It will show its app name in the home page.</simpara>
<simpara>The <literal>DiscoveryClient</literal> can lists all the apps in a space, according to
the credentials it is authenticated with, where the space defaults to
the one the client is running in (if any). If neither org nor space
are configured, they default per the user&#8217;s profile in Cloud Foundry.</simpara>
</chapter>
<chapter xml:id="_single_sign_on_2">
<title>Single Sign On</title>
<note>
<simpara>All of the OAuth2 SSO and resource server features moved to Spring Boot
in version 1.3. You can find documentation in the
<link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/">Spring Boot user guide</link>.</simpara>
</note>
<simpara>This project provides automatic binding from CloudFoundry service
credentials to the Spring Boot features. If you have a CloudFoundry
service called "sso", for instance, with credentials containing
"client_id", "client_secret" and "auth_domain", it will bind
automatically to the Spring OAuth2 client that you enable with
<literal>@EnableOAuth2Sso</literal> (from Spring Boot). The name of the service can be
parameterized using <literal>spring.oauth2.sso.serviceId</literal>.</simpara>
</chapter>
</part>
<part xml:id="_spring_cloud_contract">
<title>Spring Cloud Contract</title>
<partintro>
<simpara>_Documentation Authors: Adam Dudczak, Mathias Düsterhöft, Marcin Grzejszczak, Dennis Kieselhorst, Jakub Kubryński, Karol Lassak,
Olga Maciaszek-Sharma, Mariusz Smykuła, Dave Syer, Jay Bryant</simpara>
<simpara>Edgware.SR2</simpara>
</partintro>
<chapter xml:id="_spring_cloud_contract_2">
<title>Spring Cloud Contract</title>
<simpara>You need confidence when pushing new features to a new application or service in a
distributed system. This project provides support for Consumer Driven Contracts and
service schemas in Spring applications (for both HTTP and message-based interactions),
covering a range of options for writing tests,  publishing them as assets, and asserting
that a contract is kept by producers and consumers.</simpara>
</chapter>
<chapter xml:id="_spring_cloud_contract_verifier_introduction">
<title>Spring Cloud Contract Verifier Introduction</title>
<tip>
<simpara>The Accurest project was initially started by Marcin Grzejszczak and Jakub Kubrynski
(<link xl:href="http://codearte.io">codearte.io</link>)</simpara>
</tip>
<simpara>Spring Cloud Contract Verifier enables Consumer Driven Contract (CDC) development of
JVM-based applications. It moves TDD to the level of software architecture.</simpara>
<simpara>Spring Cloud Contract Verifier ships with <emphasis>Contract Definition Language</emphasis> (CDL). Contract
definitions are used to produce the following resources:</simpara>
<itemizedlist>
<listitem>
<simpara>JSON stub definitions to be used by WireMock when doing integration testing on the
client code (<emphasis>client tests</emphasis>). Test code must still be written by hand, and test data is
produced by Spring Cloud Contract Verifier.</simpara>
</listitem>
<listitem>
<simpara>Messaging routes, if you&#8217;re using a messaging service. We integrate with Spring
Integration, Spring Cloud Stream, Spring AMQP, and Apache Camel. You can also set your
own integrations.</simpara>
</listitem>
<listitem>
<simpara>Acceptance tests (in JUnit or Spock) are used to verify if server-side implementation
of the API is compliant with the contract (<emphasis>server tests</emphasis>). A full test is generated by
Spring Cloud Contract Verifier.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_why_a_contract_verifier">
<title>Why a Contract Verifier?</title>
<simpara>Assume that we have a system consisting of multiple microservices:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-contract/master/docs/src/main/asciidoc/images/Deps.png"/>
</imageobject>
<textobject><phrase>Microservices Architecture</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="_testing_issues">
<title>Testing issues</title>
<simpara>If we wanted to test the application in top left corner to determine whether it can
communicate with other services, we could do one of two things:</simpara>
<itemizedlist>
<listitem>
<simpara>Deploy all microservices and perform end-to-end tests.</simpara>
</listitem>
<listitem>
<simpara>Mock other microservices in unit/integration tests.</simpara>
</listitem>
</itemizedlist>
<simpara>Both have their advantages but also a lot of disadvantages.</simpara>
<simpara><emphasis role="strong">Deploy all microservices and perform end to end tests</emphasis></simpara>
<simpara>Advantages:</simpara>
<itemizedlist>
<listitem>
<simpara>Simulates production.</simpara>
</listitem>
<listitem>
<simpara>Tests real communication between services.</simpara>
</listitem>
</itemizedlist>
<simpara>Disadvantages:</simpara>
<itemizedlist>
<listitem>
<simpara>To test one microservice, we have to deploy 6 microservices, a couple of databases,
etc.</simpara>
</listitem>
<listitem>
<simpara>The environment where the tests run is locked for a single suite of tests (nobody else
would be able to run the tests in the meantime).</simpara>
</listitem>
<listitem>
<simpara>They take a long time to run.</simpara>
</listitem>
<listitem>
<simpara>The feedback comes very late in the process.</simpara>
</listitem>
<listitem>
<simpara>They are extremely hard to debug.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Mock other microservices in unit/integration tests</emphasis></simpara>
<simpara>Advantages:</simpara>
<itemizedlist>
<listitem>
<simpara>They provide very fast feedback.</simpara>
</listitem>
<listitem>
<simpara>They have no infrastructure requirements.</simpara>
</listitem>
</itemizedlist>
<simpara>Disadvantages:</simpara>
<itemizedlist>
<listitem>
<simpara>The implementor of the service creates stubs that might have nothing to do with
reality.</simpara>
</listitem>
<listitem>
<simpara>You can go to production with passing tests and failing production.</simpara>
</listitem>
</itemizedlist>
<simpara>To solve the aforementioned issues, Spring Cloud Contract Verifier with Stub Runner was
created. The main idea is to give you very fast feedback, without the need to set up the
whole world of microservices. If you work on stubs, then the only applications you need
are those that your application directly uses.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-contract/master/docs/src/main/asciidoc/images/Stubs2.png"/>
</imageobject>
<textobject><phrase>Stubbed Services</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Spring Cloud Contract Verifier gives you the certainty that the stubs that you use were
created by the service that you&#8217;re calling. Also, if you can use them, it means that they
were tested against the producer&#8217;s side. In short, you can trust those stubs.</simpara>
</section>
</section>
<section xml:id="_purposes">
<title>Purposes</title>
<simpara>The main purposes of Spring Cloud Contract Verifier with Stub Runner are:</simpara>
<itemizedlist>
<listitem>
<simpara>To ensure that WireMock/Messaging stubs (used when developing the client) do exactly
what the actual server-side implementation does.</simpara>
</listitem>
<listitem>
<simpara>To promote ATDD method and Microservices architectural style.</simpara>
</listitem>
<listitem>
<simpara>To provide a way to publish changes in contracts that are immediately visible on both
sides.</simpara>
</listitem>
<listitem>
<simpara>To generate boilerplate test code to be used on the server side.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Spring Cloud Contract Verifier&#8217;s purpose is NOT to start writing business
features in the contracts. Assume that we have a business use case of fraud check. If a
user can be a fraud for 100 different reasons, we would assume that you would create 2
contracts, one for the positive case and one for the negative case. Contract tests are
used to test contracts between applications and not to simulate full behavior.</simpara>
</important>
</section>
<section xml:id="_how_it_works">
<title>How It Works</title>
<simpara>This section explores how Spring Cloud Contract Verifier with Stub Runner works.</simpara>
<section xml:id="_defining_the_contract">
<title>Defining the contract</title>
<simpara>As consumers of services, we need to define what exactly we want to achieve. We need to
formulate our expectations. That is why we write contracts.</simpara>
<simpara>Assume that you want to send a request containing the ID of a client company and the
amount it wants to borrow from us. You also want to send it to the /fraudcheck url via
the PUT method.</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">package contracts

org.springframework.cloud.contract.spec.Contract.make {
	request { // (1)
		method 'PUT' // (2)
		url '/fraudcheck' // (3)
		body([ // (4)
			   "client.id": $(regex('[0-9]{10}')),
			   loanAmount: 99999
		])
		headers { // (5)
			contentType('application/json')
		}
	}
	response { // (6)
		status 200 // (7)
		body([ // (8)
			   fraudCheckStatus: "FRAUD",
			   "rejection.reason": "Amount too high"
		])
		headers { // (9)
			contentType('application/json')
		}
	}
}

/*
From the Consumer perspective, when shooting a request in the integration test:

(1) - If the consumer sends a request
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the response will be sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` equal to `application/json`

From the Producer perspective, in the autogenerated producer-side test:

(1) - A request will be sent to the producer
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that will have a generated value that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the test will assert if the response has been sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` matching `application/json.*`
 */</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">request: # (1)
  method: PUT # (2)
  url: /fraudcheck # (3)
  body: # (4)
    "client.id": 1234567890
    loanAmount: 99999
  headers: # (5)
    Content-Type: application/json
  matchers:
    body:
      - path: $.['client.id'] # (6)
        type: by_regex
        value: "[0-9]{10}"
response: # (7)
  status: 200 # (8)
  body:  # (9)
    fraudCheckStatus: "FRAUD"
    "rejection.reason": "Amount too high"
  headers: # (10)
    Content-Type: application/json;charset=UTF-8


#From the Consumer perspective, when shooting a request in the integration test:
#
#(1) - If the consumer sends a request
#(2) - With the "PUT" method
#(3) - to the URL "/fraudcheck"
#(4) - with the JSON body that
# * has a field `client.id`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(6) - and a `client.id` json entry matches the regular expression `[0-9]{10}`
#(7) - then the response will be sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json`
#
#From the Producer perspective, in the autogenerated producer-side test:
#
#(1) - A request will be sent to the producer
#(2) - With the "PUT" method
#(3) - to the URL "/fraudcheck"
#(4) - with the JSON body that
# * has a field `client.id` `1234567890`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(7) - then the test will assert if the response has been sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json;charset=UTF-8`</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_client_side">
<title>Client Side</title>
<simpara>Spring Cloud Contract generates stubs, which you can use during client-side testing.
You get a running WireMock instance/Messaging route that simulates the service.
You would like to feed that instance with a proper stub definition.</simpara>
<simpara>At some point in time, you need to send a request to the Fraud Detection service.</simpara>
<programlisting language="groovy" linenumbering="unnumbered">ResponseEntity&lt;FraudServiceResponse&gt; response =
		restTemplate.exchange("http://localhost:" + port + "/fraudcheck", HttpMethod.PUT,
				new HttpEntity&lt;&gt;(request, httpHeaders),
				FraudServiceResponse.class);</programlisting>
<simpara>Annotate your test class with <literal>@AutoConfigureStubRunner</literal>. In the annotation provide the group id and artifact id for the Stub Runner to download stubs of your collaborators.</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment=WebEnvironment.NONE)
@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:6565"}, workOffline = true)
@DirtiesContext
public class LoanApplicationServiceTests {</programlisting>
<simpara>After that, during the tests, Spring Cloud Contract automatically finds the stubs
(simulating the real service) in the Maven repository and exposes them on a configured
(or random) port.</simpara>
</section>
<section xml:id="_server_side">
<title>Server Side</title>
<simpara>Since you are developing your stub, you need to be sure that it actually resembles your
concrete implementation. You cannot have a situation where your stub acts in one way and
your application behaves in a different way, especially in production.</simpara>
<simpara>To ensure that your application behaves the way you define in your stub, tests are
generated from the stub you provide.</simpara>
<simpara>The autogenerated test looks, more or less, like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Test
public void validate_shouldMarkClientAsFraud() throws Exception {
    // given:
        MockMvcRequestSpecification request = given()
                .header("Content-Type", "application/vnd.fraud.v1+json")
                .body("{\"client.id\":\"1234567890\",\"loanAmount\":99999}");

    // when:
        ResponseOptions response = given().spec(request)
                .put("/fraudcheck");

    // then:
        assertThat(response.statusCode()).isEqualTo(200);
        assertThat(response.header("Content-Type")).matches("application/vnd.fraud.v1.json.*");
    // and:
        DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
        assertThatJson(parsedJson).field("['fraudCheckStatus']").matches("[A-Z]{5}");
        assertThatJson(parsedJson).field("['rejection.reason']").isEqualTo("Amount too high");
}</programlisting>
</section>
</section>
<section xml:id="_step_by_step_guide_to_consumer_driven_contracts_cdc">
<title>Step-by-step Guide to Consumer Driven Contracts (CDC)</title>
<simpara>Consider an example of Fraud Detection and the Loan Issuance process. The business
scenario is such that we want to issue loans to people but do not want them to steal from
us. The current implementation of our system grants loans to everybody.</simpara>
<simpara>Assume that <literal>Loan Issuance</literal> is a client to the <literal>Fraud Detection</literal> server. In the current
sprint, we must develop a new feature: if a client wants to borrow too much money, then
we mark the client as a fraud.</simpara>
<simpara>Technical remark - Fraud Detection has an <literal>artifact-id</literal> of <literal>http-server</literal>, while Loan
Issuance has an artifact-id of <literal>http-client</literal>, and both have a <literal>group-id</literal> of <literal>com.example</literal>.</simpara>
<simpara>Social remark - both client and server development teams need to communicate directly and
discuss changes while going through the process. CDC is all about communication.</simpara>
<simpara>The <link xl:href="https://github.com/spring-cloud/spring-cloud-contract/tree/master/samples/standalone/dsl/http-server">server
side code is available here</link> and <link xl:href="https://github.com/spring-cloud/spring-cloud-contract/tree/master/samples/standalone/dsl/http-client">the
client code here</link>.</simpara>
<tip>
<simpara>In this case, the producer owns the contracts. Physically, all the contract are
in the producer&#8217;s repository.</simpara>
</tip>
<section xml:id="_technical_note">
<title>Technical note</title>
<simpara>If using the <emphasis role="strong">SNAPSHOT</emphasis> / <emphasis role="strong">Milestone</emphasis> / <emphasis role="strong">Release Candidate</emphasis> versions please add the
following section to your build:</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">repositories {
	mavenCentral()
	mavenLocal()
	maven { url "https://repo.spring.io/snapshot" }
	maven { url "https://repo.spring.io/milestone" }
	maven { url "https://repo.spring.io/release" }
}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_consumer_side_loan_issuance">
<title>Consumer side (Loan Issuance)</title>
<simpara>As a developer of the Loan Issuance service (a consumer of the Fraud Detection server), you might do the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Start doing TDD by writing a test for your feature.</simpara>
</listitem>
<listitem>
<simpara>Write the missing implementation.</simpara>
</listitem>
<listitem>
<simpara>Clone the Fraud Detection service repository locally.</simpara>
</listitem>
<listitem>
<simpara>Define the contract locally in the repo of Fraud Detection service.</simpara>
</listitem>
<listitem>
<simpara>Add the Spring Cloud Contract Verifier plugin.</simpara>
</listitem>
<listitem>
<simpara>Run the integration tests.</simpara>
</listitem>
<listitem>
<simpara>File a pull request.</simpara>
</listitem>
<listitem>
<simpara>Create an initial implementation.</simpara>
</listitem>
<listitem>
<simpara>Take over the pull request.</simpara>
</listitem>
<listitem>
<simpara>Write the missing implementation.</simpara>
</listitem>
<listitem>
<simpara>Deploy your app.</simpara>
</listitem>
<listitem>
<simpara>Work online.</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Start doing TDD by writing a test for your feature.</emphasis></simpara>
<programlisting language="groovy" linenumbering="unnumbered">@Test
public void shouldBeRejectedDueToAbnormalLoanAmount() {
	// given:
	LoanApplication application = new LoanApplication(new Client("1234567890"),
			99999);
	// when:
	LoanApplicationResult loanApplication = service.loanApplication(application);
	// then:
	assertThat(loanApplication.getLoanApplicationStatus())
			.isEqualTo(LoanApplicationStatus.LOAN_APPLICATION_REJECTED);
	assertThat(loanApplication.getRejectionReason()).isEqualTo("Amount too high");
}</programlisting>
<simpara>Assume that you have written a test of your new feature. If a loan application for a big
amount is received, the system should reject that loan application with some description.</simpara>
<simpara><emphasis role="strong">Write the missing implementation.</emphasis></simpara>
<simpara>At some point in time, you need to send a request to the Fraud Detection service. Assume
that you need to send the request containing the ID of the client and the amount the
client wants to borrow. You want to send it to the <literal>/fraudcheck</literal> url via the <literal>PUT</literal> method.</simpara>
<programlisting language="groovy" linenumbering="unnumbered">ResponseEntity&lt;FraudServiceResponse&gt; response =
		restTemplate.exchange("http://localhost:" + port + "/fraudcheck", HttpMethod.PUT,
				new HttpEntity&lt;&gt;(request, httpHeaders),
				FraudServiceResponse.class);</programlisting>
<simpara>For simplicity, the port of the Fraud Detection service is set to <literal>8080</literal>, and the
application runs on <literal>8090</literal>.</simpara>
<simpara>If you start the test at this point, it breaks, because no service currently runs on port
<literal>8080</literal>.</simpara>
<simpara><emphasis role="strong">Clone the Fraud Detection service repository locally.</emphasis></simpara>
<simpara>You can start by playing around with the server side contract. To do so, you must first
clone it.</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git clone https://your-git-server.com/server-side.git local-http-server-repo</programlisting>
<simpara><emphasis role="strong">Define the contract locally in the repo of Fraud Detection service.</emphasis></simpara>
<simpara>As a consumer, you need to define what exactly you want to achieve. You need to formulate
your expectations. To do so, write the following contract:</simpara>
<important>
<simpara>Place the contract under <literal>src/test/resources/contracts/fraud</literal> folder. The <literal>fraud</literal> folder
is important because the producer&#8217;s test base class name references that folder.</simpara>
</important>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">package contracts

org.springframework.cloud.contract.spec.Contract.make {
	request { // (1)
		method 'PUT' // (2)
		url '/fraudcheck' // (3)
		body([ // (4)
			   "client.id": $(regex('[0-9]{10}')),
			   loanAmount: 99999
		])
		headers { // (5)
			contentType('application/json')
		}
	}
	response { // (6)
		status 200 // (7)
		body([ // (8)
			   fraudCheckStatus: "FRAUD",
			   "rejection.reason": "Amount too high"
		])
		headers { // (9)
			contentType('application/json')
		}
	}
}

/*
From the Consumer perspective, when shooting a request in the integration test:

(1) - If the consumer sends a request
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the response will be sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` equal to `application/json`

From the Producer perspective, in the autogenerated producer-side test:

(1) - A request will be sent to the producer
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that will have a generated value that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the test will assert if the response has been sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` matching `application/json.*`
 */</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">request: # (1)
  method: PUT # (2)
  url: /fraudcheck # (3)
  body: # (4)
    "client.id": 1234567890
    loanAmount: 99999
  headers: # (5)
    Content-Type: application/json
  matchers:
    body:
      - path: $.['client.id'] # (6)
        type: by_regex
        value: "[0-9]{10}"
response: # (7)
  status: 200 # (8)
  body:  # (9)
    fraudCheckStatus: "FRAUD"
    "rejection.reason": "Amount too high"
  headers: # (10)
    Content-Type: application/json;charset=UTF-8


#From the Consumer perspective, when shooting a request in the integration test:
#
#(1) - If the consumer sends a request
#(2) - With the "PUT" method
#(3) - to the URL "/fraudcheck"
#(4) - with the JSON body that
# * has a field `client.id`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(6) - and a `client.id` json entry matches the regular expression `[0-9]{10}`
#(7) - then the response will be sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json`
#
#From the Producer perspective, in the autogenerated producer-side test:
#
#(1) - A request will be sent to the producer
#(2) - With the "PUT" method
#(3) - to the URL "/fraudcheck"
#(4) - with the JSON body that
# * has a field `client.id` `1234567890`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(7) - then the test will assert if the response has been sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json;charset=UTF-8`</programlisting>
</para>
</formalpara>
<simpara>The YML contract is quite straight-forward. However when you take a look at the Contract
written using a statically typed Groovy DSL - you might wonder what the
<literal>value(client(&#8230;&#8203;), server(&#8230;&#8203;))</literal> parts are. By using this notation, Spring Cloud
Contract lets you define parts of a JSON block, a URL, etc., which are dynamic. In case
of an identifier or a timestamp, you need not hardcode a value. You want to allow some
different ranges of values. To enable ranges of values, you can set regular expressions
matching those values for the consumer side. You can provide the body by means of either
a map notation or String with interpolations.
<link xl:href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_contract_dsl">Consult the docs
for more information.</link> We highly recommend using the map notation!</simpara>
<tip>
<simpara>You must understand the map notation in order to set up contracts. Please read the
<link xl:href="http://groovy-lang.org/json.html">Groovy docs regarding JSON</link>.</simpara>
</tip>
<simpara>The previously shown contract is an agreement between two sides that:</simpara>
<itemizedlist>
<listitem>
<simpara>if an HTTP request is sent with all of</simpara>
<itemizedlist>
<listitem>
<simpara>a <literal>PUT</literal> method on the <literal>/fraudcheck</literal> endpoint,</simpara>
</listitem>
<listitem>
<simpara>a JSON body with a <literal>client.id</literal> that matches the regular expression <literal>[0-9]{10}</literal> and
<literal>loanAmount</literal> equal to <literal>99999</literal>,</simpara>
</listitem>
<listitem>
<simpara>and a <literal>Content-Type</literal> header with a value of <literal>application/vnd.fraud.v1+json</literal>,</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>then an HTTP response is sent to the consumer that</simpara>
<itemizedlist>
<listitem>
<simpara>has status <literal>200</literal>,</simpara>
</listitem>
<listitem>
<simpara>contains a JSON body with the <literal>fraudCheckStatus</literal> field containing a value <literal>FRAUD</literal> and
the <literal>rejectionReason</literal> field having value <literal>Amount too high</literal>,</simpara>
</listitem>
<listitem>
<simpara>and a <literal>Content-Type</literal> header with a value of <literal>application/vnd.fraud.v1+json</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Once you are ready to check the API in practice in the integration tests, you need to
install the stubs locally.</simpara>
<simpara><emphasis role="strong">Add the Spring Cloud Contract Verifier plugin.</emphasis></simpara>
<simpara>We can add either a Maven or a Gradle plugin. In this example, you see how to add Maven.
First, add the <literal>Spring Cloud Contract</literal> BOM.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</programlisting>
<simpara>Next, add the <literal>Spring Cloud Contract Verifier</literal> Maven plugin</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
<simpara>Since the plugin was added, you get the <literal>Spring Cloud Contract Verifier</literal> features which,
from the provided contracts:</simpara>
<itemizedlist>
<listitem>
<simpara>generate and run tests</simpara>
</listitem>
<listitem>
<simpara>produce and install stubs</simpara>
</listitem>
</itemizedlist>
<simpara>You do not want to generate tests since you, as the consumer, want only to play with the
stubs. You need to skip the test generation and execution. When you execute:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ cd local-http-server-repo
$ ./mvnw clean install -DskipTests</programlisting>
<simpara>In the logs, you see something like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">[INFO] --- spring-cloud-contract-maven-plugin:1.0.0.BUILD-SNAPSHOT:generateStubs (default-generateStubs) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar
[INFO]
[INFO] --- maven-jar-plugin:2.6:jar (default-jar) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-0.0.1-SNAPSHOT.jar
[INFO]
[INFO] --- spring-boot-maven-plugin:1.5.5.BUILD-SNAPSHOT:repackage (default) @ http-server ---
[INFO]
[INFO] --- maven-install-plugin:2.5.2:install (default-install) @ http-server ---
[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT.jar
[INFO] Installing /some/path/http-server/pom.xml to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT.pom
[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar</programlisting>
<simpara>The following line is extremely important:</simpara>
<programlisting language="bash" linenumbering="unnumbered">[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar</programlisting>
<simpara>It confirms that the stubs of the <literal>http-server</literal> have been installed in the local
repository.</simpara>
<simpara><emphasis role="strong">Run the integration tests.</emphasis></simpara>
<simpara>In order to profit from the Spring Cloud Contract Stub Runner functionality of automatic
stub downloading, you must do the following in your consumer side project (<literal>Loan
Application service</literal>):</simpara>
<simpara>Add the <literal>Spring Cloud Contract</literal> BOM:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</programlisting>
<simpara>Add the dependency to <literal>Spring Cloud Contract Stub Runner</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-starter-contract-stub-runner&lt;/artifactId&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</programlisting>
<simpara>Annotate your test class with <literal>@AutoConfigureStubRunner</literal>. In the annotation, provide the
<literal>group-id</literal> and <literal>artifact-id</literal> for the Stub Runner to download the stubs of your
collaborators. (Optional step) Because you&#8217;re playing with the collaborators offline, you
can also provide the offline work switch.</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment=WebEnvironment.NONE)
@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:6565"}, workOffline = true)
@DirtiesContext
public class LoanApplicationServiceTests {</programlisting>
<simpara>Now, when you run your tests, you see something like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">2016-07-19 14:22:25.403  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Desired version is + - will try to resolve the latest version
2016-07-19 14:22:25.438  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved version is 0.0.1-SNAPSHOT
2016-07-19 14:22:25.439  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolving artifact com.example:http-server:jar:stubs:0.0.1-SNAPSHOT using remote repositories []
2016-07-19 14:22:25.451  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved artifact com.example:http-server:jar:stubs:0.0.1-SNAPSHOT to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar
2016-07-19 14:22:25.465  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacking stub from JAR [URI: file:/path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar]
2016-07-19 14:22:25.475  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacked file to [/var/folders/0p/xwq47sq106x1_g3dtv6qfm940000gq/T/contracts100276532569594265]
2016-07-19 14:22:27.737  INFO 41050 --- [           main] o.s.c.c.stubrunner.StubRunnerExecutor    : All stubs are now running RunningStubs [namesAndPorts={com.example:http-server:0.0.1-SNAPSHOT:stubs=8080}]</programlisting>
<simpara>This output means that Stub Runner has found your stubs and started a server for your app
with group id <literal>com.example</literal>, artifact id <literal>http-server</literal> with version <literal>0.0.1-SNAPSHOT</literal> of
the stubs and with <literal>stubs</literal> classifier on port <literal>8080</literal>.</simpara>
<simpara><emphasis role="strong">File a pull request.</emphasis></simpara>
<simpara>What you have done until now is an iterative process. You can play around with the
contract, install it locally, and work on the consumer side until the contract works as
you wish.</simpara>
<simpara>Once you are satisfied with the results and the test passes, publish a pull request to
the server side. Currently, the consumer side work is done.</simpara>
</section>
<section xml:id="_producer_side_fraud_detection_server">
<title>Producer side (Fraud Detection server)</title>
<simpara>As a developer of the Fraud Detection server (a server to the Loan Issuance service):</simpara>
<simpara><emphasis role="strong">Create an initial implementation.</emphasis></simpara>
<simpara>As a reminder, you can see the initial implementation here:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RequestMapping(value = "/fraudcheck", method = PUT)
public FraudCheckResult fraudCheck(@RequestBody FraudCheck fraudCheck) {
return new FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}</programlisting>
<simpara><emphasis role="strong">Take over the pull request.</emphasis></simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git checkout -b contract-change-pr master
$ git pull https://your-git-server.com/server-side-fork.git contract-change-pr</programlisting>
<simpara>You must add the dependencies needed by the autogenerated tests:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-starter-contract-verifier&lt;/artifactId&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</programlisting>
<simpara>In the configuration of the Maven plugin, pass the <literal>packageWithBaseClasses</literal> property</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
<important>
<simpara>This example uses "convention based" naming by setting the
<literal>packageWithBaseClasses</literal> property. Doing so means that the two last packages combine to
make the name of the base test class. In our case, the contracts were placed under
<literal>src/test/resources/contracts/fraud</literal>. Since you do not have two packages starting from
the <literal>contracts</literal> folder, pick only one, which should be <literal>fraud</literal>. Add the <literal>Base</literal> suffix and
capitalize <literal>fraud</literal>. That gives you the <literal>FraudBase</literal> test class name.</simpara>
</important>
<simpara>All the generated tests extend that class. Over there, you can set up your Spring Context
or whatever is necessary. In this case, use <link xl:href="http://rest-assured.io/">Rest Assured MVC</link> to
start the server side <literal>FraudDetectionController</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.example.fraud;

import org.junit.Before;

import io.restassured.module.mockmvc.RestAssuredMockMvc;

public class FraudBase {
	@Before
	public void setup() {
		RestAssuredMockMvc.standaloneSetup(new FraudDetectionController(),
				new FraudStatsController(stubbedStatsProvider()));
	}

	private StatsProvider stubbedStatsProvider() {
		return fraudType -&gt; {
			switch (fraudType) {
			case DRUNKS:
				return 100;
			case ALL:
				return 200;
			}
			return 0;
		};
	}

	public void assertThatRejectionReasonIsNull(Object rejectionReason) {
		assert rejectionReason == null;
	}
}</programlisting>
<simpara>Now, if you run the <literal>./mvnw clean install</literal>, you get something like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">Results :

Tests in error:
  ContractVerifierTest.validate_shouldMarkClientAsFraud:32 » IllegalState Parsed...</programlisting>
<simpara>This error occurs because you have a new contract from which a test was generated and it
failed since you have not implemented the feature. The auto-generated test would look
like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Test
public void validate_shouldMarkClientAsFraud() throws Exception {
    // given:
        MockMvcRequestSpecification request = given()
                .header("Content-Type", "application/vnd.fraud.v1+json")
                .body("{\"client.id\":\"1234567890\",\"loanAmount\":99999}");

    // when:
        ResponseOptions response = given().spec(request)
                .put("/fraudcheck");

    // then:
        assertThat(response.statusCode()).isEqualTo(200);
        assertThat(response.header("Content-Type")).matches("application/vnd.fraud.v1.json.*");
    // and:
        DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
        assertThatJson(parsedJson).field("['fraudCheckStatus']").matches("[A-Z]{5}");
        assertThatJson(parsedJson).field("['rejection.reason']").isEqualTo("Amount too high");
}</programlisting>
<simpara>If you used the Groovy DSL, you can see, all the <literal>producer()</literal> parts of the Contract that were present in the
<literal>value(consumer(&#8230;&#8203;), producer(&#8230;&#8203;))</literal> blocks got injected into the test.
In case of using YAML, the same applied for the <literal>matchers</literal> sections of the <literal>response</literal>.</simpara>
<simpara>Note that, on the producer side, you are also doing TDD. The expectations are expressed
in the form of a test. This test sends a request to our own application with the URL,
headers, and body defined in the contract. It also is expecting precisely defined values
in the response. In other words, you have the <literal>red</literal> part of <literal>red</literal>, <literal>green</literal>, and
<literal>refactor</literal>. It is time to convert the <literal>red</literal> into the <literal>green</literal>.</simpara>
<simpara><emphasis role="strong">Write the missing implementation.</emphasis></simpara>
<simpara>Because you know the expected input and expected output, you can write the missing
implementation:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RequestMapping(value = "/fraudcheck", method = PUT)
public FraudCheckResult fraudCheck(@RequestBody FraudCheck fraudCheck) {
if (amountGreaterThanThreshold(fraudCheck)) {
	return new FraudCheckResult(FraudCheckStatus.FRAUD, AMOUNT_TOO_HIGH);
}
return new FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}</programlisting>
<simpara>When you execute <literal>./mvnw clean install</literal> again, the tests pass. Since the <literal>Spring Cloud
Contract Verifier</literal> plugin adds the tests to the <literal>generated-test-sources</literal>, you can
actually run those tests from your IDE.</simpara>
<simpara><emphasis role="strong">Deploy your app.</emphasis></simpara>
<simpara>Once you finish your work, you can deploy your change. First, merge the branch:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git checkout master
$ git merge --no-ff contract-change-pr
$ git push origin master</programlisting>
<simpara>Your CI might run something like <literal>./mvnw clean deploy</literal>, which would publish both the
application and the stub artifacts.</simpara>
</section>
<section xml:id="_consumer_side_loan_issuance_final_step">
<title>Consumer Side (Loan Issuance) Final Step</title>
<simpara>As a developer of the Loan Issuance service (a consumer of the Fraud Detection server):</simpara>
<simpara><emphasis role="strong">Merge branch to master.</emphasis></simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git checkout master
$ git merge --no-ff contract-change-pr</programlisting>
<simpara><emphasis role="strong">Work online.</emphasis></simpara>
<simpara>Now you can disable the offline work for Spring Cloud Contract Stub Runner and indicate
where the repository with your stubs is located. At this moment the stubs of the server
side are automatically downloaded from Nexus/Artifactory. You can switch off the value of
the <literal>workOffline</literal> parameter in your annotation. The following code shows an example of
achieving the same thing by changing the properties.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">stubrunner:
  ids: 'com.example:http-server-dsl:+:stubs:8080'
  repositoryRoot: https://repo.spring.io/libs-snapshot</programlisting>
<simpara>That&#8217;s it!</simpara>
</section>
</section>
<section xml:id="_dependencies">
<title>Dependencies</title>
<simpara>The best way to add dependencies is to use the proper <literal>starter</literal> dependency.</simpara>
<simpara>For <literal>stub-runner</literal>, use <literal>spring-cloud-starter-stub-runner</literal>. When you use a plugin, add
<literal>spring-cloud-starter-contract-verifier</literal>.</simpara>
</section>
<section xml:id="_additional_links">
<title>Additional Links</title>
<simpara>Here are some resources related to Spring Cloud Contract Verifier and Stub Runner. Note
that some may be outdated, because the Spring Cloud Contract Verifier project is under
constant development.</simpara>
<section xml:id="_spring_cloud_contract_video">
<title>Spring Cloud Contract video</title>
<simpara>You can check out the video from the Warsaw JUG about Spring Cloud Contract:</simpara>

</section>
<section xml:id="_readings">
<title>Readings</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://www.slideshare.net/MarcinGrzejszczak/stick-to-the-rules-consumer-driven-contracts-201507-confitura">Slides from Marcin Grzejszczak&#8217;s talk about Accurest</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://toomuchcoding.com/blog/categories/accurest/">Accurest related articles from Marcin Grzejszczak&#8217;s blog</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://toomuchcoding.com/blog/categories/spring-cloud-contract/">Spring Cloud Contract related articles from Marcin Grzejszczak&#8217;s blog</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="http://groovy-lang.org/json.html">Groovy docs regarding JSON</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_samples_2">
<title>Samples</title>
<simpara>You can find some samples at
<link xl:href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples">samples</link>.</simpara>
</section>
</chapter>
<chapter xml:id="_spring_cloud_contract_faq">
<title>Spring Cloud Contract FAQ</title>
<section xml:id="_why_use_spring_cloud_contract_verifier_and_not_x">
<title>Why use Spring Cloud Contract Verifier and not X ?</title>
<simpara>For the time being Spring Cloud Contract Verifier is a JVM based tool. So it could be your first pick when you&#8217;re already creating
software for the JVM. This project has a lot of really interesting features but especially quite a few of them definitely make
Spring Cloud Contract Verifier stand out on the "market" of Consumer Driven Contract (CDC) tooling. Out of many the most interesting are:</simpara>
<itemizedlist>
<listitem>
<simpara>Possibility to do CDC with messaging</simpara>
</listitem>
<listitem>
<simpara>Clear and easy to use, statically typed DSL</simpara>
</listitem>
<listitem>
<simpara>Possibility to copy paste your current JSON file to the contract and only edit its elements</simpara>
</listitem>
<listitem>
<simpara>Automatic generation of tests from the defined Contract</simpara>
</listitem>
<listitem>
<simpara>Stub Runner functionality - the stubs are automatically downloaded at runtime from Nexus / Artifactory</simpara>
</listitem>
<listitem>
<simpara>Spring Cloud integration - no discovery service is needed for integration tests</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_i_don_t_want_to_write_a_contract_in_groovy">
<title>I don&#8217;t want to write a contract in Groovy!</title>
<simpara>No problem. You can write a contract in YAML!</simpara>
</section>
<section xml:id="_what_is_this_value_consumer_producer">
<title>What is this value(consumer(), producer()) ?</title>
<simpara>One of the biggest challenges related to stubs is their reusability. Only if they can be vastly used, will they serve their purpose.
What typically makes that difficult are the hard-coded values of request / response elements. For example dates or ids.
Imagine the following JSON request</simpara>
<programlisting language="json" linenumbering="unnumbered">{
    "time" : "2016-10-10 20:10:15",
    "id" : "9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a",
    "body" : "foo"
}</programlisting>
<simpara>and JSON response</simpara>
<programlisting language="json" linenumbering="unnumbered">{
    "time" : "2016-10-10 21:10:15",
    "id" : "c4231e1f-3ca9-48d3-b7e7-567d55f0d051",
    "body" : "bar"
}</programlisting>
<simpara>Imagine the pain required to set proper value of the <literal>time</literal> field (let&#8217;s assume that this content is generated by the
database) by changing the clock in the system or providing stub implementations of data providers. The same is related
to the field called <literal>id</literal>. Will you create a stubbed implementation of UUID generator? Makes little sense&#8230;&#8203;</simpara>
<simpara>So as a consumer you would like to send a request that matches any form of a time or any UUID. That way your system
will work as usual - will generate data and you won&#8217;t have to stub anything out. Let&#8217;s assume that in case of the aforementioned
JSON the most important part is the <literal>body</literal> field. You can focus on that and provide matching for other fields. In other words
you would like the stub to work like this:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
    "time" : "SOMETHING THAT MATCHES TIME",
    "id" : "SOMETHING THAT MATCHES UUID",
    "body" : "foo"
}</programlisting>
<simpara>As far as the response goes as a consumer you need a concrete value that you can operate on. So such a JSON is valid</simpara>
<programlisting language="json" linenumbering="unnumbered">{
    "time" : "2016-10-10 21:10:15",
    "id" : "c4231e1f-3ca9-48d3-b7e7-567d55f0d051",
    "body" : "bar"
}</programlisting>
<simpara>As you could see in the previous sections we generate tests from contracts. So from the producer&#8217;s side the situation looks
much different. We&#8217;re parsing the provided contract and in the test we want to send a real request to your endpoints.
So for the case of a producer for the request we can&#8217;t have any sort of matching. We need concrete values that the
producer&#8217;s backend can work on. Such a JSON would be a valid one:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
    "time" : "2016-10-10 20:10:15",
    "id" : "9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a",
    "body" : "foo"
}</programlisting>
<simpara>On the other hand from the point of view of the validity of the contract the response doesn&#8217;t necessarily have to
contain concrete values of <literal>time</literal> or <literal>id</literal>. Let&#8217;s say that you generate those on the producer side - again, you&#8217;d
have to do a lot of stubbing to ensure that you always return the same values. That&#8217;s why from the producer&#8217;s side
what you might want is the following response:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
    "time" : "SOMETHING THAT MATCHES TIME",
    "id" : "SOMETHING THAT MATCHES UUID",
    "body" : "bar"
}</programlisting>
<simpara>How can you then provide one time a matcher for the consumer and a concrete value for the producer and vice versa?
In Spring Cloud Contract we&#8217;re allowing you to provide a <emphasis role="strong">dynamic value</emphasis>. That means that it can differ for both
sides of the communication. You can pass the values:</simpara>
<simpara>Either via the <literal>value</literal> method</simpara>
<programlisting language="groovy" linenumbering="unnumbered">value(consumer(...), producer(...))
value(stub(...), test(...))
value(client(...), server(...))</programlisting>
<simpara>or using the <literal>$()</literal> method</simpara>
<programlisting language="groovy" linenumbering="unnumbered">$(consumer(...), producer(...))
$(stub(...), test(...))
$(client(...), server(...))</programlisting>
<simpara>You can read more about this in the <link xl:href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_contract_dsl">Contract DSL section</link>.</simpara>
<simpara>Calling <literal>value()</literal> or <literal>$()</literal> tells Spring Cloud Contract that you will be passing a dynamic value.
Inside the <literal>consumer()</literal> method you pass the value that should be used on the consumer side (in the generated stub).
Inside the <literal>producer()</literal> method you pass the value that should be used on the producer side (in the generated test).</simpara>
<tip>
<simpara>If on one side you have passed the regular expression and you haven&#8217;t passed the other, then the
other side will get auto-generated.</simpara>
</tip>
<simpara>Most often you will use that method together with the <literal>regex</literal> helper method. E.g. <literal>consumer(regex('[0-9]{10}'))</literal>.</simpara>
<simpara>To sum it up the contract for the aforementioned scenario would look more or less like this (the regular expression
for time and UUID are simplified and most likely invalid but we want to keep things very simple in this example):</simpara>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
				request {
					method 'GET'
					url '/someUrl'
					body([
					    time : value(consumer(regex('[0-9]{4}-[0-9]{2}-[0-9]{2} [0-2][0-9]-[0-5][0-9]-[0-5][0-9]')),
					    id: value(consumer(regex('[0-9a-zA-z]{8}-[0-9a-zA-z]{4}-[0-9a-zA-z]{4}-[0-9a-zA-z]{12}'))
					    body: "foo"
					])
				}
			response {
				status 200
				body([
					    time : value(producer(regex('[0-9]{4}-[0-9]{2}-[0-9]{2} [0-2][0-9]-[0-5][0-9]-[0-5][0-9]')),
					    id: value([producer(regex('[0-9a-zA-z]{8}-[0-9a-zA-z]{4}-[0-9a-zA-z]{4}-[0-9a-zA-z]{12}'))
					    body: "bar"
					])
			}
}</programlisting>
<important>
<simpara>Please read the <link xl:href="http://groovy-lang.org/json.html">Groovy docs related to JSON</link> to understand how to
properly structure the request / response bodies.</simpara>
</important>
</section>
<section xml:id="_how_to_do_stubs_versioning">
<title>How to do Stubs versioning?</title>
<section xml:id="_api_versioning">
<title>API Versioning</title>
<simpara>Let&#8217;s try to answer a question what versioning really means. If you&#8217;re referring to the API version then there are
different approaches.</simpara>
<itemizedlist>
<listitem>
<simpara>use Hypermedia, links and do not version your API by any means</simpara>
</listitem>
<listitem>
<simpara>pass versions through headers / urls</simpara>
</listitem>
</itemizedlist>
<simpara>I will not try to answer a question which approach is better. Whatever suit your needs and allows you to generate
business value should be picked.</simpara>
<simpara>Let&#8217;s assume that you do version your API. In that case you should provide as many contracts as many versions you support.
You can create a subfolder for every version or append it to th contract name - whatever suits you more.</simpara>
</section>
<section xml:id="_jar_versioning">
<title>JAR versioning</title>
<simpara>If by versioning you mean the version of the JAR that contains the stubs then there are essentially two main approaches.</simpara>
<simpara>Let&#8217;s assume that you&#8217;re doing Continuous Delivery / Deployment which means that you&#8217;re generating a new version of
the jar each time you go through the pipeline and that jar can go to production at any time. For example your jar version
looks like this (it got built on the 20.10.2016 at 20:15:21) :</simpara>
<programlisting language="groovy" linenumbering="unnumbered">1.0.0.20161020-201521-RELEASE</programlisting>
<simpara>In that case your generated stub jar will look like this.</simpara>
<programlisting language="groovy" linenumbering="unnumbered">1.0.0.20161020-201521-RELEASE-stubs.jar</programlisting>
<simpara>In this case you should inside your <literal>application.yml</literal> or <literal>@AutoConfigureStubRunner</literal> when referencing stubs provide the
 latest version of the stubs. You can do that by passing the <literal>+</literal> sign. Example</simpara>
<programlisting language="java" linenumbering="unnumbered">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:8080"})</programlisting>
<simpara>If the versioning however is fixed (e.g. <literal>1.0.4.RELEASE</literal> or <literal>2.1.1</literal>) then you have to set the concrete value of the jar
version. Example for 2.1.1.</simpara>
<programlisting language="java" linenumbering="unnumbered">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:2.1.1:stubs:8080"})</programlisting>
</section>
<section xml:id="_dev_or_prod_stubs">
<title>Dev or prod stubs</title>
<simpara>You can manipulate the classifier to run the tests against current development version of the stubs of other services
 or the ones that were deployed to production. If you alter your build to deploy the stubs with the <literal>prod-stubs</literal> classifier
 once you reach production deployment then you can run tests in one case with dev stubs and one with prod stubs.</simpara>
<simpara>Example of tests using development version of stubs</simpara>
<programlisting language="java" linenumbering="unnumbered">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:8080"})</programlisting>
<simpara>Example of tests using production version of stubs</simpara>
<programlisting language="java" linenumbering="unnumbered">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:prod-stubs:8080"})</programlisting>
<simpara>You can pass those values also via properties from your deployment pipeline.</simpara>
</section>
</section>
<section xml:id="_common_repo_with_contracts">
<title>Common repo with contracts</title>
<simpara>Another way of storing contracts other than having them with the producer is keeping them in a common place.
It can be related to security issues where the consumers can&#8217;t clone the producer&#8217;s code. Also if you keep
contracts in a single place then you, as a producer, will know how many consumers you have and which
consumer will you break with your local changes.</simpara>
<section xml:id="_repo_structure">
<title>Repo structure</title>
<simpara>Let&#8217;s assume that we have a producer with coordinates <literal>com.example:server</literal> and 3 consumers: <literal>client1</literal>,
<literal>client2</literal>, <literal>client3</literal>. Then in the repository with common contracts you would have the following setup
(which you can checkout <link xl:href="https://github.com/spring-cloud/spring-cloud-contract/tree/1.0.x/samples/standalone/contracts">here</link>:</simpara>
<programlisting language="bash" linenumbering="unnumbered">├── com
│   └── example
│       └── server
│           ├── client1
│           │   └── expectation.groovy
│           ├── client2
│           │   └── expectation.groovy
│           ├── client3
│           │   └── expectation.groovy
│           └── pom.xml
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    └── assembly
        └── contracts.xml</programlisting>
<simpara>As you can see the under the slash-delimited groupid <literal>/</literal> artifact id folder (<literal>com/example/server</literal>) you have
expectations of the 3 consumers (<literal>client1</literal>, <literal>client2</literal> and <literal>client3</literal>). Expectations are the standard Groovy DSL
contract files as described throughout this documentation. This repository has to produce a JAR file that maps
one to one to the contents of the repo.</simpara>
<simpara>Example of a <literal>pom.xml</literal> inside the <literal>server</literal> folder.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

	&lt;groupId&gt;com.example&lt;/groupId&gt;
	&lt;artifactId&gt;server&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

	&lt;name&gt;Server Stubs&lt;/name&gt;
	&lt;description&gt;POM used to install locally stubs for consumer side&lt;/description&gt;

	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.0.0.BUILD-SNAPSHOT&lt;/version&gt;
		&lt;relativePath /&gt;
	&lt;/parent&gt;

	&lt;properties&gt;
		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
		&lt;spring-cloud-contract.version&gt;2.0.0.BUILD-SNAPSHOT&lt;/spring-cloud-contract.version&gt;
		&lt;spring-cloud-dependencies.version&gt;Finchley.BUILD-SNAPSHOT&lt;/spring-cloud-dependencies.version&gt;
		&lt;excludeBuildFolders&gt;true&lt;/excludeBuildFolders&gt;
	&lt;/properties&gt;

	&lt;dependencyManagement&gt;
		&lt;dependencies&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
				&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
				&lt;type&gt;pom&lt;/type&gt;
				&lt;scope&gt;import&lt;/scope&gt;
			&lt;/dependency&gt;
		&lt;/dependencies&gt;
	&lt;/dependencyManagement&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
				&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
				&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
				&lt;extensions&gt;true&lt;/extensions&gt;
				&lt;configuration&gt;
					&lt;!-- By default it would search under src/test/resources/ --&gt;
					&lt;contractsDirectory&gt;${project.basedir}&lt;/contractsDirectory&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

	&lt;repositories&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-releases&lt;/id&gt;
			&lt;name&gt;Spring Releases&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
	&lt;/repositories&gt;
	&lt;pluginRepositories&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-releases&lt;/id&gt;
			&lt;name&gt;Spring Releases&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
	&lt;/pluginRepositories&gt;

&lt;/project&gt;</programlisting>
<simpara>As you can see there are no dependencies other than the Spring Cloud Contract Maven Plugin.
Those poms are necessary for the consumer side to run <literal>mvn clean install -DskipTests</literal> to locally install
 stubs of the producer project.</simpara>
<simpara>The <literal>pom.xml</literal> in the root folder can look like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

	&lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
	&lt;artifactId&gt;contracts&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

	&lt;name&gt;Contracts&lt;/name&gt;
	&lt;description&gt;Contains all the Spring Cloud Contracts, well, contracts. JAR used by the producers to generate tests and stubs&lt;/description&gt;

	&lt;properties&gt;
		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
	&lt;/properties&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
				&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
				&lt;executions&gt;
					&lt;execution&gt;
						&lt;id&gt;contracts&lt;/id&gt;
						&lt;phase&gt;prepare-package&lt;/phase&gt;
						&lt;goals&gt;
							&lt;goal&gt;single&lt;/goal&gt;
						&lt;/goals&gt;
						&lt;configuration&gt;
							&lt;attach&gt;true&lt;/attach&gt;
							&lt;descriptor&gt;${basedir}/src/assembly/contracts.xml&lt;/descriptor&gt;
							&lt;!-- If you want an explicit classifier remove the following line --&gt;
							&lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;
						&lt;/configuration&gt;
					&lt;/execution&gt;
				&lt;/executions&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;</programlisting>
<simpara>It&#8217;s using the assembly plugin in order to build the JAR with all the contracts. Example of such setup is here:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
		  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		  xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd"&gt;
	&lt;id&gt;project&lt;/id&gt;
	&lt;formats&gt;
		&lt;format&gt;jar&lt;/format&gt;
	&lt;/formats&gt;
	&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
	&lt;fileSets&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${project.basedir}&lt;/directory&gt;
			&lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
			&lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
			&lt;excludes&gt;
				&lt;exclude&gt;**/${project.build.directory}/**&lt;/exclude&gt;
				&lt;exclude&gt;mvnw&lt;/exclude&gt;
				&lt;exclude&gt;mvnw.cmd&lt;/exclude&gt;
				&lt;exclude&gt;.mvn/**&lt;/exclude&gt;
				&lt;exclude&gt;src/**&lt;/exclude&gt;
			&lt;/excludes&gt;
		&lt;/fileSet&gt;
	&lt;/fileSets&gt;
&lt;/assembly&gt;</programlisting>
</section>
<section xml:id="_workflow">
<title>Workflow</title>
<simpara>The workflow would look similar to the one presented in the <literal>Step by step guide to CDC</literal>. The only difference
 is that the producer doesn&#8217;t own the contracts anymore. So the consumer and the producer have to work on
 common contracts in a common repository.</simpara>
</section>
<section xml:id="_consumer">
<title>Consumer</title>
<simpara>When the <emphasis role="strong">consumer</emphasis> wants to work on the contracts offline, instead of cloning the producer code, the
consumer team clones the common repository, goes to the required producer&#8217;s folder (e.g. <literal>com/example/server</literal>)
and runs <literal>mvn clean install -DskipTests</literal> to install locally the stubs converted from the contracts.</simpara>
<tip>
<simpara>You need to have <link xl:href="https://maven.apache.org/download.cgi">Maven installed locally</link></simpara>
</tip>
</section>
<section xml:id="_producer">
<title>Producer</title>
<simpara>As a <emphasis role="strong">producer</emphasis> it&#8217;s enough to alter the Spring Cloud Contract Verifier to provide the URL and the dependency
of the JAR containing the contracts:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;configuration&gt;
		&lt;stubsMode&gt;REMOTE&lt;/stubsMode&gt;
		&lt;contractsRepositoryUrl&gt;http://link/to/your/nexus/or/artifactory/or/sth&lt;/contractsRepositoryUrl&gt;
		&lt;contractDependency&gt;
			&lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
			&lt;artifactId&gt;contracts&lt;/artifactId&gt;
		&lt;/contractDependency&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
<simpara>With this setup the JAR with groupid <literal>com.example.standalone</literal> and artifactid <literal>contracts</literal> will be downloaded
from <literal><link xl:href="http://link/to/your/nexus/or/artifactory/or/sth">http://link/to/your/nexus/or/artifactory/or/sth</link></literal>. It will be then unpacked in a local temporary folder
and contracts present under the <literal>com/example/server</literal> will be picked as the ones used to generate the
tests and the stubs. Due to this convention the producer team will know which consumer teams will be broken
when some incompatible changes are done.</simpara>
<simpara>The rest of the flow looks the same.</simpara>
</section>
</section>
<section xml:id="_can_i_have_multiple_base_classes_for_tests">
<title>Can I have multiple base classes for tests?</title>
<simpara>Yes! Check out the <link xl:href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_different_base_classes_for_contracts">Different base classes for contracts</link> sections
of either Gradle or Maven plugins.</simpara>
</section>
<section xml:id="_how_can_i_debug_the_request_response_being_sent_by_the_generated_tests_client">
<title>How can I debug the request/response being sent by the generated tests client?</title>
<simpara>The generated tests all boil down to RestAssured in some form or fashion which relies on <link xl:href="https://hc.apache.org/httpcomponents-client-ga/">Apache HttpClient</link>.  HttpClient has a facility called <link xl:href="https://hc.apache.org/httpcomponents-client-ga/logging.html#Wire_Logging">wire logging</link> which logs the entire request and response to HttpClient.  Spring Boot has a logging <link xl:href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">common application property</link> for doing this sort of thing, just add this to your application properties</simpara>
<programlisting language="properties" linenumbering="unnumbered">logging.level.org.apache.http.wire=DEBUG</programlisting>
<section xml:id="_how_can_i_debug_the_mapping_request_response_being_sent_by_wiremock">
<title>How can I debug the mapping/request/response being sent by WireMock?</title>
<simpara>Starting from version <literal>1.2.0</literal> we turn on WireMock logging to
info and the WireMock notifier to being verbose. Now you will
exactly know what request was received by WireMock server and which
matching response definition was picked.</simpara>
<simpara>To turn off this feature just bump WireMock logging to <literal>ERROR</literal></simpara>
<programlisting language="properties" linenumbering="unnumbered">logging.level.com.github.tomakehurst.wiremock=ERROR</programlisting>
</section>
<section xml:id="_how_can_i_see_what_got_registered_in_the_http_server_stub">
<title>How can I see what got registered in the HTTP server stub?</title>
<simpara>You can use the <literal>mappingsOutputFolder</literal> property on <literal>@AutoConfigureStubRunner</literal> or <literal>StubRunnerRule</literal>
to dump all mappings per artifact id. Also the port at which the given stub server was
started will be attached.</simpara>
</section>
<section xml:id="_can_i_reference_the_request_from_the_response">
<title>Can I reference the request from the response?</title>
<simpara>Yes! With version 1.1.0 we&#8217;ve added such a possibility. On the HTTP stub server side we&#8217;re providing support
for this for WireMock. In case of other HTTP server stubs you&#8217;ll have to implement the approach yourself.</simpara>
</section>
<section xml:id="_can_i_reference_text_from_file">
<title>Can I reference text from file?</title>
<simpara>Yes! With version 1.2.0 we&#8217;ve added such a possibility. It&#8217;s enough to call <literal>file(&#8230;&#8203;)</literal> method in the
DSL and provide a path relative to where the contract lays.
If you&#8217;re using YAML just use the <literal>bodyFromFile</literal> property.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="_spring_cloud_contract_verifier_setup">
<title>Spring Cloud Contract Verifier Setup</title>
<simpara>You can set up Spring Cloud Contract Verifier in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="gradle-project">As a Gradle project</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="maven-project">As a Maven project</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="docker-project">As a Docker project</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="gradle-project">
<title>Gradle Project</title>
<simpara>To learn how to set up the Gradle project for Spring Cloud Contract Verifier, read the
following sections:</simpara>
<itemizedlist>
<listitem>
<simpara><xref linkend="gradle-prerequisites"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="gradle-add-gradle-plugin"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="gradle-and-rest-assured"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="gradle-snapshot-versions"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="gradle-add-stubs"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="gradle-default-setup"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="gradle-configure-plugin"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="gradle-configuration-options"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="gradle-single-base-class"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="gradle-different-base-classes"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="gradle-invoking-generated-tests"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="gradle-consumer"/></simpara>
</listitem>
</itemizedlist>
<section xml:id="gradle-prerequisites">
<title>Prerequisites</title>
<simpara>In order to use Spring Cloud Contract Verifier with WireMock, you muse use either a
Gradle or a Maven plugin.</simpara>
<warning>
<simpara>If you want to use Spock in your projects, you must add separately the
<literal>spock-core</literal> and <literal>spock-spring</literal> modules. Check <link xl:href="https://spockframework.github.io/">Spock
docs for more information</link></simpara>
</warning>
</section>
<section xml:id="gradle-add-gradle-plugin">
<title>Add Gradle Plugin with Dependencies</title>
<simpara>To add a Gradle plugin with dependencies, use code similar to this:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
	    classpath "org.springframework.boot:spring-boot-gradle-plugin:${springboot_version}"
		classpath "org.springframework.cloud:spring-cloud-contract-gradle-plugin:${verifier_version}"
	}
}

apply plugin: 'groovy'
apply plugin: 'spring-cloud-contract'

dependencyManagement {
	imports {
		mavenBom "org.springframework.cloud:spring-cloud-contract-dependencies:${verifier_version}"
	}
}

dependencies {
	testCompile 'org.codehaus.groovy:groovy-all:2.4.6'
	// example with adding Spock core and Spock Spring
	testCompile 'org.spockframework:spock-core:1.0-groovy-2.4'
	testCompile 'org.spockframework:spock-spring:1.0-groovy-2.4'
	testCompile 'org.springframework.cloud:spring-cloud-starter-contract-verifier'
}</programlisting>
</section>
<section xml:id="gradle-and-rest-assured">
<title>Gradle and Rest Assured 2.0</title>
<simpara>By default, Rest Assured 3.x is added to the classpath. However, to use Rest Assured 2.x
you can add it to the plugins classpath, as shown here:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
	    classpath "org.springframework.boot:spring-boot-gradle-plugin:${springboot_version}"
		classpath "org.springframework.cloud:spring-cloud-contract-gradle-plugin:${verifier_version}"
		classpath "com.jayway.restassured:rest-assured:2.5.0"
		classpath "com.jayway.restassured:spring-mock-mvc:2.5.0"
	}
}

depenendencies {
    // all dependencies
    // you can exclude rest-assured from spring-cloud-contract-verifier
    testCompile "com.jayway.restassured:rest-assured:2.5.0"
    testCompile "com.jayway.restassured:spring-mock-mvc:2.5.0"
}</programlisting>
<simpara>That way, the plugin automatically sees that Rest Assured 2.x is present on the classpath
and modifies the imports accordingly.</simpara>
</section>
<section xml:id="gradle-snapshot-versions">
<title>Snapshot Versions for Gradle</title>
<simpara>Add the additional snapshot repository to your build.gradle to use snapshot versions,
which are automatically uploaded after every successful build, as shown here:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">buildscript {
	repositories {
		mavenCentral()
		mavenLocal()
		maven { url "https://repo.spring.io/snapshot" }
		maven { url "https://repo.spring.io/milestone" }
		maven { url "https://repo.spring.io/release" }
	}
}</programlisting>
</section>
<section xml:id="gradle-add-stubs">
<title>Add stubs</title>
<simpara>By default, Spring Cloud Contract Verifier is looking for stubs in the
<literal>src/test/resources/contracts</literal> directory.</simpara>
<simpara>The directory containing stub definitions is treated as a class name, and each stub
definition is treated as a single test. Spring Cloud Contract Verifier assumes that it
contains at  least one level of directories that are to be used as the test class name.
If more than  one level of nested directories is present, all except the last one is used
as the package name. For example, with following structure:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">src/test/resources/contracts/myservice/shouldCreateUser.groovy
src/test/resources/contracts/myservice/shouldReturnUser.groovy</programlisting>
<simpara>Spring Cloud Contract Verifier creates a test class named <literal>defaultBasePackage.MyService</literal>
with two methods:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>shouldCreateUser()</literal></simpara>
</listitem>
<listitem>
<simpara><literal>shouldReturnUser()</literal></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="gradle-run-plugin">
<title>Run the Plugin</title>
<simpara>The plugin registers itself to be invoked before a <literal>check</literal> task. If you want it to be
part of your build process, you need to do nothing more. If you just want to generate
tests, invoke the <literal>generateContractTests</literal> task.</simpara>
</section>
<section xml:id="gradle-default-setup">
<title>Default Setup</title>
<simpara>The default Gradle Plugin setup creates the following Gradle part of the build (in
pseudocode):</simpara>
<programlisting language="groovy" linenumbering="unnumbered">contracts {
    targetFramework = 'JUNIT'
    testMode = 'MockMvc'
    generatedTestSourcesDir = project.file("${project.buildDir}/generated-test-sources/contracts")
    contractsDslDir = "${project.rootDir}/src/test/resources/contracts"
    basePackageForTests = 'org.springframework.cloud.verifier.tests'
    stubsOutputDir = project.file("${project.buildDir}/stubs")

    // the following properties are used when you want to provide where the JAR with contract lays
    contractDependency {
        stringNotation = ''
    }
    contractsPath = ''
    contractsWorkOffline = false
    contractRepository {
        cacheDownloadedContracts(true)
    }
}

tasks.create(type: Jar, name: 'verifierStubsJar', dependsOn: 'generateClientStubs') {
    baseName = project.name
    classifier = contracts.stubsSuffix
    from contractVerifier.stubsOutputDir
}

project.artifacts {
    archives task
}

tasks.create(type: Copy, name: 'copyContracts') {
    from contracts.contractsDslDir
    into contracts.stubsOutputDir
}

verifierStubsJar.dependsOn 'copyContracts'

publishing {
    publications {
        stubs(MavenPublication) {
            artifactId project.name
            artifact verifierStubsJar
        }
    }
}</programlisting>
</section>
<section xml:id="gradle-configure-plugin">
<title>Configure Plugin</title>
<simpara>To change the default configuration, add a <literal>contracts</literal> snippet to your Gradle config, as
shown here:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">contracts {
	testMode = 'MockMvc'
	baseClassForTests = 'org.mycompany.tests'
	generatedTestSourcesDir = project.file('src/generatedContract')
}</programlisting>
</section>
<section xml:id="gradle-configuration-options">
<title>Configuration Options</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">testMode</emphasis>: Defines the mode for acceptance tests. By default, the mode is MockMvc,
which is based on Spring&#8217;s MockMvc. It can also be changed to <emphasis role="strong">JaxRsClient</emphasis> or to
<emphasis role="strong">Explicit</emphasis> for real HTTP calls.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">imports</emphasis>: Creates an array with imports that should be included in generated tests
(for example ['org.myorg.Matchers']). By default, it creates an empty array.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">staticImports</emphasis>: Creates an array with static imports that should be included in
generated tests(for example ['org.myorg.Matchers.*']). By default, it creates an empty
array.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">basePackageForTests</emphasis>: Specifies the base package for all generated tests. If not set,
the value is picked from <literal>baseClassForTests&#8217;s package and from `packageWithBaseClasses</literal>.
If neither of these values are set, then the value is set to
<literal>org.springframework.cloud.contract.verifier.tests</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">baseClassForTests</emphasis>: Creates a base class for all generated tests. By default, if you
use Spock classes, the class is <literal>spock.lang.Specification</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">packageWithBaseClasses</emphasis>: Defines a package where all the base classes reside. This
setting takes precedence over <emphasis role="strong">baseClassForTests</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">baseClassMappings</emphasis>: Explicitly maps a contract package to a FQN of a base class. This
setting takes precedence over <emphasis role="strong">packageWithBaseClasses</emphasis> and <emphasis role="strong">baseClassForTests</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">ruleClassForTests</emphasis>: Specifies a rule that should be added to the generated test
classes.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">ignoredFiles</emphasis>: Uses an <literal>Antmatcher</literal> to allow defining stub files for which processing
should be skipped. By default, it is an empty array.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">contractsDslDir</emphasis>: Specifies the directory containing contracts written using the
GroovyDSL. By default, its value is <literal>$rootDir/src/test/resources/contracts</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">generatedTestSourcesDir</emphasis>: Specifies the test source directory where tests generated
from the Groovy DSL should be placed. By default its value is
<literal>$buildDir/generated-test-sources/contractVerifier</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">stubsOutputDir</emphasis>: Specifies the directory where the generated WireMock stubs from
the Groovy DSL should be placed.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">targetFramework</emphasis>: Specifies the target test framework to be used. Currently, Spock and
JUnit are supported with JUnit being the default framework.</simpara>
</listitem>
</itemizedlist>
<simpara>The following properties are used when you want to specify the location of the JAR
containing the contracts:
* <emphasis role="strong">contractDependency</emphasis>: Specifies the Dependency that provides
<literal>groupid:artifactid:version:classifier</literal> coordinates. You can use the <literal>contractDependency</literal>
closure to set it up.
* <emphasis role="strong">contractsPath</emphasis>: Specifies the path to the jar. If contract dependencies are
 downloaded, the path defaults to <literal>groupid/artifactid</literal> where <literal>groupid</literal> is slash
 separated. Otherwise, it scans contracts under the provided directory.
* <emphasis role="strong">contractsWorkOffline</emphasis>: Specifies whether to download the dependencies each time, so
that you can work online. In other words, it specifies whether to reuses the local Maven
repo.</simpara>
</section>
<section xml:id="gradle-single-base-class">
<title>Single Base Class for All Tests</title>
<simpara>When using Spring Cloud Contract Verifier in default MockMvc, you need to create a base
specification for all generated acceptance tests. In this class, you need to point to an
endpoint, which should be verified.</simpara>
<programlisting language="groovy" linenumbering="unnumbered">abstract class BaseMockMvcSpec extends Specification {

	def setup() {
		RestAssuredMockMvc.standaloneSetup(new PairIdController())
	}

	void isProperCorrelationId(Integer correlationId) {
		assert correlationId == 123456
	}

	void isEmpty(String value) {
		assert value == null
	}

}</programlisting>
<simpara>If you use <literal>Explicit</literal> mode, you can use a base class to initialize the whole tested app
as you might see in regular integration tests. If you use the <literal>JAXRSCLIENT</literal> mode, this
base class should also contain a <literal>protected WebTarget webTarget</literal> field. Right now, the
only option to test the JAX-RS API is to start a web server.</simpara>
</section>
<section xml:id="gradle-different-base-classes">
<title>Different Base Classes for Contracts</title>
<simpara>If your base classes differ between contracts, you can tell the Spring Cloud Contract
plugin which class should get extended by the autogenerated tests. You have two options:</simpara>
<itemizedlist>
<listitem>
<simpara>Follow a convention by providing the <literal>packageWithBaseClasses</literal></simpara>
</listitem>
<listitem>
<simpara>Provide explicit mapping via <literal>baseClassMappings</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">By Convention</emphasis></simpara>
<simpara>The convention is such that if you have a contract under (for example)
<literal>src/test/resources/contract/foo/bar/baz/</literal> and set the value of the
<literal>packageWithBaseClasses</literal> property to <literal>com.example.base</literal>, then Spring Cloud Contract
Verifier assumes that there is a <literal>BarBazBase</literal> class under the <literal>com.example.base</literal> package.
In other words, the system takes the last two parts of the package, if they exist, and
forms a class with a <literal>Base</literal> suffix. This rule takes precedence over <emphasis role="strong">baseClassForTests</emphasis>.
Here is an example of how it works in the <literal>contracts</literal> closure:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">packageWithBaseClasses = 'com.example.base'</programlisting>
<simpara><emphasis role="strong">By Mapping</emphasis></simpara>
<simpara>You can manually map a regular expression of the contract&#8217;s package to fully qualified
name of the base class for the matched contract. You have to provide a list called
<literal>baseClassMappings</literal> that consists <literal>baseClassMapping</literal> objects that takes a
<literal>contractPackageRegex</literal> to <literal>baseClassFQN</literal> mapping. Consider the following example:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">baseClassForTests = "com.example.FooBase"
baseClassMappings {
	baseClassMapping('.*/com/.*', 'com.example.ComBase')
	baseClassMapping('.*/bar/.*':'com.example.BarBase')
}</programlisting>
<simpara>Let&#8217;s assume that you have contracts under
 - <literal>src/test/resources/contract/com/</literal>
 - <literal>src/test/resources/contract/foo/</literal></simpara>
<simpara>By providing the <literal>baseClassForTests</literal>, we have a fallback in case mapping did not succeed.
(You could also provide the <literal>packageWithBaseClasses</literal> as a fallback.) That way, the tests
generated from <literal>src/test/resources/contract/com/</literal> contracts extend the
<literal>com.example.ComBase</literal>, whereas the rest of the tests extend <literal>com.example.FooBase</literal>.</simpara>
</section>
<section xml:id="gradle-invoking-generated-tests">
<title>Invoking Generated Tests</title>
<simpara>To ensure that the provider side is compliant with defined contracts, you need to invoke:</simpara>
<programlisting language="bash" linenumbering="unnumbered">./gradlew generateContractTests test</programlisting>
</section>
<section xml:id="gradle-consumer">
<title>Spring Cloud Contract Verifier on the Consumer Side</title>
<simpara>In a consuming service, you need to configure the Spring Cloud Contract Verifier plugin
in exactly the same way as in case of provider. If you do not want to use Stub Runner
then you need to copy contracts stored in <literal>src/test/resources/contracts</literal> and generate
WireMock JSON stubs using:</simpara>
<programlisting language="bash" linenumbering="unnumbered">./gradlew generateClientStubs</programlisting>
<note>
<simpara>The <literal>stubsOutputDir</literal> option has to be set for stub generation to work.</simpara>
</note>
<simpara>When present, JSON stubs can be used in automated tests of consuming a service.</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@ContextConfiguration(loader == SpringApplicationContextLoader, classes == Application)
class LoanApplicationServiceSpec extends Specification {

 @ClassRule
 @Shared
 WireMockClassRule wireMockRule == new WireMockClassRule()

 @Autowired
 LoanApplicationService sut

 def 'should successfully apply for loan'() {
   given:
 	LoanApplication application =
			new LoanApplication(client: new Client(clientPesel: '12345678901'), amount: 123.123)
   when:
	LoanApplicationResult loanApplication == sut.loanApplication(application)
   then:
	loanApplication.loanApplicationStatus == LoanApplicationStatus.LOAN_APPLIED
	loanApplication.rejectionReason == null
 }
}</programlisting>
<simpara><literal>LoanApplication</literal> makes a call to <literal>FraudDetection</literal> service. This request is handled by a
WireMock server configured with stubs generated by Spring Cloud Contract Verifier.</simpara>
</section>
</section>
<section xml:id="maven-project">
<title>Maven Project</title>
<simpara>To learn how to set up the Maven project for Spring Cloud Contract Verifier, read the
following sections:</simpara>
<itemizedlist>
<listitem>
<simpara><xref linkend="maven-add-plugin"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="maven-rest-assured"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="maven-snapshot-versions"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="maven-add-stubs"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="maven-run-plugin"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="maven-configure-plugin"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="maven-configuration-options"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="maven-single-base"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="maven-different-base"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="maven-invoking-generated-tests"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="maven-sts"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="maven-consumer"/></simpara>
</listitem>
</itemizedlist>
<section xml:id="maven-add-plugin">
<title>Add maven plugin</title>
<simpara>Add the Spring Cloud Contract BOM in a fashion similar to this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</programlisting>
<simpara>Next, add the <literal>Spring Cloud Contract Verifier</literal> Maven plugin:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
<simpara>You can read more in the
<link xl:href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/">Spring
Cloud Contract Maven Plugin Documentation</link>.</simpara>
</section>
<section xml:id="maven-rest-assured">
<title>Maven and Rest Assured 2.0</title>
<simpara>By default, Rest Assured 3.x is added to the classpath. However, you can use Rest
Assured 2.x by adding it to the plugins classpath, as shown here:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
    &lt;configuration&gt;
        &lt;packageWithBaseClasses&gt;com.example&lt;/packageWithBaseClasses&gt;
    &lt;/configuration&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-contract-verifier&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
           &lt;groupId&gt;com.jayway.restassured&lt;/groupId&gt;
           &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;
           &lt;version&gt;2.5.0&lt;/version&gt;
           &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
           &lt;groupId&gt;com.jayway.restassured&lt;/groupId&gt;
           &lt;artifactId&gt;spring-mock-mvc&lt;/artifactId&gt;
           &lt;version&gt;2.5.0&lt;/version&gt;
           &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;

&lt;dependencies&gt;
    &lt;!-- all dependencies --&gt;
    &lt;!-- you can exclude rest-assured from spring-cloud-contract-verifier --&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;com.jayway.restassured&lt;/groupId&gt;
       &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;
       &lt;version&gt;2.5.0&lt;/version&gt;
       &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;com.jayway.restassured&lt;/groupId&gt;
       &lt;artifactId&gt;spring-mock-mvc&lt;/artifactId&gt;
       &lt;version&gt;2.5.0&lt;/version&gt;
       &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
<simpara>That way, the plugin automatically sees that Rest Assured 3.x is present on the classpath
and modifies the imports accordingly.</simpara>
</section>
<section xml:id="maven-snapshot-versions">
<title>Snapshot versions for Maven</title>
<simpara>For Snapshot and Milestone versions, you have to add the following section to your
<literal>pom.xml</literal>, as shown here:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</programlisting>
</section>
<section xml:id="maven-add-stubs">
<title>Add stubs</title>
<simpara>By default, Spring Cloud Contract Verifier is looking for stubs in the
<literal>src/test/resources/contracts</literal> directory. The directory containing stub definitions is
treated as a class name, and each stub definition is treated as a single test. We assume
that it contains at least one directory to be used as test class name. If there is more
than one level of nested directories, all except the last one is used as package name.
For example, with following structure:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">src/test/resources/contracts/myservice/shouldCreateUser.groovy
src/test/resources/contracts/myservice/shouldReturnUser.groovy</programlisting>
<simpara>Spring Cloud Contract Verifier creates a test class named <literal>defaultBasePackage.MyService</literal>
with two methods</simpara>
<itemizedlist>
<listitem>
<simpara><literal>shouldCreateUser()</literal></simpara>
</listitem>
<listitem>
<simpara><literal>shouldReturnUser()</literal></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="maven-run-plugin">
<title>Run plugin</title>
<simpara>The plugin goal <literal>generateTests</literal> is assigned to be invoked in the phase called
<literal>generate-test-sources</literal>. If you want it to be part of your build process, you need not do
anything. If you just want to generate tests, invoke the <literal>generateTests</literal> goal.</simpara>
</section>
<section xml:id="maven-configure-plugin">
<title>Configure plugin</title>
<simpara>To change the default configuration, just add a <literal>configuration</literal> section to the plugin
definition or the <literal>execution</literal> definition, as shown here:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;convert&lt;/goal&gt;
                &lt;goal&gt;generateStubs&lt;/goal&gt;
                &lt;goal&gt;generateTests&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;basePackageForTests&gt;org.springframework.cloud.verifier.twitter.place&lt;/basePackageForTests&gt;
        &lt;baseClassForTests&gt;org.springframework.cloud.verifier.twitter.place.BaseMockMvcSpec&lt;/baseClassForTests&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
</section>
<section xml:id="maven-configuration-options">
<title>Configuration Options</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">testMode</emphasis>: Defines the mode for acceptance tests. By default, the mode is MockMvc,
which is based on Spring&#8217;s MockMvc. It can also be changed to <emphasis role="strong">JaxRsClient</emphasis> or to
<emphasis role="strong">Explicit</emphasis> for real HTTP calls.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">basePackageForTests</emphasis>: Specifies the base package for all generated tests. If not set,
the value is picked from <literal>baseClassForTests&#8217;s package and from `packageWithBaseClasses</literal>.
If neither of these values are set, then the value is set to
<literal>org.springframework.cloud.contract.verifier.tests</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">ruleClassForTests</emphasis>: Specifies a rule that should be added to the generated test
classes.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">baseClassForTests</emphasis>: Creates a base class for all generated tests. By default, if you
use Spock classes, the class is <literal>spock.lang.Specification</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">contractsDirectory</emphasis>: Specifies a directory containing contracts written with the
GroovyDSL. The default directory is <literal>/src/test/resources/contracts</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">testFramework</emphasis>: Specifies the target test framework to be used. Currently, Spock and
JUnit are supported with JUnit being the default framework</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">packageWithBaseClasses</emphasis>: Defines a package where all the base classes reside. This
setting takes precedence over <emphasis role="strong">baseClassForTests</emphasis>. The convention is such that, if you
have a contract under (for example) <literal>src/test/resources/contract/foo/bar/baz/</literal> and set
the value of the <literal>packageWithBaseClasses</literal> property to <literal>com.example.base</literal>, then Spring
Cloud Contract Verifier assumes that there is a <literal>BarBazBase</literal> class under the
<literal>com.example.base</literal> package. In other words, the system takes the last two parts of the
package, if they exist, and forms a class with a <literal>Base</literal> suffix.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">baseClassMappings</emphasis>: Specifies a list of base class mappings that provide
<literal>contractPackageRegex</literal>, which is checked against the package where the contract is
located, and <literal>baseClassFQN</literal>, which maps to the fully qualified name of the base class for
the matched contract. For example, if you have a contract under
<literal>src/test/resources/contract/foo/bar/baz/</literal> and map the property
<literal>.* &#8594; com.example.base.BaseClass</literal>, then the test class generated from these contracts
extends <literal>com.example.base.BaseClass</literal>. This setting takes precedence over
<emphasis role="strong">packageWithBaseClasses</emphasis> and <emphasis role="strong">baseClassForTests</emphasis>.</simpara>
</listitem>
</itemizedlist>
<simpara>If you want to download your contract definitions from a Maven repository, you can use
the following options:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">contractDependency</emphasis>: The contract dependency that contains all the packaged contracts.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">contractsPath</emphasis>: The path to the concrete contracts in the JAR with packaged contracts.
Defaults to <literal>groupid/artifactid</literal> where <literal>gropuid</literal> is slash separated.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">contractsWorkOffline</emphasis>: Dictates whether the dependencies should be downloaded or the
local Maven artifacts should be reused.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">contractsRepositoryUrl</emphasis>: URL to a repo with the artifacts that have contracts. If it is not provided,
use the current Maven ones.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">contractsRepositoryUsername</emphasis>: The user name to be used to connect to the repo with contracts.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">contractsRepositoryPassword</emphasis>: The password to be used to connect to the repo with contracts.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">contractsRepositoryProxyHost</emphasis>: The proxy host to be used to connect to the repo with contracts.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">contractsRepositoryProxyPort</emphasis>: The proxy port to be used to connect to the repo with contracts.</simpara>
</listitem>
</itemizedlist>
<simpara>We cache only non-snapshot, explicitly provided versions (for example
<literal>+</literal> or <literal>1.0.0.BUILD-SNAPSHOT</literal> won&#8217;t get cached). By default, this feature is turned on.</simpara>
</section>
<section xml:id="maven-single-base">
<title>Single Base Class for All Tests</title>
<simpara>When using Spring Cloud Contract Verifier in default MockMvc, you need to create a base
specification for all generated acceptance tests. In this class, you need to point to an
endpoint, which should be verified.</simpara>
<programlisting language="groovy" linenumbering="unnumbered">package org.mycompany.tests

import org.mycompany.ExampleSpringController
import com.jayway.restassured.module.mockmvc.RestAssuredMockMvc
import spock.lang.Specification

class  MvcSpec extends Specification {
  def setup() {
   RestAssuredMockMvc.standaloneSetup(new ExampleSpringController())
  }
}</programlisting>
<simpara>If you use <literal>Explicit</literal> mode, you can use a base class to initialize the whole tested app
similarly, as you might find in regular integration tests. If you use the <literal>JAXRSCLIENT</literal>
mode, this base class should also contain a <literal>protected WebTarget webTarget</literal> field. Right
now, the only option to test the JAX-RS API is to start a web server.</simpara>
</section>
<section xml:id="maven-different-base">
<title>Different base classes for contracts</title>
<simpara>If your base classes differ between contracts, you can tell the Spring Cloud Contract
plugin which class should get extended by the autogenerated tests. You have two options:</simpara>
<itemizedlist>
<listitem>
<simpara>Follow a convention by providing the <literal>packageWithBaseClasses</literal></simpara>
</listitem>
<listitem>
<simpara>provide explicit mapping via <literal>baseClassMappings</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">By Convention</emphasis></simpara>
<simpara>The convention is such that if you have a contract under (for example)
<literal>src/test/resources/contract/foo/bar/baz/</literal> and set the value of the
<literal>packageWithBaseClasses</literal> property to <literal>com.example.base</literal>, then Spring Cloud Contract
Verifier assumes that there is a <literal>BarBazBase</literal> class under the <literal>com.example.base</literal> package.
In other words, the system takes the last two parts of the package, if they exist, and
forms a class with a <literal>Base</literal> suffix. This rule takes precedence over <emphasis role="strong">baseClassForTests</emphasis>.
Here is an example of how it works in the <literal>contracts</literal> closure:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;hello&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
<simpara><emphasis role="strong">By Mapping</emphasis></simpara>
<simpara>You can manually map a regular expression of the contract&#8217;s package to fully qualified
name of the base class for the matched contract. You have to provide a list called
<literal>baseClassMappings</literal> that consists <literal>baseClassMapping</literal> objects that takes a
<literal>contractPackageRegex</literal> to <literal>baseClassFQN</literal> mapping. Consider the following example:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;configuration&gt;
		&lt;baseClassForTests&gt;com.example.FooBase&lt;/baseClassForTests&gt;
		&lt;baseClassMappings&gt;
			&lt;baseClassMapping&gt;
				&lt;contractPackageRegex&gt;.*com.*&lt;/contractPackageRegex&gt;
				&lt;baseClassFQN&gt;com.example.TestBase&lt;/baseClassFQN&gt;
			&lt;/baseClassMapping&gt;
		&lt;/baseClassMappings&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
<simpara>Assume that you have contracts under these two locations:
* <literal>src/test/resources/contract/com/</literal>
* <literal>src/test/resources/contract/foo/</literal></simpara>
<simpara>By providing the <literal>baseClassForTests</literal>, we have a fallback in case mapping did not succeed.
(You can also provide the <literal>packageWithBaseClasses</literal> as a fallback.) That way, the tests
generated from <literal>src/test/resources/contract/com/</literal> contracts extend the
<literal>com.example.ComBase</literal>, whereas the rest of the tests extend <literal>com.example.FooBase</literal>.</simpara>
</section>
<section xml:id="maven-invoking-generated-tests">
<title>Invoking generated tests</title>
<simpara>The Spring Cloud Contract Maven Plugin generates verification code in a directory called
<literal>/generated-test-sources/contractVerifier</literal> and attaches this directory to <literal>testCompile</literal>
goal.</simpara>
<simpara>For Groovy Spock code, use the following:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
	&lt;groupId&gt;org.codehaus.gmavenplus&lt;/groupId&gt;
	&lt;artifactId&gt;gmavenplus-plugin&lt;/artifactId&gt;
	&lt;version&gt;1.5&lt;/version&gt;
	&lt;executions&gt;
		&lt;execution&gt;
			&lt;goals&gt;
				&lt;goal&gt;testCompile&lt;/goal&gt;
			&lt;/goals&gt;
		&lt;/execution&gt;
	&lt;/executions&gt;
	&lt;configuration&gt;
		&lt;testSources&gt;
			&lt;testSource&gt;
				&lt;directory&gt;${project.basedir}/src/test/groovy&lt;/directory&gt;
				&lt;includes&gt;
					&lt;include&gt;**/*.groovy&lt;/include&gt;
				&lt;/includes&gt;
			&lt;/testSource&gt;
			&lt;testSource&gt;
				&lt;directory&gt;${project.build.directory}/generated-test-sources/contractVerifier&lt;/directory&gt;
				&lt;includes&gt;
					&lt;include&gt;**/*.groovy&lt;/include&gt;
				&lt;/includes&gt;
			&lt;/testSource&gt;
		&lt;/testSources&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
<simpara>To ensure that provider side is compliant with defined contracts, you need to invoke
<literal>mvn generateTest test</literal>.</simpara>
</section>
<section xml:id="maven-sts">
<title>Maven Plugin and STS</title>
<simpara>If you see the following exception while using STS:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="https://raw.githubusercontent.com/spring-cloud/spring-cloud-contract/master/docs/src/main/asciidoc/images/sts_exception.png"/>
</imageobject>
<textobject><phrase>STS Exception</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>When you click on the error marker you should see something like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered"> plugin:1.1.0.M1:convert:default-convert:process-test-resources) org.apache.maven.plugin.PluginExecutionException: Execution default-convert of goal org.springframework.cloud:spring-
 cloud-contract-maven-plugin:1.1.0.M1:convert failed. at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:145) at
 org.eclipse.m2e.core.internal.embedder.MavenImpl.execute(MavenImpl.java:331) at org.eclipse.m2e.core.internal.embedder.MavenImpl$11.call(MavenImpl.java:1362) at
...
 org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) Caused by: java.lang.NullPointerException at
 org.eclipse.m2e.core.internal.builder.plexusbuildapi.EclipseIncrementalBuildContext.hasDelta(EclipseIncrementalBuildContext.java:53) at
 org.sonatype.plexus.build.incremental.ThreadBuildContext.hasDelta(ThreadBuildContext.java:59) at</programlisting>
<simpara>In order to fix this issue, provide the following section in your <literal>pom.xml</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;build&gt;
    &lt;pluginManagement&gt;
        &lt;plugins&gt;
            &lt;!--This plugin's configuration is used to store Eclipse m2e settings
                only. It has no influence on the Maven build itself. --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.eclipse.m2e&lt;/groupId&gt;
                &lt;artifactId&gt;lifecycle-mapping&lt;/artifactId&gt;
                &lt;version&gt;1.0.0&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;lifecycleMappingMetadata&gt;
                        &lt;pluginExecutions&gt;
                             &lt;pluginExecution&gt;
                                &lt;pluginExecutionFilter&gt;
                                    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                                    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
                                    &lt;versionRange&gt;[1.0,)&lt;/versionRange&gt;
                                    &lt;goals&gt;
                                        &lt;goal&gt;convert&lt;/goal&gt;
                                    &lt;/goals&gt;
                                &lt;/pluginExecutionFilter&gt;
                                &lt;action&gt;
                                    &lt;execute /&gt;
                                &lt;/action&gt;
                             &lt;/pluginExecution&gt;
                        &lt;/pluginExecutions&gt;
                    &lt;/lifecycleMappingMetadata&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
&lt;/build&gt;</programlisting>
</section>
<section xml:id="maven-consumer">
<title>Spring Cloud Contract Verifier on the Consumer Side</title>
<simpara>You can also use the Spring Cloud Contract Verifier for the consumer side. To do so, use
the plugin so that it only converts the contracts and generates the stubs. To achieve
that, you need to configure Spring Cloud Contract Verifier plugin in exactly the same way
as you would for a provider. You need to copy contracts stored in
<literal>src/test/resources/contracts</literal> and generate WireMock JSON stubs using the
<literal>mvn generateStubs</literal> command. By default, the generated WireMock mapping is stored in a
directory named <literal>target/mappings</literal>. From these generated mappings, your project should
create additional artifacts with a classifier of <literal>stubs</literal> for easy deployment to the maven
repository.</simpara>
<simpara>Here is a sample configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${verifier-plugin.version}&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;convert&lt;/goal&gt;
                &lt;goal&gt;generateStubs&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</programlisting>
<simpara>When present, JSON stubs can be used in consumer automated tests, as shown here:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@RunWith(SpringTestRunner.class)
@SpringBootTest
@AutoConfigureStubRunner
public class LoanApplicationServiceTests {

  @Autowired
  LoanApplicationService service;

  @Test
  public void shouldSuccessfullyApplyForLoan() {
    //given:
 	LoanApplication application =
			new LoanApplication(new Client("12345678901"), 123.123);
    //when:
	LoanApplicationResult loanApplication = service.loanApplication(application);
    // then:
	assertThat(loanApplication.loanApplicationStatus).isEqualTo(LoanApplicationStatus.LOAN_APPLIED);
	assertThat(loanApplication.rejectionReason).isNull();
  }
}</programlisting>
<simpara><literal>LoanApplication</literal> makes a call to the <literal>FraudDetection</literal> service. This request is handled
by a WireMock server configured with stubs generated by the Spring Cloud Contract
Verifier.</simpara>
</section>
</section>
<section xml:id="_stubs_and_transitive_dependencies">
<title>Stubs and Transitive Dependencies</title>
<simpara>The Maven and Gradle plugin that add the tasks that create the stubs jar for you. One
problem that arises is that, when reusing the stubs, you can mistakenly import all of
that stub&#8217;s dependencies. When building a Maven artifact, even though you have a couple
of different jars, all of them share one pom:</simpara>
<programlisting language="bash" linenumbering="unnumbered">├── github-webhook-0.0.1.BUILD-20160903.075506-1-stubs.jar
├── github-webhook-0.0.1.BUILD-20160903.075506-1-stubs.jar.sha1
├── github-webhook-0.0.1.BUILD-20160903.075655-2-stubs.jar
├── github-webhook-0.0.1.BUILD-20160903.075655-2-stubs.jar.sha1
├── github-webhook-0.0.1.BUILD-SNAPSHOT.jar
├── github-webhook-0.0.1.BUILD-SNAPSHOT.pom
├── github-webhook-0.0.1.BUILD-SNAPSHOT-stubs.jar
├── ...
└── ...</programlisting>
<simpara>There are three possibilities of working with those dependencies so as not to have any
issues with transitive dependencies:</simpara>
<itemizedlist>
<listitem>
<simpara>Mark all application dependencies as optional</simpara>
</listitem>
<listitem>
<simpara>Create a separate artifactid for the stubs</simpara>
</listitem>
<listitem>
<simpara>Exclude dependencies on the consumer side</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Mark all application dependencies as optional</emphasis></simpara>
<simpara>If, in the <literal>github-webhook</literal> application, you mark all of your dependencies as optional,
when you include the <literal>github-webhook</literal> stubs in another application (or when that
dependency gets downloaded by Stub Runner) then, since all of the dependencies are
optional, they will not get downloaded.</simpara>
<simpara><emphasis role="strong">Create a separate <literal>artifactid</literal> for the stubs</emphasis></simpara>
<simpara>If you create a separate <literal>artifactid</literal>, then you can set it up in whatever way you wish.
For example, you might decide to have no dependencies at all.</simpara>
<simpara><emphasis role="strong">Exclude dependencies on the consumer side</emphasis></simpara>
<simpara>As a consumer, if you add the stub dependency to your classpath, you can explicitly
exclude the unwanted dependencies.</simpara>
</section>
<section xml:id="_scenarios">
<title>Scenarios</title>
<simpara>You can handle scenarios with Spring Cloud Contract Verifier. All you need to do is to
stick to the proper naming convention while creating your contracts. The convention
requires including an order number followed by an underscore. This will work regardles
 of whether you&#8217;re working with YAML or Groovy. Example:</simpara>
<screen>my_contracts_dir\
  scenario1\
    1_login.groovy
    2_showCart.groovy
    3_logout.groovy</screen>
<simpara>Such a tree causes Spring Cloud Contract Verifier to generate WireMock&#8217;s scenario with a
name of <literal>scenario1</literal> and the three following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>login marked as <literal>Started</literal> pointing to&#8230;&#8203;</simpara>
</listitem>
<listitem>
<simpara>showCart marked as <literal>Step1</literal> pointing to&#8230;&#8203;</simpara>
</listitem>
<listitem>
<simpara>logout marked as <literal>Step2</literal> which will close the scenario.</simpara>
</listitem>
</orderedlist>
<simpara>More details about WireMock scenarios can be found at
<link xl:href="http://wiremock.org/stateful-behaviour.html">http://wiremock.org/stateful-behaviour.html</link></simpara>
<simpara>Spring Cloud Contract Verifier also generates tests with a guaranteed order of execution.</simpara>
</section>
<section xml:id="docker-project">
<title>Docker Project</title>
<simpara>We&#8217;re publishing a <literal>springcloud/spring-cloud-contract</literal> Docker image
that contains a project that will generate tests and execute them in <literal>EXPLICIT</literal> mode
against a running application.</simpara>
<tip>
<simpara>The <literal>EXPLICIT</literal> mode means that the tests generated from contracts will send
real requests and not the mocked ones.</simpara>
</tip>
<section xml:id="_short_intro_to_maven_jars_and_binary_storage">
<title>Short intro to Maven, JARs and Binary storage</title>
<simpara>Since the Docker image can be used by non JVM projects, it&#8217;s good to
explain the basic terms behind Spring Cloud Contract packaging defaults.</simpara>
<simpara>Part of the following definitions were taken from the <link xl:href="https://maven.apache.org/glossary.html">Maven Glossary</link></simpara>
<itemizedlist>
<listitem>
<simpara><literal>Project</literal>: Maven thinks in terms of projects. Everything that you
will build are projects. Those projects follow a well defined
“Project Object Model”. Projects can depend on other projects,
in which case the latter are called “dependencies”. A project may
consistent of several subprojects, however these subprojects are still
treated equally as projects.</simpara>
</listitem>
<listitem>
<simpara><literal>Artifact</literal>: An artifact is something that is either produced or used
by a project. Examples of artifacts produced by Maven for a project
include: JARs, source and binary distributions. Each artifact
is uniquely identified by a group id and an artifact ID which is
unique within a group.</simpara>
</listitem>
<listitem>
<simpara><literal>JAR</literal>: JAR stands for Java ARchive. It&#8217;s a format based on
the ZIP file format. Spring Cloud Contract packages the contracts and generated
stubs in a JAR file.</simpara>
</listitem>
<listitem>
<simpara><literal>GroupId</literal>: A group ID is a universally unique identifier for a project.
While this is often just the project name (eg. commons-collections),
it is helpful to use a fully-qualified package name to distinguish it
from other projects with a similar name (eg. org.apache.maven).
Typically, when published to the Artifact Manager, the <literal>GroupId</literal> will get
slash separated and form part of the URL. E.g. for group id <literal>com.example</literal>
and artifact id <literal>application</literal> would be <literal>/com/example/application/</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>Classifier</literal>: The Maven dependency notation looks as follows:
<literal>groupId:artifactId:version:classifier</literal>. The classifier is additional suffix
passed to the dependency. E.g. <literal>stubs</literal>, <literal>sources</literal>. The same dependency
e.g. <literal>com.example:application</literal> can produce multiple artifacts that
differ from each other with the classifier.</simpara>
</listitem>
<listitem>
<simpara><literal>Artifact manager</literal>: When you generate binaries / sources / packages, you would
like them to be available for others to download / reference or reuse. In case
of the JVM world those artifacts would be JARs, for Ruby these are gems
and for Docker those would be Docker images. You can store those artifacts
in a manager. Examples of such managers can be <link xl:href="https://jfrog.com/artifactory/">Artifactory</link>
or <link xl:href="https://www.sonatype.org/nexus/">Nexus</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_how_it_works_2">
<title>How it works</title>
<simpara>The image searches for contracts under the <literal>/contracts</literal> folder.
The output from running the tests will be available under
<literal>/spring-cloud-contract/build</literal> folder (it&#8217;s useful for debugging
purposes).</simpara>
<simpara>It&#8217;s enough for you to mount your contracts, pass the environment variables
 and the image will:</simpara>
<itemizedlist>
<listitem>
<simpara>generate the contract tests</simpara>
</listitem>
<listitem>
<simpara>execute the tests against the provided URL</simpara>
</listitem>
<listitem>
<simpara>generate the <link xl:href="http://wiremock.org">WireMock</link> stubs</simpara>
</listitem>
<listitem>
<simpara>(optional - turned on by default) publish the stubs to a Artifact Manager</simpara>
</listitem>
</itemizedlist>
<section xml:id="_environment_variables">
<title>Environment Variables</title>
<simpara>The Docker image requires some environment variables to point to
your running application, to the Artifact manager instance etc.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>PROJECT_GROUP</literal> - your project&#8217;s group id. Defaults to <literal>com.example</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>PROJECT_VERSION</literal> - your project&#8217;s version. Defaults to <literal>0.0.1-SNAPSHOT</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PROJECT_NAME</literal> - artifact id. Defaults to <literal>example</literal></simpara>
</listitem>
<listitem>
<simpara><literal>REPO_WITH_BINARIES_URL</literal> - URL of your Artifact Manager. Defaults to <literal><link xl:href="http://localhost:8081/artifactory/libs-release-local">http://localhost:8081/artifactory/libs-release-local</link></literal>
which is the default URL of <link xl:href="https://jfrog.com/artifactory/">Artifactory</link> running locally</simpara>
</listitem>
<listitem>
<simpara><literal>REPO_WITH_BINARIES_USERNAME</literal> - (optional) username when the Artifact Manager is secured</simpara>
</listitem>
<listitem>
<simpara><literal>REPO_WITH_BINARIES_PASSWORD</literal> - (optional) password when the Artifact Manager is secured</simpara>
</listitem>
<listitem>
<simpara><literal>PUBLISH_ARTIFACTS</literal> - if set to <literal>true</literal> then will publish artifact to binary storage. Defaults to <literal>true</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>These environment variables are used when tests are executed:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>APPLICATION_BASE_URL</literal> - url against which tests should be executed.
Remember that it has to be accessible from the Docker container (e.g. <literal>localhost</literal>
will not work)</simpara>
</listitem>
<listitem>
<simpara><literal>APPLICATION_USERNAME</literal> - (optional) username for basic authentication to your application</simpara>
</listitem>
<listitem>
<simpara><literal>APPLICATION_PASSWORD</literal> - (optional) password for basic authentication to your application</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_example_of_usage">
<title>Example of usage</title>
<simpara>Let&#8217;s take a look at a simple MVC application</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git clone https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs
$ cd bookstore</programlisting>
<simpara>The contracts are available under <literal>/contracts</literal> folder.</simpara>
</section>
<section xml:id="docker-server-side">
<title>Server side (nodejs)</title>
<simpara>Since we want to run tests, we could just execute:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ npm test</programlisting>
<simpara>however, for learning purposes, let&#8217;s split it into pieces:</simpara>
<programlisting language="bash" linenumbering="unnumbered"># Stop docker infra (nodejs, artifactory)
$ ./stop_infra.sh
# Start docker infra (nodejs, artifactory)
$ ./setup_infra.sh

# Kill &amp; Run app
$ pkill -f "node app"
$ nohup node app &amp;

# Prepare environment variables
$ SC_CONTRACT_DOCKER_VERSION="..."
$ APP_IP="192.168.0.100"
$ APP_PORT="3000"
$ ARTIFACTORY_PORT="8081"
$ APPLICATION_BASE_URL="http://${APP_IP}:${APP_PORT}"
$ ARTIFACTORY_URL="http://${APP_IP}:${ARTIFACTORY_PORT}/artifactory/libs-release-local"
$ CURRENT_DIR="$( pwd )"
$ CURRENT_FOLDER_NAME=${PWD##*/}
$ PROJECT_VERSION="0.0.1.RELEASE"

# Execute contract tests
$ docker run  --rm -e "APPLICATION_BASE_URL=${APPLICATION_BASE_URL}" -e "PUBLISH_ARTIFACTS=true" -e "PROJECT_NAME=${CURRENT_FOLDER_NAME}" -e "REPO_WITH_BINARIES_URL=${ARTIFACTORY_URL}" -e "PROJECT_VERSION=${PROJECT_VERSION}" -v "${CURRENT_DIR}/contracts/:/contracts:ro" -v "${CURRENT_DIR}/node_modules/spring-cloud-contract/output:/spring-cloud-contract-output/" springcloud/spring-cloud-contract:"${SC_CONTRACT_DOCKER_VERSION}"

# Kill app
$ pkill -f "node app"</programlisting>
<simpara>What will happen is that via bash scripts:</simpara>
<itemizedlist>
<listitem>
<simpara>infrastructure will be set up (MongoDb, Artifactory).
In real life scenario you would just run the NodeJS application
with mocked database. In this example we want to show how we can
benefit from Spring Cloud Contract in no time.</simpara>
</listitem>
<listitem>
<simpara>due to those constraints the contracts also represent the
stateful situation</simpara>
<itemizedlist>
<listitem>
<simpara>first request is a <literal>POST</literal> that causes data to get inserted to the database</simpara>
</listitem>
<listitem>
<simpara>second request is a <literal>GET</literal> that returns a list of data with 1 previously inserted element</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>the NodeJS application will be started (on port <literal>3000</literal>)</simpara>
</listitem>
<listitem>
<simpara>contract tests will be generated via Docker and tests
will be executed against the running application</simpara>
<itemizedlist>
<listitem>
<simpara>the contracts will be taken from <literal>/contracts</literal> folder.</simpara>
</listitem>
<listitem>
<simpara>the output of the test execution is available under
<literal>node_modules/spring-cloud-contract/output</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>the stubs will be uploaded to Artifactory. You can check them out
under <link xl:href="http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/">http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/</link> .
The stubs will be here <link xl:href="http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/bookstore-0.0.1.RELEASE-stubs.jar">http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/bookstore-0.0.1.RELEASE-stubs.jar</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>To see how the client side looks like check out the <xref linkend="stubrunner-docker"/> section.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="_spring_cloud_contract_verifier_messaging">
<title>Spring Cloud Contract Verifier Messaging</title>
<simpara>Spring Cloud Contract Verifier lets you verify applications that uses messaging as a
means of communication. All of the integrations shown in this document work with Spring,
but you can also create one of your own and use that.</simpara>
<section xml:id="_integrations_2">
<title>Integrations</title>
<simpara>You can use one of the following four integration configurations:</simpara>
<itemizedlist>
<listitem>
<simpara>Apache Camel</simpara>
</listitem>
<listitem>
<simpara>Spring Integration</simpara>
</listitem>
<listitem>
<simpara>Spring Cloud Stream</simpara>
</listitem>
<listitem>
<simpara>Spring AMQP</simpara>
</listitem>
</itemizedlist>
<simpara>Since we use Spring Boot, if you have added one of these libraries to the classpath, all
the messaging configuration is automatically set up.</simpara>
<important>
<simpara>Remember to put <literal>@AutoConfigureMessageVerifier</literal> on the base class of your
generated tests. Otherwise, messaging part of Spring Cloud Contract Verifier does not
work.</simpara>
</important>
<important>
<simpara>If you want to use Spring Cloud Stream, remember to add a dependency on
<literal>org.springframework.cloud:spring-cloud-stream-test-support</literal>, as shown here:</simpara>
</important>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-stream-test-support&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">testCompile "org.springframework.cloud:spring-cloud-stream-test-support"</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_manual_integration_testing">
<title>Manual Integration Testing</title>
<simpara>The main interface used by the tests is
<literal>org.springframework.cloud.contract.verifier.messaging.MessageVerifier</literal>.
It defines how to send and receive messages. You can create your own implementation to
achieve the same goal.</simpara>
<simpara>In a test, you can inject a <literal>ContractVerifierMessageExchange</literal> to send and receive
messages that follow the contract. Then add <literal>@AutoConfigureMessageVerifier</literal> to your test.
Here&#8217;s an example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RunWith(SpringTestRunner.class)
@SpringBootTest
@AutoConfigureMessageVerifier
public static class MessagingContractTests {

  @Autowired
  private MessageVerifier verifier;
  ...
}</programlisting>
<note>
<simpara>If your tests require stubs as well, then <literal>@AutoConfigureStubRunner</literal> includes the
messaging configuration, so you only need the one annotation.</simpara>
</note>
</section>
<section xml:id="_publisher_side_test_generation">
<title>Publisher-Side Test Generation</title>
<simpara>Having the <literal>input</literal> or <literal>outputMessage</literal> sections in your DSL results in creation of tests
on the publisher&#8217;s side. By default, JUnit tests are created. However, there is also a
possibility to create Spock tests.</simpara>
<simpara>There are 3 main scenarios that we should take into consideration:</simpara>
<itemizedlist>
<listitem>
<simpara>Scenario 1: There is no input message that produces an output message. The output
message  is triggered by a component inside the application (for example, scheduler).</simpara>
</listitem>
<listitem>
<simpara>Scenario 2: The input message triggers an output message.</simpara>
</listitem>
<listitem>
<simpara>Scenario 3: The input message is consumed and there is no output message.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>The destination passed to <literal>messageFrom</literal> or <literal>sentTo</literal> can have different
meanings for different messaging implementations. For <emphasis role="strong">Stream</emphasis> and <emphasis role="strong">Integration</emphasis> it is
first resolved as a <literal>destination</literal> of a channel. Then, if there is no such <literal>destination</literal>
it is resolved as a channel name. For <emphasis role="strong">Camel</emphasis>, that&#8217;s a certain component (for example,
<literal>jms</literal>).</simpara>
</important>
<section xml:id="_scenario_1_no_input_message">
<title>Scenario 1: No Input Message</title>
<simpara>Here is an example for Camel. For the given contract:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">def contractDsl = Contract.make {
	label 'some_label'
	input {
		triggeredBy('bookReturnedTriggered()')
	}
	outputMessage {
		sentTo('activemq:output')
		body('''{ "bookName" : "foo" }''')
		headers {
			header('BOOK-NAME', 'foo')
			messagingContentType(applicationJson())
		}
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">label: some_label
input:
  triggeredBy: bookReturnedTriggered
outputMessage:
  sentTo: activemq:output
  body:
    bookName: foo
  headers:
    BOOK-NAME: foo
    contentType: application/json</programlisting>
</para>
</formalpara>
<simpara>The following JUnit test is created:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">'''
 // when:
  bookReturnedTriggered();

 // then:
  ContractVerifierMessage response = contractVerifierMessaging.receive("activemq:output");
  assertThat(response).isNotNull();
  assertThat(response.getHeader("BOOK-NAME")).isNotNull();
  assertThat(response.getHeader("BOOK-NAME").toString()).isEqualTo("foo");
  assertThat(response.getHeader("contentType")).isNotNull();
  assertThat(response.getHeader("contentType").toString()).isEqualTo("application/json");
 // and:
  DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()));
  assertThatJson(parsedJson).field("bookName").isEqualTo("foo");
'''</programlisting>
<simpara>And the following Spock test would be created:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">'''
 when:
  bookReturnedTriggered()

 then:
  ContractVerifierMessage response = contractVerifierMessaging.receive('activemq:output')
  assert response != null
  response.getHeader('BOOK-NAME')?.toString()  == 'foo'
  response.getHeader('contentType')?.toString()  == 'application/json'
 and:
  DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.payload))
  assertThatJson(parsedJson).field("bookName").isEqualTo("foo")

'''</programlisting>
</section>
<section xml:id="_scenario_2_output_triggered_by_input">
<title>Scenario 2: Output Triggered by Input</title>
<simpara>Here is an example for Camel. For the given contract:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">def contractDsl = Contract.make {
	label 'some_label'
	input {
		messageFrom('jms:input')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('jms:output')
		body([
				bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">label: some_label
input:
  messageFrom: jms:input
  messageBody:
    bookName: 'foo'
  messageHeaders:
    sample: header
outputMessage:
  sentTo: jms:output
  body:
    bookName: foo
  headers:
    BOOK-NAME: foo</programlisting>
</para>
</formalpara>
<simpara>The following JUnit test is created:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">'''
// given:
 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
  "{\\"bookName\\":\\"foo\\"}"
, headers()
  .header("sample", "header"));

// when:
 contractVerifierMessaging.send(inputMessage, "jms:input");

// then:
 ContractVerifierMessage response = contractVerifierMessaging.receive("jms:output");
 assertThat(response).isNotNull();
 assertThat(response.getHeader("BOOK-NAME")).isNotNull();
 assertThat(response.getHeader("BOOK-NAME").toString()).isEqualTo("foo");
// and:
 DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()));
 assertThatJson(parsedJson).field("bookName").isEqualTo("foo");
'''</programlisting>
<simpara>And the following Spock test would be created:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">"""\
given:
   ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
    '''{"bookName":"foo"}''',
    ['sample': 'header']
  )

when:
   contractVerifierMessaging.send(inputMessage, 'jms:input')

then:
   ContractVerifierMessage response = contractVerifierMessaging.receive('jms:output')
   assert response !- null
   response.getHeader('BOOK-NAME')?.toString()  == 'foo'
and:
   DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.payload))
   assertThatJson(parsedJson).field("bookName").isEqualTo("foo")
"""</programlisting>
</section>
<section xml:id="_scenario_3_no_output_message">
<title>Scenario 3: No Output Message</title>
<simpara>Here is an example for Camel. For the given contract:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">def contractDsl = Contract.make {
	label 'some_label'
	input {
		messageFrom('jms:delete')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
		assertThat('bookWasDeleted()')
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">label: some_label
input:
  messageFrom: jms:delete
  messageBody:
    bookName: 'foo'
  messageHeaders:
    sample: header
  assertThat: bookWasDeleted()</programlisting>
</para>
</formalpara>
<simpara>The following JUnit test is created:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">'''
// given:
 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
	"{\\"bookName\\":\\"foo\\"}"
, headers()
	.header("sample", "header"));

// when:
 contractVerifierMessaging.send(inputMessage, "jms:delete");

// then:
 bookWasDeleted();
'''</programlisting>
<simpara>And the following Spock test would be created:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">'''
given:
	 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
		\'\'\'{"bookName":"foo"}\'\'\',
		['sample': 'header']
	)

when:
	 contractVerifierMessaging.send(inputMessage, 'jms:delete')

then:
	 noExceptionThrown()
	 bookWasDeleted()
'''</programlisting>
</section>
</section>
<section xml:id="_consumer_stub_generation">
<title>Consumer Stub Generation</title>
<simpara>Unlike the HTTP part, in messaging, we need to publish the Groovy DSL inside the JAR with
a stub. Then it is parsed on the consumer side and proper stubbed routes are created.</simpara>
<simpara>For more information, see
<link xl:href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html/#stub-runner-for-messaging">the
Stub Runner Messaging sections</link>.</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
		&lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
	&lt;/dependency&gt;

	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
		&lt;artifactId&gt;spring-cloud-starter-contract-stub-runner&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
		&lt;artifactId&gt;spring-cloud-stream-test-support&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;Edgware.BUILD-SNAPSHOT&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">ext {
	contractsDir = file("mappings")
	stubsOutputDirRoot = file("${project.buildDir}/production/${project.name}-stubs/")
}

// Automatically added by plugin:
// copyContracts - copies contracts to the output folder from which JAR will be created
// verifierStubsJar - JAR with a provided stub suffix
// the presented publication is also added by the plugin but you can modify it as you wish

publishing {
	publications {
		stubs(MavenPublication) {
			artifactId "${project.name}-stubs"
			artifact verifierStubsJar
		}
	}
}</programlisting>
</para>
</formalpara>
</section>
</chapter>
<chapter xml:id="_spring_cloud_contract_stub_runner">
<title>Spring Cloud Contract Stub Runner</title>
<simpara>One of the issues that you might encounter while using Spring Cloud Contract Verifier is
passing the generated WireMock JSON stubs from the server side to the client side (or to
various clients). The same takes place in terms of client-side generation for messaging.</simpara>
<simpara>Copying the JSON files and setting the client side for messaging manually is out of the
question. That is why we introduced Spring Cloud Contract Stub Runner. It can
automatically download and run the stubs for you.</simpara>
<section xml:id="_snapshot_versions">
<title>Snapshot versions</title>
<simpara>Add the additional snapshot repository to your <literal>build.gradle</literal> file to use snapshot
versions, which are automatically uploaded after every successful build:</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">buildscript {
	repositories {
		mavenCentral()
		mavenLocal()
		maven { url "https://repo.spring.io/snapshot" }
		maven { url "https://repo.spring.io/milestone" }
		maven { url "https://repo.spring.io/release" }
	}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_publishing_stubs_as_jars">
<title>Publishing Stubs as JARs</title>
<simpara>The easiest approach would be to centralize the way stubs are kept. For example, you can
keep them as jars in a Maven repository.</simpara>
<tip>
<simpara>For both Maven and Gradle, the setup comes ready to work. However, you can customize
it if you want to.</simpara>
</tip>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- First disable the default jar setup in the properties section --&gt;
&lt;!-- we don't want the verifier to do a jar for us --&gt;
&lt;spring.cloud.contract.verifier.skip&gt;true&lt;/spring.cloud.contract.verifier.skip&gt;

&lt;!-- Next add the assembly plugin to your build --&gt;
&lt;!-- we want the assembly plugin to generate the JAR --&gt;
&lt;plugin&gt;
	&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
	&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
	&lt;executions&gt;
		&lt;execution&gt;
			&lt;id&gt;stub&lt;/id&gt;
			&lt;phase&gt;prepare-package&lt;/phase&gt;
			&lt;goals&gt;
				&lt;goal&gt;single&lt;/goal&gt;
			&lt;/goals&gt;
			&lt;inherited&gt;false&lt;/inherited&gt;
			&lt;configuration&gt;
				&lt;attach&gt;true&lt;/attach&gt;
				&lt;descriptor&gt;$../../../../src/assembly/stub.xml&lt;/descriptor&gt;
			&lt;/configuration&gt;
		&lt;/execution&gt;
	&lt;/executions&gt;
&lt;/plugin&gt;

&lt;!-- Finally setup your assembly. Below you can find the contents of src/main/assembly/stub.xml --&gt;
&lt;assembly
	xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd"&gt;
	&lt;id&gt;stubs&lt;/id&gt;
	&lt;formats&gt;
		&lt;format&gt;jar&lt;/format&gt;
	&lt;/formats&gt;
	&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
	&lt;fileSets&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;src/main/java&lt;/directory&gt;
			&lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**com/example/model/*.*&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${project.build.directory}/classes&lt;/directory&gt;
			&lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**com/example/model/*.*&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${project.build.directory}/snippets/stubs&lt;/directory&gt;
			&lt;outputDirectory&gt;META-INF/${project.groupId}/${project.artifactId}/${project.version}/mappings&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**/*&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;$../../../../src/test/resources/contracts&lt;/directory&gt;
			&lt;outputDirectory&gt;META-INF/${project.groupId}/${project.artifactId}/${project.version}/contracts&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**/*.groovy&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
	&lt;/fileSets&gt;
&lt;/assembly&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">ext {
	contractsDir = file("mappings")
	stubsOutputDirRoot = file("${project.buildDir}/production/${project.name}-stubs/")
}

// Automatically added by plugin:
// copyContracts - copies contracts to the output folder from which JAR will be created
// verifierStubsJar - JAR with a provided stub suffix
// the presented publication is also added by the plugin but you can modify it as you wish

publishing {
	publications {
		stubs(MavenPublication) {
			artifactId "${project.name}-stubs"
			artifact verifierStubsJar
		}
	}
}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_stub_runner_core">
<title>Stub Runner Core</title>
<simpara>Runs stubs for service collaborators. Treating stubs as contracts of services allows to use stub-runner as an implementation of
<link xl:href="https://martinfowler.com/articles/consumerDrivenContracts.html">Consumer Driven Contracts</link>.</simpara>
<simpara>Stub Runner allows you to automatically download the stubs of the provided dependencies (or pick those from the classpath), start WireMock servers for them and feed them with proper stub definitions.
For messaging, special stub routes are defined.</simpara>
<section xml:id="_retrieving_stubs">
<title>Retrieving stubs</title>
<simpara>You can pick the following options of acquiring stubs</simpara>
<itemizedlist>
<listitem>
<simpara>Aether based solution that downloads JARs with stubs from Artifactory / Nexus</simpara>
</listitem>
<listitem>
<simpara>Classpath scanning solution that searches classpath via pattern to retrieve stubs</simpara>
</listitem>
<listitem>
<simpara>Write your own implementation of the <literal>org.springframework.cloud.contract.stubrunner.StubDownloaderBuilder</literal> for full customization</simpara>
</listitem>
</itemizedlist>
<simpara>The latter example is described in the <link linkend="custom_stub_runner">Custom Stub Runner</link> section.</simpara>
<section xml:id="_stub_downloading">
<title>Stub downloading</title>
<simpara>If you provide the <literal>stubrunner.repositoryRoot</literal> or <literal>stubrunner.workOffline</literal> flag will be set
to <literal>true</literal> then Stub Runner will connect to the given server and download the required jars.
It will then unpack the JAR to a temporary folder and reference those files in further
contract processing.</simpara>
<simpara>Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@AutoConfigureStubRunner(repositoryRoot="https://foo.bar", ids = "com.example:beer-api-producer:+:stubs:8095")</programlisting>
</section>
<section xml:id="_classpath_scanning">
<title>Classpath scanning</title>
<simpara>If you <emphasis role="strong">DON&#8217;T</emphasis> provide the <literal>stubrunner.repositoryRoot</literal> and <literal>stubrunner.workOffline</literal> flag will
be set to <literal>false</literal> (that&#8217;s the default) then classpath will get scanned. Let&#8217;s look at the
following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@AutoConfigureStubRunner(ids = {
    "com.example:beer-api-producer:+:stubs:8095",
    "com.example.foo:bar:1.0.0:superstubs:8096"
})</programlisting>
<simpara>If you&#8217;ve added the dependencies to your classpath</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;beer-api-producer-restdocs&lt;/artifactId&gt;
    &lt;classifier&gt;stubs&lt;/classifier&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;*&lt;/groupId&gt;
            &lt;artifactId&gt;*&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.example.foo&lt;/groupId&gt;
    &lt;artifactId&gt;bar&lt;/artifactId&gt;
    &lt;classifier&gt;superstubs&lt;/classifier&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;*&lt;/groupId&gt;
            &lt;artifactId&gt;*&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">testCompile("com.example:beer-api-producer-restdocs:0.0.1-SNAPSHOT:stubs") {
    transitive = false
}
testCompile("com.example.foo:bar:1.0.0:superstubs") {
    transitive = false
}</programlisting>
</para>
</formalpara>
<simpara>Then the following locations on your classpath will get scanned. For <literal>com.example:beer-api-producer-restdocs</literal></simpara>
<itemizedlist>
<listitem>
<simpara>/META-INF/com.example/beer-api-producer-restdocs/<emphasis role="strong">*/</emphasis>.*</simpara>
</listitem>
<listitem>
<simpara>/contracts/com.example/beer-api-producer-restdocs/<emphasis role="strong">*/</emphasis>.*</simpara>
</listitem>
<listitem>
<simpara>/mappings/com.example/beer-api-producer-restdocs/<emphasis role="strong">*/</emphasis>.*</simpara>
</listitem>
</itemizedlist>
<simpara>and <literal>com.example.foo:bar</literal></simpara>
<itemizedlist>
<listitem>
<simpara>/META-INF/com.example.foo/bar/<emphasis role="strong">*/</emphasis>.*</simpara>
</listitem>
<listitem>
<simpara>/contracts/com.example.foo/bar/<emphasis role="strong">*/</emphasis>.*</simpara>
</listitem>
<listitem>
<simpara>/mappings/com.example.foo/bar/<emphasis role="strong">*/</emphasis>.*</simpara>
</listitem>
</itemizedlist>
<tip>
<simpara>As you can see you have to explicitly provide the group and artifact ids when packaging the
producer stubs.</simpara>
</tip>
<simpara>The producer would setup the contracts like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">└── src
    └── test
        └── resources
            └── contracts
                └── com.example
                    └── beer-api-producer-restdocs
                        └── nested
                            └── contract3.groovy</programlisting>
<simpara>To achieve proper stub packaging.</simpara>
<simpara>Or using the <link xl:href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/blob/master/producer_with_restdocs/pom.xml">Maven <literal>assembly</literal> plugin</link> or
<link xl:href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/blob/master/producer_with_restdocs/build.gradle">Gradle Jar</link> task you have to create the following
structure in your stubs jar.</simpara>
<programlisting language="bash" linenumbering="unnumbered">└── META-INF
    └── com.example
        └── beer-api-producer-restdocs
            └── 2.0.0
                ├── contracts
                │   └── nested
                │       └── contract2.groovy
                └── mappings
                    └── mapping.json</programlisting>
<simpara>By maintaining this structure classpath gets scanned and you can profit from the messaging /
HTTP stubs without the need to download artifacts.</simpara>
</section>
</section>
<section xml:id="_running_stubs">
<title>Running stubs</title>
<section xml:id="_limitations">
<title>Limitations</title>
<important>
<simpara>There might be a problem with StubRunner shutting down ports between tests. You might
 have a situation in which you get port conflicts. As long as you use the same context across tests
 everything works fine. But when the context are different (e.g. different stubs or different profiles)
 then you have to either use <literal>@DirtiesContext</literal> to shut down the stub servers, or else run them on
 different ports per test.</simpara>
</important>
</section>
<section xml:id="_running_using_main_app">
<title>Running using main app</title>
<simpara>You can set the following options to the main class:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">-c, --classifier                Suffix for the jar containing stubs (e.
                                  g. 'stubs' if the stub jar would
                                  have a 'stubs' classifier for stubs:
                                  foobar-stubs ). Defaults to 'stubs'
                                  (default: stubs)
--maxPort, --maxp &lt;Integer&gt;     Maximum port value to be assigned to
                                  the WireMock instance. Defaults to
                                  15000 (default: 15000)
--minPort, --minp &lt;Integer&gt;     Minimum port value to be assigned to
                                  the WireMock instance. Defaults to
                                  10000 (default: 10000)
-p, --password                  Password to user when connecting to
                                  repository
--phost, --proxyHost            Proxy host to use for repository
                                  requests
--pport, --proxyPort [Integer]  Proxy port to use for repository
                                  requests
-r, --root                      Location of a Jar containing server
                                  where you keep your stubs (e.g. http:
                                  //nexus.
                                  net/content/repositories/repository)
-s, --stubs                     Comma separated list of Ivy
                                  representation of jars with stubs.
                                  Eg. groupid:artifactid1,groupid2:
                                  artifactid2:classifier
-u, --username                  Username to user when connecting to
                                  repository
--wo, --workOffline             Switch to work offline. Defaults to
                                  'false'</programlisting>
</section>
<section xml:id="_http_stubs">
<title>HTTP Stubs</title>
<simpara>Stubs are defined in JSON documents, whose syntax is defined in <link xl:href="http://wiremock.org/stubbing.html">WireMock documentation</link></simpara>
<simpara>Example:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">{
    "request": {
        "method": "GET",
        "url": "/ping"
    },
    "response": {
        "status": 200,
        "body": "pong",
        "headers": {
            "Content-Type": "text/plain"
        }
    }
}</programlisting>
</section>
<section xml:id="_viewing_registered_mappings">
<title>Viewing registered mappings</title>
<simpara>Every stubbed collaborator exposes list of defined mappings under <literal>__/admin/</literal> endpoint.</simpara>
<simpara>You can also use the <literal>mappingsOutputFolder</literal> property to dump the mappings to files.
 For annotation based approach it would look like this</simpara>
<programlisting language="java" linenumbering="unnumbered">@AutoConfigureStubRunner(ids="a.b.c:loanIssuance,a.b.c:fraudDetectionServer",
mappingsOutputFolder = "target/outputmappings/")</programlisting>
<simpara>and for the JUnit approach like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@ClassRule @Shared StubRunnerRule rule = new StubRunnerRule()
			.repoRoot("http://some_url")
			.downloadStub("a.b.c", "loanIssuance")
			.downloadStub("a.b.c:fraudDetectionServer")
			.withMappingsOutputFolder("target/outputmappings")</programlisting>
<simpara>Then if you check out the folder <literal>target/outputmappings</literal> you would see the following structure</simpara>
<programlisting language="bash" linenumbering="unnumbered">.
├── fraudDetectionServer_13705
└── loanIssuance_12255</programlisting>
<simpara>That means that there were two stubs registered. <literal>fraudDetectionServer</literal> was registered at port <literal>13705</literal>
and <literal>loanIssuance</literal> at port <literal>12255</literal>. If we take a look at one of the files we would see (for WireMock)
mappings available for the given server:</simpara>
<programlisting language="json" linenumbering="unnumbered">[{
  "id" : "f9152eb9-bf77-4c38-8289-90be7d10d0d7",
  "request" : {
    "url" : "/name",
    "method" : "GET"
  },
  "response" : {
    "status" : 200,
    "body" : "fraudDetectionServer"
  },
  "uuid" : "f9152eb9-bf77-4c38-8289-90be7d10d0d7"
},
...
]</programlisting>
</section>
<section xml:id="_messaging_stubs">
<title>Messaging Stubs</title>
<simpara>Depending on the provided Stub Runner dependency and the DSL the messaging routes are automatically set up.</simpara>
</section>
</section>
</section>
<section xml:id="_stub_runner_junit_rule">
<title>Stub Runner JUnit Rule</title>
<simpara>Stub Runner comes with a JUnit rule thanks to which you can very easily download and run stubs for given group and artifact id:</simpara>
<programlisting language="java" linenumbering="unnumbered">@ClassRule public static StubRunnerRule rule = new StubRunnerRule()
		.repoRoot(repoRoot())
		.downloadStub("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")
		.downloadStub("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer");</programlisting>
<simpara>After that rule gets executed Stub Runner connects to your Maven repository and for the given list of dependencies tries to:</simpara>
<itemizedlist>
<listitem>
<simpara>download them</simpara>
</listitem>
<listitem>
<simpara>cache them locally</simpara>
</listitem>
<listitem>
<simpara>unzip them to a temporary folder</simpara>
</listitem>
<listitem>
<simpara>start a WireMock server for each Maven dependency on a random port from the provided range of ports / provided port</simpara>
</listitem>
<listitem>
<simpara>feed the WireMock server with all JSON files that are valid WireMock definitions</simpara>
</listitem>
<listitem>
<simpara>can also send messages (remember to pass an implementation of <literal>MessageVerifier</literal> interface)</simpara>
</listitem>
</itemizedlist>
<simpara>Stub Runner uses <link xl:href="https://wiki.eclipse.org/Aether">Eclipse Aether</link> mechanism to download the Maven dependencies.
Check their <link xl:href="https://wiki.eclipse.org/Aether">docs</link> for more information.</simpara>
<simpara>Since the <literal>StubRunnerRule</literal> implements the <literal>StubFinder</literal> it allows you to find the started stubs:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">package org.springframework.cloud.contract.stubrunner;

import java.net.URL;
import java.util.Collection;
import java.util.Map;

import org.springframework.cloud.contract.spec.Contract;

public interface StubFinder extends StubTrigger {
	/**
	 * For the given groupId and artifactId tries to find the matching
	 * URL of the running stub.
	 *
	 * @param groupId - might be null. In that case a search only via artifactId takes place
	 * @return URL of a running stub or throws exception if not found
	 */
	URL findStubUrl(String groupId, String artifactId) throws StubNotFoundException;

	/**
	 * For the given Ivy notation {@code [groupId]:artifactId:[version]:[classifier]} tries to
	 * find the matching URL of the running stub. You can also pass only {@code artifactId}.
	 *
	 * @param ivyNotation - Ivy representation of the Maven artifact
	 * @return URL of a running stub or throws exception if not found
	 */
	URL findStubUrl(String ivyNotation) throws StubNotFoundException;

	/**
	 * Returns all running stubs
	 */
	RunningStubs findAllRunningStubs();

	/**
	 * Returns the list of Contracts
	 */
	Map&lt;StubConfiguration, Collection&lt;Contract&gt;&gt; getContracts();
}</programlisting>
<simpara>Example of usage in Spock tests:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@ClassRule @Shared StubRunnerRule rule = new StubRunnerRule()
		.repoRoot(StubRunnerRuleSpec.getResource("/m2repo/repository").toURI().toString())
		.downloadStub("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")
		.downloadStub("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")
		.withMappingsOutputFolder("target/outputmappingsforrule")


def 'should start WireMock servers'() {
	expect: 'WireMocks are running'
		rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance') != null
		rule.findStubUrl('loanIssuance') != null
		rule.findStubUrl('loanIssuance') == rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance')
		rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer') != null
	and:
		rule.findAllRunningStubs().isPresent('loanIssuance')
		rule.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs', 'fraudDetectionServer')
		rule.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer')
	and: 'Stubs were registered'
		"${rule.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
		"${rule.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
}

def 'should output mappings to output folder'() {
	when:
		def url = rule.findStubUrl('fraudDetectionServer')
	then:
		new File("target/outputmappingsforrule", "fraudDetectionServer_${url.port}").exists()
}</programlisting>
<simpara>Example of usage in JUnit tests:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Test
public void should_start_wiremock_servers() throws Exception {
	// expect: 'WireMocks are running'
		then(rule.findStubUrl("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")).isNotNull();
		then(rule.findStubUrl("loanIssuance")).isNotNull();
		then(rule.findStubUrl("loanIssuance")).isEqualTo(rule.findStubUrl("org.springframework.cloud.contract.verifier.stubs", "loanIssuance"));
		then(rule.findStubUrl("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")).isNotNull();
	// and:
		then(rule.findAllRunningStubs().isPresent("loanIssuance")).isTrue();
		then(rule.findAllRunningStubs().isPresent("org.springframework.cloud.contract.verifier.stubs", "fraudDetectionServer")).isTrue();
		then(rule.findAllRunningStubs().isPresent("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")).isTrue();
	// and: 'Stubs were registered'
		then(httpGet(rule.findStubUrl("loanIssuance").toString() + "/name")).isEqualTo("loanIssuance");
		then(httpGet(rule.findStubUrl("fraudDetectionServer").toString() + "/name")).isEqualTo("fraudDetectionServer");
}</programlisting>
<simpara>Check the <emphasis role="strong">Common properties for JUnit and Spring</emphasis> for more information on how to apply global configuration of Stub Runner.</simpara>
<important>
<simpara>To use the JUnit rule together with messaging you have to provide an implementation of the
<literal>MessageVerifier</literal> interface to the rule builder (e.g. <literal>rule.messageVerifier(new MyMessageVerifier())</literal>).
If you don&#8217;t do this then whenever you try to send a message an exception will be thrown.</simpara>
</important>
<section xml:id="_maven_settings">
<title>Maven settings</title>
<simpara>The stub downloader honors Maven settings for a different local repository folder.
Authentication details for repositories and profiles are currently not taken into account, so you need to specify it using the properties mentioned above.</simpara>
</section>
<section xml:id="_providing_fixed_ports">
<title>Providing fixed ports</title>
<simpara>You can also run your stubs on fixed ports. You can do it in two different ways. One is to pass it in the properties, and the other via fluent API of
JUnit rule.</simpara>
</section>
<section xml:id="_fluent_api">
<title>Fluent API</title>
<simpara>When using the <literal>StubRunnerRule</literal> you can add a stub to download and then pass the port for the last downloaded stub.</simpara>
<programlisting language="java" linenumbering="unnumbered">@ClassRule public static StubRunnerRule rule = new StubRunnerRule()
		.repoRoot(repoRoot())
		.downloadStub("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")
		.withPort(12345)
		.downloadStub("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer:12346");</programlisting>
<simpara>You can see that for this example the following test is valid:</simpara>
<programlisting language="java" linenumbering="unnumbered">then(rule.findStubUrl("loanIssuance")).isEqualTo(URI.create("http://localhost:12345").toURL());
then(rule.findStubUrl("fraudDetectionServer")).isEqualTo(URI.create("http://localhost:12346").toURL());</programlisting>
</section>
<section xml:id="_stub_runner_with_spring">
<title>Stub Runner with Spring</title>
<simpara>Sets up Spring configuration of the Stub Runner project.</simpara>
<simpara>By providing a list of stubs inside your configuration file the Stub Runner automatically downloads
and registers in WireMock the selected stubs.</simpara>
<simpara>If you want to find the URL of your stubbed dependency you can autowire the <literal>StubFinder</literal> interface and use
its methods as presented below:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@ContextConfiguration(classes = Config, loader = SpringBootContextLoader)
@SpringBootTest(properties = [" stubrunner.cloud.enabled=false",
		"stubrunner.camel.enabled=false",
		'foo=${stubrunner.runningstubs.fraudDetectionServer.port}'])
@AutoConfigureStubRunner(mappingsOutputFolder = "target/outputmappings/")
@DirtiesContext
@ActiveProfiles("test")
class StubRunnerConfigurationSpec extends Specification {

	@Autowired StubFinder stubFinder
	@Autowired Environment environment
	@Value('${foo}') Integer foo

	@BeforeClass
	@AfterClass
	void setupProps() {
		System.clearProperty("stubrunner.repository.root")
		System.clearProperty("stubrunner.classifier")
	}

	def 'should start WireMock servers'() {
		expect: 'WireMocks are running'
			stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance') != null
			stubFinder.findStubUrl('loanIssuance') != null
			stubFinder.findStubUrl('loanIssuance') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance')
			stubFinder.findStubUrl('loanIssuance') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance')
			stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT:stubs')
			stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer') != null
		and:
			stubFinder.findAllRunningStubs().isPresent('loanIssuance')
			stubFinder.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs', 'fraudDetectionServer')
			stubFinder.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer')
		and: 'Stubs were registered'
			"${stubFinder.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
			"${stubFinder.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
	}

	def 'should throw an exception when stub is not found'() {
		when:
			stubFinder.findStubUrl('nonExistingService')
		then:
			thrown(StubNotFoundException)
		when:
			stubFinder.findStubUrl('nonExistingGroupId', 'nonExistingArtifactId')
		then:
			thrown(StubNotFoundException)
	}

	def 'should register started servers as environment variables'() {
		expect:
			environment.getProperty("stubrunner.runningstubs.loanIssuance.port") != null
			stubFinder.findAllRunningStubs().getPort("loanIssuance") == (environment.getProperty("stubrunner.runningstubs.loanIssuance.port") as Integer)
		and:
			environment.getProperty("stubrunner.runningstubs.fraudDetectionServer.port") != null
			stubFinder.findAllRunningStubs().getPort("fraudDetectionServer") == (environment.getProperty("stubrunner.runningstubs.fraudDetectionServer.port") as Integer)
	}

	def 'should be able to interpolate a running stub in the passed test property'() {
		given:
			int fraudPort = stubFinder.findAllRunningStubs().getPort("fraudDetectionServer")
		expect:
			fraudPort &gt; 0
			environment.getProperty("foo", Integer) == fraudPort
			foo == fraudPort
	}

	def 'should dump all mappings to a file'() {
		when:
			def url = stubFinder.findStubUrl("fraudDetectionServer")
		then:
			new File("target/outputmappings/", "fraudDetectionServer_${url.port}").exists()
	}

	@Configuration
	@EnableAutoConfiguration
	static class Config {}
}</programlisting>
<simpara>for the following configuration file:</simpara>
<programlisting language="yml" linenumbering="unnumbered">stubrunner:
  repositoryRoot: classpath:m2repo/repository/
  ids:
    - org.springframework.cloud.contract.verifier.stubs:loanIssuance
    - org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer
    - org.springframework.cloud.contract.verifier.stubs:bootService</programlisting>
<simpara>Instead of using the properties you can also use the properties inside the <literal>@AutoConfigureStubRunner</literal>.
Below you can find an example of achieving the same result by setting values on the annotation.</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@AutoConfigureStubRunner(
		ids = ["org.springframework.cloud.contract.verifier.stubs:loanIssuance",
		"org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer",
		"org.springframework.cloud.contract.verifier.stubs:bootService"],
		repositoryRoot = "classpath:m2repo/repository/")</programlisting>
<simpara>Stub Runner Spring registers environment variables in the following manner
for every registered WireMock server. Example for Stub Runner ids
 <literal>com.example:foo</literal>, <literal>com.example:bar</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>stubrunner.runningstubs.foo.port</literal></simpara>
</listitem>
<listitem>
<simpara><literal>stubrunner.runningstubs.bar.port</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Which you can reference in your code.</simpara>
</section>
</section>
<section xml:id="_stub_runner_spring_cloud">
<title>Stub Runner Spring Cloud</title>
<simpara>Stub Runner can integrate with Spring Cloud.</simpara>
<simpara>For real life examples you can check the</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/master/producer">producer app sample</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/master/consumer_with_discovery">consumer app sample</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="_stubbing_service_discovery">
<title>Stubbing Service Discovery</title>
<simpara>The most important feature of <literal>Stub Runner Spring Cloud</literal> is the fact that it&#8217;s stubbing</simpara>
<itemizedlist>
<listitem>
<simpara><literal>DiscoveryClient</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Ribbon</literal> <literal>ServerList</literal></simpara>
</listitem>
</itemizedlist>
<simpara>that means that regardless of the fact whether you&#8217;re using Zookeeper, Consul, Eureka or anything else, you don&#8217;t need that in your tests.
We&#8217;re starting WireMock instances of your dependencies and we&#8217;re telling your application whenever you&#8217;re using <literal>Feign</literal>, load balanced <literal>RestTemplate</literal>
or <literal>DiscoveryClient</literal> directly, to call those stubbed servers instead of calling the real Service Discovery tool.</simpara>
<simpara>For example this test will pass</simpara>
<programlisting language="groovy" linenumbering="unnumbered">def 'should make service discovery work'() {
	expect: 'WireMocks are running'
		"${stubFinder.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
		"${stubFinder.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
	and: 'Stubs can be reached via load service discovery'
		restTemplate.getForObject('http://loanIssuance/name', String) == 'loanIssuance'
		restTemplate.getForObject('http://someNameThatShouldMapFraudDetectionServer/name', String) == 'fraudDetectionServer'
}</programlisting>
<simpara>for the following configuration file</simpara>
<programlisting language="yml" linenumbering="unnumbered">stubrunner:
  idsToServiceIds:
    ivyNotation: someValueInsideYourCode
    fraudDetectionServer: someNameThatShouldMapFraudDetectionServer</programlisting>
<section xml:id="_test_profiles_and_service_discovery">
<title>Test profiles and service discovery</title>
<simpara>In your integration tests you typically don&#8217;t want to call neither a discovery service (e.g. Eureka)
or Config Server. That&#8217;s why you create an additional test configuration in which you want to disable
these features.</simpara>
<simpara>Due to certain limitations of <link xl:href="https://github.com/spring-cloud/spring-cloud-commons/issues/156"><literal>spring-cloud-commons</literal></link> to achieve this you have disable these properties
via a static block like presented below (example for Eureka)</simpara>
<programlisting language="java" linenumbering="unnumbered">    //Hack to work around https://github.com/spring-cloud/spring-cloud-commons/issues/156
    static {
        System.setProperty("eureka.client.enabled", "false");
        System.setProperty("spring.cloud.config.failFast", "false");
    }</programlisting>
</section>
</section>
<section xml:id="_additional_configuration">
<title>Additional Configuration</title>
<simpara>You can match the artifactId of the stub with the name of your app by using the <literal>stubrunner.idsToServiceIds:</literal> map.
You can disable Stub Runner Ribbon support by providing: <literal>stubrunner.cloud.ribbon.enabled</literal> equal to <literal>false</literal>
You can disable Stub Runner support by providing: <literal>stubrunner.cloud.enabled</literal> equal to <literal>false</literal></simpara>
<tip>
<simpara>By default all service discovery will be stubbed. That means that regardless of the fact if you have
an existing <literal>DiscoveryClient</literal> its results will be ignored. However, if you want to reuse it, just set
 <literal>stubrunner.cloud.delegate.enabled</literal> to <literal>true</literal> and then your existing <literal>DiscoveryClient</literal> results will be
 merged with the stubbed ones.</simpara>
</tip>
</section>
</section>
<section xml:id="_stub_runner_boot_application">
<title>Stub Runner Boot Application</title>
<simpara>Spring Cloud Contract Stub Runner Boot is a Spring Boot application that exposes REST endpoints to
trigger the messaging labels and to access started WireMock servers.</simpara>
<simpara>One of the use-cases is to run some smoke (end to end) tests on a deployed application.
You can check out the <link xl:href="https://github.com/spring-cloud/spring-cloud-pipelines">Spring Cloud Pipelines</link>
project for more information.</simpara>
<section xml:id="_how_to_use_it">
<title>How to use it?</title>
<section xml:id="_stub_runner_server">
<title>Stub Runner Server</title>
<simpara>Just add the</simpara>
<programlisting language="groovy" linenumbering="unnumbered">compile "org.springframework.cloud:spring-cloud-starter-stub-runner"</programlisting>
<simpara>Annotate a class with <literal>@EnableStubRunnerServer</literal>, build a fat-jar and you&#8217;re ready to go!</simpara>
<simpara>For the properties check the <emphasis role="strong">Stub Runner Spring</emphasis> section.</simpara>
</section>
<section xml:id="_spring_cloud_cli">
<title>Spring Cloud CLI</title>
<simpara>Starting from <literal>1.4.0.RELEASE</literal> version of the <link xl:href="https://cloud.spring.io/spring-cloud-cli">Spring Cloud CLI</link>
project you can start Stub Runner Boot by executing <literal>spring cloud stubrunner</literal>.</simpara>
<simpara>In order to pass the configuration just create a <literal>stubrunner.yml</literal> file in the current working directory
or a subdirectory called <literal>config</literal> or in <literal>~/.spring-cloud</literal>. The file could look like this
(example for running stubs installed locally)</simpara>
<formalpara>
<title>stubrunner.yml</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">stubrunner:
  workOffline: true
  ids:
    - com.example:beer-api-producer:+:9876</programlisting>
</para>
</formalpara>
<simpara>and then just call <literal>spring cloud stubrunner</literal> from your terminal window to start
the Stub Runner server. It will be available at port <literal>8750</literal>.</simpara>
</section>
</section>
<section xml:id="_endpoints_2">
<title>Endpoints</title>
<section xml:id="_http_2">
<title>HTTP</title>
<itemizedlist>
<listitem>
<simpara>GET <literal>/stubs</literal> - returns a list of all running stubs in <literal>ivy:integer</literal> notation</simpara>
</listitem>
<listitem>
<simpara>GET <literal>/stubs/{ivy}</literal> - returns a port for the given <literal>ivy</literal> notation (when calling the endpoint <literal>ivy</literal> can also be <literal>artifactId</literal> only)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_messaging_2">
<title>Messaging</title>
<simpara>For Messaging</simpara>
<itemizedlist>
<listitem>
<simpara>GET <literal>/triggers</literal> - returns a list of all running labels in <literal>ivy : [ label1, label2 &#8230;&#8203;]</literal> notation</simpara>
</listitem>
<listitem>
<simpara>POST <literal>/triggers/{label}</literal> - executes a trigger with <literal>label</literal></simpara>
</listitem>
<listitem>
<simpara>POST <literal>/triggers/{ivy}/{label}</literal> - executes a trigger with <literal>label</literal> for the given <literal>ivy</literal> notation (when calling the endpoint <literal>ivy</literal> can also be <literal>artifactId</literal> only)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_example_2">
<title>Example</title>
<programlisting language="groovy" linenumbering="unnumbered">@ContextConfiguration(classes = StubRunnerBoot, loader = SpringBootContextLoader)
@SpringBootTest(properties = "spring.cloud.zookeeper.enabled=false")
@ActiveProfiles("test")
class StubRunnerBootSpec extends Specification {

	@Autowired StubRunning stubRunning

	def setup() {
		RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning),
				new TriggerController(stubRunning))
	}

	def 'should return a list of running stub servers in "full ivy:port" notation'() {
		when:
			String response = RestAssuredMockMvc.get('/stubs').body.asString()
		then:
			def root = new JsonSlurper().parseText(response)
			root.'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs' instanceof Integer
	}

	def 'should return a port on which a [#stubId] stub is running'() {
		when:
			def response = RestAssuredMockMvc.get("/stubs/${stubId}")
		then:
			response.statusCode == 200
			response.body.as(Integer) &gt; 0
		where:
			stubId &lt;&lt; ['org.springframework.cloud.contract.verifier.stubs:bootService:+:stubs',
					   'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs',
					   'org.springframework.cloud.contract.verifier.stubs:bootService:+',
					   'org.springframework.cloud.contract.verifier.stubs:bootService',
					   'bootService']
	}

	def 'should return 404 when missing stub was called'() {
		when:
			def response = RestAssuredMockMvc.get("/stubs/a:b:c:d")
		then:
			response.statusCode == 404
	}

	def 'should return a list of messaging labels that can be triggered when version and classifier are passed'() {
		when:
			String response = RestAssuredMockMvc.get('/triggers').body.asString()
		then:
			def root = new JsonSlurper().parseText(response)
			root.'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs'?.containsAll(["delete_book","return_book_1","return_book_2"])
	}

	def 'should trigger a messaging label'() {
		given:
			StubRunning stubRunning = Mock()
			RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning), new TriggerController(stubRunning))
		when:
			def response = RestAssuredMockMvc.post("/triggers/delete_book")
		then:
			response.statusCode == 200
		and:
			1 * stubRunning.trigger('delete_book')
	}

	def 'should trigger a messaging label for a stub with [#stubId] ivy notation'() {
		given:
			StubRunning stubRunning = Mock()
			RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning), new TriggerController(stubRunning))
		when:
			def response = RestAssuredMockMvc.post("/triggers/$stubId/delete_book")
		then:
			response.statusCode == 200
		and:
			1 * stubRunning.trigger(stubId, 'delete_book')
		where:
			stubId &lt;&lt; ['org.springframework.cloud.contract.verifier.stubs:bootService:stubs', 'org.springframework.cloud.contract.verifier.stubs:bootService', 'bootService']
	}

	def 'should throw exception when trigger is missing'() {
		when:
			RestAssuredMockMvc.post("/triggers/missing_label")
		then:
			Exception e = thrown(Exception)
			e.message.contains("Exception occurred while trying to return [missing_label] label.")
			e.message.contains("Available labels are")
			e.message.contains("org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT:stubs=[]")
			e.message.contains("org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs=")
	}

}</programlisting>
</section>
<section xml:id="_stub_runner_boot_with_service_discovery">
<title>Stub Runner Boot with Service Discovery</title>
<simpara>One of the possibilities of using Stub Runner Boot is to use it as a feed of stubs for "smoke-tests". What does it mean?
 Let&#8217;s assume that you don&#8217;t want to deploy 50 microservice to a test environment in order
 to check if your application is working fine. You&#8217;ve already executed a suite of tests during the build process
 but you would also like to ensure that the packaging of your application is fine. What you can do
 is to deploy your application to an environment, start it and run a couple of tests on it to see if
 it&#8217;s working fine. We can call those tests smoke-tests since their idea is to check only a handful
 of testing scenarios.</simpara>
<simpara>The problem with this approach is such that if you&#8217;re doing microservices most likely you&#8217;re
 using a service discovery tool. Stub Runner Boot allows you to solve this issue by starting the
 required stubs and register them in a service discovery tool. Let&#8217;s take a look at an example of
 such a setup with Eureka. Let&#8217;s assume that Eureka was already running.</simpara>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@EnableStubRunnerServer
@EnableEurekaClient
@AutoConfigureStubRunner
public class StubRunnerBootEurekaExample {

	public static void main(String[] args) {
		SpringApplication.run(StubRunnerBootEurekaExample.class, args);
	}

}</programlisting>
<simpara>As you can see we want to start a Stub Runner Boot server <literal>@EnableStubRunnerServer</literal>, enable Eureka client <literal>@EnableEurekaClient</literal>
and we want to have the stub runner feature turned on <literal>@AutoConfigureStubRunner</literal>.</simpara>
<simpara>Now let&#8217;s assume that we want to start this application so that the stubs get automatically registered.
 We can do it by running the app <literal>java -jar ${SYSTEM_PROPS} stub-runner-boot-eureka-example.jar</literal> where
 <literal>${SYSTEM_PROPS}</literal> would contain the following list of properties</simpara>
<programlisting language="bash" linenumbering="unnumbered">-Dstubrunner.repositoryRoot=https://repo.spring.io/snapshots (1)
-Dstubrunner.cloud.stubbed.discovery.enabled=false (2)
-Dstubrunner.ids=org.springframework.cloud.contract.verifier.stubs:loanIssuance,org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer,org.springframework.cloud.contract.verifier.stubs:bootService (3)
-Dstubrunner.idsToServiceIds.fraudDetectionServer=someNameThatShouldMapFraudDetectionServer (4)

(1) - we tell Stub Runner where all the stubs reside
(2) - we don't want the default behaviour where the discovery service is stubbed. That's why the stub registration will be picked
(3) - we provide a list of stubs to download
(4) - we provide a list of artifactId to serviceId mapping</programlisting>
<simpara>That way your deployed application can send requests to started WireMock servers via the service
discovery. Most likely points 1-3 could be set by default in <literal>application.yml</literal> cause they are not
likely to change. That way you can provide only the list of stubs to download whenever you start
the Stub Runner Boot.</simpara>
</section>
</section>
<section xml:id="_stubs_per_consumer">
<title>Stubs Per Consumer</title>
<simpara>There are cases in which 2 consumers of the same endpoint want to have 2 different responses.</simpara>
<tip>
<simpara>This approach also allows you to immediately know which consumer is using which part of your API.
You can remove part of a response that your API produces and you can see which of your autogenerated tests
fails. If none fails then you can safely delete that part of the response cause nobody is using it.</simpara>
</tip>
<simpara>Let&#8217;s look at the following example for contract defined for the producer called <literal>producer</literal>.
There are 2 consumers: <literal>foo-consumer</literal> and <literal>bar-consumer</literal>.</simpara>
<simpara><emphasis role="strong">Consumer <literal>foo-service</literal></emphasis></simpara>
<programlisting language="groovy" linenumbering="unnumbered">request {
   url '/foo'
   method GET()
}
response {
    status 200
    body(
       foo: "foo"
    }
}</programlisting>
<simpara><emphasis role="strong">Consumer <literal>bar-service</literal></emphasis></simpara>
<programlisting language="groovy" linenumbering="unnumbered">request {
   url '/foo'
   method GET()
}
response {
    status 200
    body(
       bar: "bar"
    }
}</programlisting>
<simpara>You can&#8217;t produce for the same request 2 different responses. That&#8217;s why you can properly package the
contracts and then profit from the <literal>stubsPerConsumer</literal> feature.</simpara>
<simpara>On the producer side the consumers can have a folder that contains contracts related only to them.
By setting the <literal>stubrunner.stubs-per-consumer</literal> flag to <literal>true</literal> we no longer register all stubs but only those that
correspond to the consumer application&#8217;s name. In other words we&#8217;ll scan the path of every stub and
if it contains the subfolder with name of the consumer in the path only then will it get registered.</simpara>
<simpara>On the <literal>foo</literal> producer side the contracts would look like this</simpara>
<programlisting language="bash" linenumbering="unnumbered">.
└── contracts
    ├── bar-consumer
    │   ├── bookReturnedForBar.groovy
    │   └── shouldCallBar.groovy
    └── foo-consumer
        ├── bookReturnedForFoo.groovy
        └── shouldCallFoo.groovy</programlisting>
<simpara>Being the <literal>bar-consumer</literal> consumer you can either set the <literal>spring.application.name</literal> or the <literal>stubrunner.consumer-name</literal> to <literal>bar-consumer</literal>
Or set the test as follows:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@ContextConfiguration(classes = Config, loader = SpringBootContextLoader)
@SpringBootTest(properties = ["spring.application.name=bar-consumer"])
@AutoConfigureStubRunner(ids = "org.springframework.cloud.contract.verifier.stubs:producerWithMultipleConsumers",
		repositoryRoot = "classpath:m2repo/repository/",
		stubsPerConsumer = true)
@DirtiesContext
class StubRunnerStubsPerConsumerSpec extends Specification {
...
}</programlisting>
<simpara>Then only the stubs registered under a path that contains the <literal>bar-consumer</literal> in its name (i.e. those from the
<literal>src/test/resources/contracts/bar-consumer/some/contracts/&#8230;&#8203;</literal> folder) will be allowed to be referenced.</simpara>
<simpara>Or set the consumer name explicitly</simpara>
<programlisting language="groovy" linenumbering="unnumbered">@ContextConfiguration(classes = Config, loader = SpringBootContextLoader)
@SpringBootTest
@AutoConfigureStubRunner(ids = "org.springframework.cloud.contract.verifier.stubs:producerWithMultipleConsumers",
		repositoryRoot = "classpath:m2repo/repository/",
		consumerName = "foo-consumer",
		stubsPerConsumer = true)
@DirtiesContext
class StubRunnerStubsPerConsumerWithConsumerNameSpec extends Specification {
...
}</programlisting>
<simpara>Then only the stubs registered under a path that contains the <literal>foo-consumer</literal> in its name (i.e. those from the
<literal>src/test/resources/contracts/foo-consumer/some/contracts/&#8230;&#8203;</literal> folder) will be allowed to be referenced.</simpara>
<simpara>You can check out <link xl:href="https://github.com/spring-cloud/spring-cloud-contract/issues/224">issue 224</link> for more
information about the reasons behind this change.</simpara>
</section>
<section xml:id="_common">
<title>Common</title>
<simpara>This section briefly describes common properties, including:</simpara>
<itemizedlist>
<listitem>
<simpara><xref linkend="common-properties-junit-spring"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="stub-runner-stub-ids"/></simpara>
</listitem>
</itemizedlist>
<section xml:id="common-properties-junit-spring">
<title>Common Properties for JUnit and Spring</title>
<simpara>You can set repetitive properties by using system properties or Spring configuration
properties. Here are their names with their default values:</simpara>
<informaltable frame="topbot" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Property name</entry>
<entry align="left" valign="top">Default value</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>stubrunner.minPort</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"><simpara>Minimum value of a port for a started WireMock with stubs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>stubrunner.maxPort</simpara></entry>
<entry align="left" valign="top"><simpara>15000</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum value of a port for a started WireMock with stubs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>stubrunner.repositoryRoot</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Maven repo URL. If blank, then call the local maven repo.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>stubrunner.classifier</simpara></entry>
<entry align="left" valign="top"><simpara>stubs</simpara></entry>
<entry align="left" valign="top"><simpara>Default classifier for the stub artifacts.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>stubrunner.workOffline</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>If true, then do not contact any remote repositories to
download stubs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>stubrunner.ids</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Array of Ivy notation stubs to download.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>stubrunner.username</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Optional username to access the tool that stores the JARs with
stubs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>stubrunner.password</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Optional password to access the tool that stores the JARs with
stubs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>stubrunner.stubsPerConsumer</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Set to <literal>true</literal> if you want to use different stubs for
each consumer instead of registering all stubs for every consumer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>stubrunner.consumerName</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>If you want to use a stub for each consumer and want to
override the consumer name just change this value.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="stub-runner-stub-ids">
<title>Stub Runner Stubs IDs</title>
<simpara>You can provide the stubs to download via the <literal>stubrunner.ids</literal> system property. They
follow this pattern:</simpara>
<programlisting language="java" linenumbering="unnumbered">groupId:artifactId:version:classifier:port</programlisting>
<simpara>Note that <literal>version</literal>, <literal>classifier</literal> and <literal>port</literal> are optional.</simpara>
<itemizedlist>
<listitem>
<simpara>If you do not provide the <literal>port</literal>, a random one will be picked.</simpara>
</listitem>
<listitem>
<simpara>If you do not provide the <literal>classifier</literal>, the default is used. (Note that you can
pass an empty classifier this way: <literal>groupId:artifactId:version:</literal>).</simpara>
</listitem>
<listitem>
<simpara>If you do not provide the <literal>version</literal>, then the <literal>+</literal> will be passed and the latest one is
downloaded.</simpara>
</listitem>
</itemizedlist>
<simpara><literal>port</literal> means the port of the WireMock server.</simpara>
<important>
<simpara>Starting with version 1.0.4, you can provide a range of versions that you
would like the Stub Runner to take into consideration. You can read more about the
<link xl:href="https://wiki.eclipse.org/Aether/New_and_Noteworthy#Version_Ranges">Aether versioning
ranges here</link>.</simpara>
</important>
</section>
</section>
<section xml:id="stubrunner-docker">
<title>Stub Runner Docker</title>
<simpara>We&#8217;re publishing a <literal>spring-cloud/spring-cloud-contract-stub-runner</literal> Docker image
that will start the standalone version of Stub Runner.</simpara>
<simpara>If you want to learn more about the basics of Maven, artifact ids,
group ids, classifiers and Artifact Managers, just click here <xref linkend="docker-project"/>.</simpara>
<section xml:id="_how_to_use_it_2">
<title>How to use it</title>
<simpara>Just execute the docker image. You can pass any of the <xref linkend="common-properties-junit-spring"/>
as environment variables. The convention is that all the
letters should be upper case. The camel case notation should
and the dot (<literal>.</literal>) should be separated via underscore (<literal>_</literal>). E.g.
 the <literal>stubrunner.repositoryRoot</literal> property should be represented
  as a <literal>STUBRUNNER_REPOSITORY_ROOT</literal> environment variable.</simpara>
</section>
<section xml:id="_example_of_client_side_usage_in_a_non_jvm_project">
<title>Example of client side usage in a non JVM project</title>
<simpara>We&#8217;d like to use the stubs created in this <xref linkend="docker-server-side"/> step.
Let&#8217;s assume that we want to run the stubs on port <literal>9876</literal>. The NodeJS code
is available here:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ git clone https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs
$ cd bookstore</programlisting>
<simpara>Let&#8217;s run the Stub Runner Boot application with the stubs.</simpara>
<programlisting language="bash" linenumbering="unnumbered"># Provide the Spring Cloud Contract Docker version
$ SC_CONTRACT_DOCKER_VERSION="..."
# The IP at which the app is running and Docker container can reach it
$ APP_IP="192.168.0.100"
# Spring Cloud Contract Stub Runner properties
$ STUBRUNNER_PORT="8083"
# Stub coordinates 'groupId:artifactId:version:classifier:port'
$ STUBRUNNER_IDS="com.example:bookstore:0.0.1.RELEASE:stubs:9876"
$ STUBRUNNER_REPOSITORY_ROOT="http://${APP_IP}:8081/artifactory/libs-release-local"
# Run the docker with Stub Runner Boot
$ docker run  --rm -e "STUBRUNNER_IDS=${STUBRUNNER_IDS}" -e "STUBRUNNER_REPOSITORY_ROOT=${STUBRUNNER_REPOSITORY_ROOT}" -p "${STUBRUNNER_PORT}:${STUBRUNNER_PORT}" -p "9876:9876" springcloud/spring-cloud-contract-stub-runner:"${SC_CONTRACT_DOCKER_VERSION}"</programlisting>
<simpara>What&#8217;s happening is that</simpara>
<itemizedlist>
<listitem>
<simpara>a standalone Stub Runner application got started</simpara>
</listitem>
<listitem>
<simpara>it downloaded the stub with coordinates <literal>com.example:bookstore:0.0.1.RELEASE:stubs</literal> on port <literal>9876</literal></simpara>
</listitem>
<listitem>
<simpara>it got downloaded from Artifactory running at <literal><link xl:href="http://192.168.0.100:8081/artifactory/libs-release-local">http://192.168.0.100:8081/artifactory/libs-release-local</link></literal></simpara>
</listitem>
<listitem>
<simpara>after a while Stub Runner will be running on port <literal>8083</literal></simpara>
</listitem>
<listitem>
<simpara>and the stubs will be running at port <literal>9876</literal></simpara>
</listitem>
</itemizedlist>
<simpara>On the server side we built a stateful stub. Let&#8217;s use curl to assert
that the stubs are setup properly.</simpara>
<programlisting language="bash" linenumbering="unnumbered"># let's execute the first request (no response is returned)
$ curl -H "Content-Type:application/json" -X POST --data '{ "title" : "Title", "genre" : "Genre", "description" : "Description", "author" : "Author", "publisher" : "Publisher", "pages" : 100, "image_url" : "https://d213dhlpdb53mu.cloudfront.net/assets/pivotal-square-logo-41418bd391196c3022f3cd9f3959b3f6d7764c47873d858583384e759c7db435.svg", "buy_url" : "https://pivotal.io" }' http://localhost:9876/api/books
# Now time for the second request
$ curl -X GET http://localhost:9876/api/books
# You will receive contents of the JSON</programlisting>
</section>
</section>
</chapter>
<chapter xml:id="_stub_runner_for_messaging">
<title>Stub Runner for Messaging</title>
<simpara>Stub Runner can run the published stubs in memory. It can integrate with the following
frameworks:</simpara>
<itemizedlist>
<listitem>
<simpara>Spring Integration</simpara>
</listitem>
<listitem>
<simpara>Spring Cloud Stream</simpara>
</listitem>
<listitem>
<simpara>Apache Camel</simpara>
</listitem>
<listitem>
<simpara>Spring AMQP</simpara>
</listitem>
</itemizedlist>
<simpara>It also provides entry points to integrate with any other solution on the market.</simpara>
<important>
<simpara>If you have multiple frameworks on the classpath Stub Runner will need to
define which one should be used. Let&#8217;s assume that you have both AMQP, Spring Cloud Stream and Spring Integration
on the classpath. Then you need to set <literal>stubrunner.stream.enabled=false</literal> and <literal>stubrunner.integration.enabled=false</literal>.
That way the only remaining framework is Spring AMQP.</simpara>
</important>
<section xml:id="_stub_triggering">
<title>Stub triggering</title>
<simpara>To trigger a message, use the <literal>StubTrigger</literal> interface:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">package org.springframework.cloud.contract.stubrunner;

import java.util.Collection;
import java.util.Map;

public interface StubTrigger {

	/**
	 * Triggers an event by a given label for a given {@code groupid:artifactid} notation. You can use only {@code artifactId} too.
	 *
	 * Feature related to messaging.
	 *
	 * @return true - if managed to run a trigger
	 */
	boolean trigger(String ivyNotation, String labelName);

	/**
	 * Triggers an event by a given label.
	 *
	 * Feature related to messaging.
	 *
	 * @return true - if managed to run a trigger
	 */
	boolean trigger(String labelName);

	/**
	 * Triggers all possible events.
	 *
	 * Feature related to messaging.
	 *
	 * @return true - if managed to run a trigger
	 */
	boolean trigger();

	/**
	 * Returns a mapping of ivy notation of a dependency to all the labels it has.
	 *
	 * Feature related to messaging.
	 */
	Map&lt;String, Collection&lt;String&gt;&gt; labels();
}</programlisting>
<simpara>For convenience, the <literal>StubFinder</literal> interface extends <literal>StubTrigger</literal>, so you only need one
or the other in your tests.</simpara>
<simpara><literal>StubTrigger</literal> gives you the following options to trigger a message:</simpara>
<itemizedlist>
<listitem>
<simpara><xref linkend="trigger-label"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="trigger-group-artifact-ids"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="trigger-artifact-ids"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="trigger-all-messages"/></simpara>
</listitem>
</itemizedlist>
<section xml:id="trigger-label">
<title>Trigger by Label</title>
<programlisting language="groovy" linenumbering="unnumbered">stubFinder.trigger('return_book_1')</programlisting>
</section>
<section xml:id="trigger-group-artifact-ids">
<title>Trigger by Group and Artifact Ids</title>
<programlisting language="groovy" linenumbering="unnumbered">stubFinder.trigger('org.springframework.cloud.contract.verifier.stubs:camelService', 'return_book_1')</programlisting>
</section>
<section xml:id="trigger-artifact-ids">
<title>Trigger by Artifact Ids</title>
<programlisting language="groovy" linenumbering="unnumbered">stubFinder.trigger('camelService', 'return_book_1')</programlisting>
</section>
<section xml:id="trigger-all-messages">
<title>Trigger All Messages</title>
<programlisting language="groovy" linenumbering="unnumbered">stubFinder.trigger()</programlisting>
</section>
</section>
<section xml:id="_stub_runner_camel">
<title>Stub Runner Camel</title>
<simpara>Spring Cloud Contract Verifier Stub Runner&#8217;s messaging module gives you an easy way to
integrate with Apache Camel. For the provided artifacts, it automatically downloads the
stubs and registers the required routes.</simpara>
<section xml:id="_adding_the_runner_to_the_project">
<title>Adding the Runner to the Project</title>
<simpara>You can have both Apache Camel and Spring Cloud Contract Stub Runner on the classpath.
Remember to annotate your test class with <literal>@AutoConfigureStubRunner</literal>.</simpara>
</section>
<section xml:id="_disabling_the_functionality">
<title>Disabling the functionality</title>
<simpara>If you need to disable this functionality, set the <literal>stubrunner.camel.enabled=false</literal>
property.</simpara>
<simpara>Assume that you have the following Maven repository with deployed stubs for the
<literal>camelService</literal> application:</simpara>
<programlisting language="bash" linenumbering="unnumbered">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── camelService
                            ├── 0.0.1-SNAPSHOT
                            │   ├── camelService-0.0.1-SNAPSHOT.pom
                            │   ├── camelService-0.0.1-SNAPSHOT-stubs.jar
                            │   └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</programlisting>
<simpara>Further assume that the stubs contain the following structure:</simpara>
<programlisting language="bash" linenumbering="unnumbered">├── META-INF
│   └── MANIFEST.MF
└── repository
    ├── accurest
    │   ├── bookDeleted.groovy
    │   ├── bookReturned1.groovy
    │   └── bookReturned2.groovy
    └── mappings</programlisting>
<simpara>Consider the following contracts (numbered <emphasis role="strong">1</emphasis>):</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Contract.make {
	label 'return_book_1'
	input {
		triggeredBy('bookReturnedTriggered()')
	}
	outputMessage {
		sentTo('jms:output')
		body('''{ "bookName" : "foo" }''')
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</programlisting>
<simpara>Now consider <emphasis role="strong">2</emphasis></simpara>
<programlisting language="groovy" linenumbering="unnumbered">Contract.make {
	label 'return_book_2'
	input {
		messageFrom('jms:input')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('jms:output')
		body([
				bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</programlisting>
<simpara>These examples lend themselves to three scenarios:</simpara>
<itemizedlist>
<listitem>
<simpara><xref linkend="camel-scenario-1"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="camel-scenario-2"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="camel-scenario-3"/></simpara>
</listitem>
</itemizedlist>
<section xml:id="camel-scenario-1">
<title>Scenario 1 (no input message)</title>
<simpara>To trigger a message via the <literal>return_book_1</literal> label, use the <literal>StubTigger</literal> interface, as
follows:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">stubFinder.trigger('return_book_1')</programlisting>
<simpara>To listen to the output of the message sent to <literal>jms:output</literal>:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Exchange receivedMessage = camelContext.createConsumerTemplate().receive('jms:output', 5000)</programlisting>
<simpara>The received message passes the following assertions:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.in.body)
receivedMessage.in.headers.get('BOOK-NAME') == 'foo'</programlisting>
</section>
<section xml:id="camel-scenario-2">
<title>Scenario 2 (output triggered by input)</title>
<simpara>Since the route is set for you, you can send a message to the <literal>jms:output</literal>
destination:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">camelContext.createProducerTemplate().sendBodyAndHeaders('jms:input', new BookReturned('foo'), [sample: 'header'])</programlisting>
<simpara>You can listen to the output of the message sent to <literal>jms:output</literal>:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Exchange receivedMessage = camelContext.createConsumerTemplate().receive('jms:output', 5000)</programlisting>
<simpara>The received message passes the following assertions:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.in.body)
receivedMessage.in.headers.get('BOOK-NAME') == 'foo'</programlisting>
</section>
<section xml:id="camel-scenario-3">
<title>Scenario 3 (input with no output)</title>
<simpara>Since the route is set for you, you can send a message to the <literal>jms:output</literal>
destination:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">camelContext.createProducerTemplate().sendBodyAndHeaders('jms:delete', new BookReturned('foo'), [sample: 'header'])</programlisting>
</section>
</section>
</section>
<section xml:id="_stub_runner_integration">
<title>Stub Runner Integration</title>
<simpara>Spring Cloud Contract Verifier Stub Runner&#8217;s messaging module gives you an easy way to
integrate with Spring Integration. For the provided artifacts, it automatically downloads
the stubs and registers the required routes.</simpara>
<section xml:id="_adding_the_runner_to_the_project_2">
<title>Adding the Runner to the Project</title>
<simpara>You can have both Spring Integration and Spring Cloud Contract Stub Runner on the
classpath. Remember to annotate your test class with <literal>@AutoConfigureStubRunner</literal>.</simpara>
</section>
<section xml:id="_disabling_the_functionality_2">
<title>Disabling the functionality</title>
<simpara>If you need to disable this functionality, set the
<literal>stubrunner.integration.enabled=false</literal> property.</simpara>
<simpara>Assume that you have the following Maven repository with deployed stubs for the
<literal>integrationService</literal> application:</simpara>
<programlisting language="bash" linenumbering="unnumbered">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── integrationService
                            ├── 0.0.1-SNAPSHOT
                            │   ├── integrationService-0.0.1-SNAPSHOT.pom
                            │   ├── integrationService-0.0.1-SNAPSHOT-stubs.jar
                            │   └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</programlisting>
<simpara>Further assume the stubs contain the following structure:</simpara>
<programlisting language="bash" linenumbering="unnumbered">├── META-INF
│   └── MANIFEST.MF
└── repository
    ├── accurest
    │   ├── bookDeleted.groovy
    │   ├── bookReturned1.groovy
    │   └── bookReturned2.groovy
    └── mappings</programlisting>
<simpara>Consider the following contracts (numbered <emphasis role="strong">1</emphasis>):</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Contract.make {
	label 'return_book_1'
	input {
		triggeredBy('bookReturnedTriggered()')
	}
	outputMessage {
		sentTo('output')
		body('''{ "bookName" : "foo" }''')
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</programlisting>
<simpara>Now consider <emphasis role="strong">2</emphasis>:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Contract.make {
	label 'return_book_2'
	input {
		messageFrom('input')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('output')
		body([
				bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</programlisting>
<simpara>and the following Spring Integration Route:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns="http://www.springframework.org/schema/integration"
			 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xmlns:beans="http://www.springframework.org/schema/beans"
			 xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/integration
			https://www.springframework.org/schema/integration/spring-integration.xsd"&gt;


	&lt;!-- REQUIRED FOR TESTING --&gt;
	&lt;bridge input-channel="output"
			output-channel="outputTest"/&gt;

	&lt;channel id="outputTest"&gt;
		&lt;queue/&gt;
	&lt;/channel&gt;

&lt;/beans:beans&gt;</programlisting>
<simpara>These examples lend themselves to three scenarios:</simpara>
<itemizedlist>
<listitem>
<simpara><xref linkend="integration-scenario-1"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="integration-scenario-2"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="integration-scenario-3"/></simpara>
</listitem>
</itemizedlist>
<section xml:id="integration-scenario-1">
<title>Scenario 1 (no input message)</title>
<simpara>To trigger a message via the <literal>return_book_1</literal> label, use the <literal>StubTigger</literal> interface, as
follows:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">stubFinder.trigger('return_book_1')</programlisting>
<simpara>To listen to the output of the message sent to <literal>output</literal>:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Message&lt;?&gt; receivedMessage = messaging.receive('outputTest')</programlisting>
<simpara>The received message would pass the following assertions:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</programlisting>
</section>
<section xml:id="integration-scenario-1">
<title>Scenario 2 (output triggered by input)</title>
<simpara>Since the route is set for you, you can send a message to the <literal>output</literal>
destination:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">messaging.send(new BookReturned('foo'), [sample: 'header'], 'input')</programlisting>
<simpara>To listen to the output of the message sent to <literal>output</literal>:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Message&lt;?&gt; receivedMessage = messaging.receive('outputTest')</programlisting>
<simpara>The received message passes the following assertions:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</programlisting>
</section>
<section xml:id="integration-scenario-3">
<title>Scenario 3 (input with no output)</title>
<simpara>Since the route is set for you, you can send a message to the <literal>input</literal> destination:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">messaging.send(new BookReturned('foo'), [sample: 'header'], 'delete')</programlisting>
</section>
</section>
</section>
<section xml:id="_stub_runner_stream">
<title>Stub Runner Stream</title>
<simpara>Spring Cloud Contract Verifier Stub Runner&#8217;s messaging module gives you an easy way to
integrate with Spring Stream. For the provided artifacts, it automatically downloads the
stubs and registers the required routes.</simpara>
<warning>
<simpara>If Stub Runner&#8217;s integration with Stream the <literal>messageFrom</literal> or <literal>sentTo</literal> Strings
are resolved first as a <literal>destination</literal> of a channel and no such <literal>destination</literal> exists, the
destination is resolved as a channel name.</simpara>
</warning>
<important>
<simpara>If you want to use Spring Cloud Stream remember, to add a dependency on
<literal>org.springframework.cloud:spring-cloud-stream-test-support</literal>.</simpara>
</important>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-stream-test-support&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">testCompile "org.springframework.cloud:spring-cloud-stream-test-support"</programlisting>
</para>
</formalpara>
<section xml:id="_adding_the_runner_to_the_project_3">
<title>Adding the Runner to the Project</title>
<simpara>You can have both Spring Cloud Stream and Spring Cloud Contract Stub Runner on the
classpath. Remember to annotate your test class with <literal>@AutoConfigureStubRunner</literal>.</simpara>
</section>
<section xml:id="_disabling_the_functionality_3">
<title>Disabling the functionality</title>
<simpara>If you need to disable this functionality, set the <literal>stubrunner.stream.enabled=false</literal>
property.</simpara>
<simpara>Assume that you have the following Maven repository with a deployed stubs for the
<literal>streamService</literal> application:</simpara>
<programlisting language="bash" linenumbering="unnumbered">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── streamService
                            ├── 0.0.1-SNAPSHOT
                            │   ├── streamService-0.0.1-SNAPSHOT.pom
                            │   ├── streamService-0.0.1-SNAPSHOT-stubs.jar
                            │   └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</programlisting>
<simpara>Further assume the stubs contain the following structure:</simpara>
<programlisting language="bash" linenumbering="unnumbered">├── META-INF
│   └── MANIFEST.MF
└── repository
    ├── accurest
    │   ├── bookDeleted.groovy
    │   ├── bookReturned1.groovy
    │   └── bookReturned2.groovy
    └── mappings</programlisting>
<simpara>Consider the following contracts (numbered <emphasis role="strong">1</emphasis>):</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Contract.make {
	label 'return_book_1'
	input { triggeredBy('bookReturnedTriggered()') }
	outputMessage {
		sentTo('returnBook')
		body('''{ "bookName" : "foo" }''')
		headers { header('BOOK-NAME', 'foo') }
	}
}</programlisting>
<simpara>Now consider <emphasis role="strong">2</emphasis>:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Contract.make {
	label 'return_book_2'
	input {
		messageFrom('bookStorage')
		messageBody([
			bookName: 'foo'
		])
		messageHeaders { header('sample', 'header') }
	}
	outputMessage {
		sentTo('returnBook')
		body([
			bookName: 'foo'
		])
		headers { header('BOOK-NAME', 'foo') }
	}
}</programlisting>
<simpara>Now consider the following Spring configuration:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">stubrunner.repositoryRoot: classpath:m2repo/repository/
stubrunner.ids: org.springframework.cloud.contract.verifier.stubs:streamService:0.0.1-SNAPSHOT:stubs

spring:
  cloud:
    stream:
      bindings:
        output:
          destination: returnBook
        input:
          destination: bookStorage

server:
  port: 0

debug: true</programlisting>
<simpara>These examples lend themselves to three scenarios:</simpara>
<itemizedlist>
<listitem>
<simpara><xref linkend="stream-scenario-1"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="stream-scenario-2"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="stream-scenario-3"/></simpara>
</listitem>
</itemizedlist>
<section xml:id="stream-scenario-1">
<title>Scenario 1 (no input message)</title>
<simpara>To trigger a message via the <literal>return_book_1</literal> label, use the <literal>StubTrigger</literal> interface as
follows:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">stubFinder.trigger('return_book_1')</programlisting>
<simpara>To listen to the output of the message sent to a channel whose <literal>destination</literal> is
<literal>returnBook</literal>:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Message&lt;?&gt; receivedMessage = messaging.receive('returnBook')</programlisting>
<simpara>The received message passes the following assertions:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</programlisting>
</section>
<section xml:id="stream-scenario-2">
<title>Scenario 2 (output triggered by input)</title>
<simpara>Since the route is set for you, you can send a message to the <literal>bookStorage</literal>
<literal>destination</literal>:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">messaging.send(new BookReturned('foo'), [sample: 'header'], 'bookStorage')</programlisting>
<simpara>To listen to the output of the message sent to <literal>returnBook</literal>:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Message&lt;?&gt; receivedMessage = messaging.receive('returnBook')</programlisting>
<simpara>The received message passes the following assertions:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</programlisting>
</section>
<section xml:id="stream-scenario-3">
<title>Scenario 3 (input with no output)</title>
<simpara>Since the route is set for you, you can send a message to the <literal>output</literal>
destination:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">messaging.send(new BookReturned('foo'), [sample: 'header'], 'delete')</programlisting>
</section>
</section>
</section>
<section xml:id="_stub_runner_spring_amqp">
<title>Stub Runner Spring AMQP</title>
<simpara>Spring Cloud Contract Verifier Stub Runner&#8217;s messaging module provides an easy way to
integrate with Spring AMQP&#8217;s Rabbit Template. For the provided artifacts, it
automatically downloads the stubs and registers the required routes.</simpara>
<simpara>The integration tries to work standalone (that is, without interaction with a running
RabbitMQ message broker). It expects a <literal>RabbitTemplate</literal> on the application context and
uses it as a spring boot test named <literal>@SpyBean</literal>. As a result, it can use the mockito spy
functionality to verify and inspect messages sent by the application.</simpara>
<simpara>On the message consumer side, the stub runner considers all <literal>@RabbitListener</literal> annotated
endpoints and all <literal>SimpleMessageListenerContainer</literal> objects on the application context.</simpara>
<simpara>As messages are usually sent to exchanges in AMQP, the message contract contains the
exchange name as the destination. Message listeners on the other side are bound to
queues. Bindings connect an exchange to a queue. If message contracts are triggered, the
Spring AMQP stub runner integration looks for bindings on the application context that
match this exchange. Then it collects the queues from the Spring exchanges and tries to
find message listeners bound to these queues. The message is triggered for all matching
message listeners.</simpara>
<section xml:id="_adding_the_runner_to_the_project_4">
<title>Adding the Runner to the Project</title>
<simpara>You can have both Spring AMQP and Spring Cloud Contract Stub Runner on the classpath and
set the property <literal>stubrunner.amqp.enabled=true</literal>. Remember to annotate your test class
with <literal>@AutoConfigureStubRunner</literal>.</simpara>
<important>
<simpara>If you already have Stream and Integration on the classpath, you need
to disable them explicitly by setting the  <literal>stubrunner.stream.enabled=false</literal> and
<literal>stubrunner.integration.enabled=false</literal> properties.</simpara>
</important>
<simpara>Assume that you have the following Maven repository with a deployed stubs for the
<literal>spring-cloud-contract-amqp-test</literal> application.</simpara>
<programlisting language="bash" linenumbering="unnumbered">└── .m2
    └── repository
        └── com
            └── example
                └── spring-cloud-contract-amqp-test
                    ├── 0.4.0-SNAPSHOT
                    │   ├── spring-cloud-contract-amqp-test-0.4.0-SNAPSHOT.pom
                    │   ├── spring-cloud-contract-amqp-test-0.4.0-SNAPSHOT-stubs.jar
                    │   └── maven-metadata-local.xml
                    └── maven-metadata-local.xml</programlisting>
<simpara>Further assume that the stubs contain the following structure:</simpara>
<programlisting language="bash" linenumbering="unnumbered">├── META-INF
│   └── MANIFEST.MF
└── contracts
    └── shouldProduceValidPersonData.groovy</programlisting>
<simpara>Consider the following contract:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Contract.make {
    // Human readable description
    description 'Should produce valid person data'
    // Label by means of which the output message can be triggered
    label 'contract-test.person.created.event'
    // input to the contract
    input {
        // the contract will be triggered by a method
        triggeredBy('createPerson()')
    }
    // output message of the contract
    outputMessage {
        // destination to which the output message will be sent
        sentTo 'contract-test.exchange'
        headers {
            header('contentType': 'application/json')
            header('__TypeId__': 'org.springframework.cloud.contract.stubrunner.messaging.amqp.Person')
        }
        // the body of the output message
        body ([
                id: $(consumer(9), producer(regex("[0-9]+"))),
                name: "me"
        ])
    }
}</programlisting>
<simpara>Now consider the following Spring configuration:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">stubrunner:
  repositoryRoot: classpath:m2repo/repository/
  ids: org.springframework.cloud.contract.verifier.stubs.amqp:spring-cloud-contract-amqp-test:0.4.0-SNAPSHOT:stubs
  amqp:
    enabled: true
server:
  port: 0</programlisting>
<section xml:id="_triggering_the_message">
<title>Triggering the message</title>
<simpara>To trigger a message using the contract above, use the <literal>StubTrigger</literal> interface as
follows:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">stubTrigger.trigger("contract-test.person.created.event")</programlisting>
<simpara>The message has a destination of <literal>contract-test.exchange</literal>, so the Spring AMQP stub runner
integration looks for bindings related to this exchange.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bean
public Binding binding() {
	return BindingBuilder.bind(new Queue("test.queue")).to(new DirectExchange("contract-test.exchange")).with("#");
}</programlisting>
<simpara>The binding definition binds the queue <literal>test.queue</literal>. As a result, the following listener
definition is matched and invoked with the contract message.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bean
public SimpleMessageListenerContainer simpleMessageListenerContainer(ConnectionFactory connectionFactory,
																		MessageListenerAdapter listenerAdapter) {
	SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
	container.setConnectionFactory(connectionFactory);
	container.setQueueNames("test.queue");
	container.setMessageListener(listenerAdapter);

	return container;
}</programlisting>
<simpara>Also, the following annotated listener matches and is invoked:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RabbitListener(bindings = @QueueBinding(
		value = @Queue(value = "test.queue"),
		exchange = @Exchange(value = "contract-test.exchange", ignoreDeclarationExceptions = "true")))
public void handlePerson(Person person) {
	this.person = person;
}</programlisting>
<note>
<simpara>The message is directly handed over to the <literal>onMessage</literal> method of the
<literal>MessageListener</literal> associated with the matching <literal>SimpleMessageListenerContainer</literal>.</simpara>
</note>
</section>
<section xml:id="_spring_amqp_test_configuration">
<title>Spring AMQP Test Configuration</title>
<simpara>In order to avoid Spring AMQP trying to connect to a running broker during our tests
configure a mock <literal>ConnectionFactory</literal>.</simpara>
<simpara>To disable the mocked ConnectionFactory, set the following property:
<literal>stubrunner.amqp.mockConnection=false</literal></simpara>
<programlisting language="yaml" linenumbering="unnumbered">stubrunner:
  amqp:
    mockConnection: false</programlisting>
</section>
</section>
</section>
</chapter>
<chapter xml:id="_contract_dsl">
<title>Contract DSL</title>
<simpara>Spring Cloud Contract supports out of the box 2 types of DSL. One written in
<literal>Groovy</literal> and one written in <literal>YAML</literal>.</simpara>
<simpara>If you decide to write the contract in Groovy, do not be alarmed if you have not used Groovy
before. Knowledge of the language is not really needed, as the Contract DSL uses only a
tiny subset of it (only literals, method calls and closures). Also, the DSL is statically
typed, to make it programmer-readable without any knowledge of the DSL itself.</simpara>
<important>
<simpara>Remember that, inside the Groovy contract file, you have to provide the fully
qualified name to the <literal>Contract</literal> class and <literal>make</literal> static imports, such as
<literal>org.springframework.cloud.spec.Contract.make { &#8230;&#8203; }</literal>. You can also provide an import to
the <literal>Contract</literal> class: <literal>import org.springframework.cloud.spec.Contract</literal> and then call
<literal>Contract.make { &#8230;&#8203; }</literal>.</simpara>
</important>
<tip>
<simpara>Spring Cloud Contract supports defining multiple contracts in a single file.</simpara>
</tip>
<simpara>The following is a complete example of a Groovy contract definition:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'PUT'
		url '/api/12'
		headers {
			header 'Content-Type': 'application/vnd.org.springframework.cloud.contract.verifier.twitter-places-analyzer.v1+json'
		}
		body '''\
		[{
			"created_at": "Sat Jul 26 09:38:57 +0000 2014",
			"id": 492967299297845248,
			"id_str": "492967299297845248",
			"text": "Gonna see you at Warsaw",
			"place":
			{
				"attributes":{},
				"bounding_box":
				{
					"coordinates":
						[[
							[-77.119759,38.791645],
							[-76.909393,38.791645],
							[-76.909393,38.995548],
							[-77.119759,38.995548]
						]],
					"type":"Polygon"
				},
				"country":"United States",
				"country_code":"US",
				"full_name":"Washington, DC",
				"id":"01fbe706f872cb32",
				"name":"Washington",
				"place_type":"city",
				"url": "https://api.twitter.com/1/geo/id/01fbe706f872cb32.json"
			}
		}]
	'''
	}
	response {
		status 200
	}
}</programlisting>
<simpara>The following is a complete example of a YAML contract definition:</simpara>
<programlisting language="yml" linenumbering="unnumbered">description: Some description
name: some name
priority: 8
ignored: true
request:
  url: /foo
  queryParameters:
    a: b
    b: c
  method: PUT
  headers:
    foo: bar
    fooReq: baz
  body:
    foo: bar
  matchers:
    body:
      - path: $.foo
        type: by_regex
        value: bar
    headers:
      - key: foo
        regex: bar
response:
  status: 200
  headers:
    foo2: bar
    foo3: foo33
    fooRes: baz
  body:
    foo2: bar
    foo3: baz
  matchers:
    body:
      - path: $.foo2
        type: by_regex
        value: bar
      - path: $.foo3
        type: by_command
        value: executeMe($it)
    headers:
      - key: foo2
        regex: bar
      - key: foo3
        command: andMeToo($it)</programlisting>
<tip>
<simpara>You can compile contracts to stubs mapping using standalone maven command:
<literal>mvn org.springframework.cloud:spring-cloud-contract-maven-plugin:convert</literal></simpara>
</tip>
<section xml:id="_limitations_2">
<title>Limitations</title>
<warning>
<simpara>Spring Cloud Contract Verifier does not properly support XML. Please use JSON or
help us implement this feature.</simpara>
</warning>
<warning>
<simpara>The support for verifying the size of JSON arrays is experimental. If you want
to turn it on, please set the value of the following system property to <literal>true</literal>:
<literal>spring.cloud.contract.verifier.assert.size</literal>. By default, this feature is set to <literal>false</literal>.
You can also provide the <literal>assertJsonSize</literal> property in the plugin configuration.</simpara>
</warning>
<warning>
<simpara>Because JSON structure can have any form, it can be impossible to parse it
properly when using the Groovy DSL and the <literal>value(consumer(&#8230;&#8203;), producer(&#8230;&#8203;))</literal> notation in <literal>GString</literal>. That
is why you should use the Groovy Map notation.</simpara>
</warning>
</section>
<section xml:id="_common_top_level_elements">
<title>Common Top-Level elements</title>
<simpara>The following sections describe the most common top-level elements:</simpara>
<itemizedlist>
<listitem>
<simpara><xref linkend="contract-dsl-description"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="contract-dsl-name"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="contract-dsl-ignoring-contracts"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="contract-dsl-passing-values-from-files"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="contract-dsl-http-top-level-elements"/></simpara>
</listitem>
</itemizedlist>
<section xml:id="contract-dsl-description">
<title>Description</title>
<simpara>You can add a <literal>description</literal> to your contract. The description is arbitrary text. The
following code shows an example:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">		org.springframework.cloud.contract.spec.Contract.make {
			description('''
given:
	An input
when:
	Sth happens
then:
	Output
''')
		}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">description: Some description
name: some name
priority: 8
ignored: true
request:
  url: /foo
  queryParameters:
    a: b
    b: c
  method: PUT
  headers:
    foo: bar
    fooReq: baz
  body:
    foo: bar
  matchers:
    body:
      - path: $.foo
        type: by_regex
        value: bar
    headers:
      - key: foo
        regex: bar
response:
  status: 200
  headers:
    foo2: bar
    foo3: foo33
    fooRes: baz
  body:
    foo2: bar
    foo3: baz
  matchers:
    body:
      - path: $.foo2
        type: by_regex
        value: bar
      - path: $.foo3
        type: by_command
        value: executeMe($it)
    headers:
      - key: foo2
        regex: bar
      - key: foo3
        command: andMeToo($it)</programlisting>
</para>
</formalpara>
</section>
<section xml:id="contract-dsl-name">
<title>Name</title>
<simpara>You can provide a name for your contract. Assume that you provided the following name:
<literal>should register a user</literal>. If you do so, the name of the autogenerated test is
<literal>validate_should_register_a_user</literal>. Also, the name of the stub in a WireMock stub is
<literal>should_register_a_user.json</literal>.</simpara>
<important>
<simpara>You must ensure that the name does not contain any characters that make the
generated test not compile. Also, remember that, if you provide the same name for
multiple contracts, your autogenerated tests fail to compile and your generated stubs
override each other.</simpara>
</important>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	name("some_special_name")
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">name: some name</programlisting>
</para>
</formalpara>
</section>
<section xml:id="contract-dsl-ignoring-contracts">
<title>Ignoring Contracts</title>
<simpara>If you want to ignore a contract, you can either set a value of ignored contracts in the
plugin configuration or set the <literal>ignored</literal> property on the contract itself:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	ignored()
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">ignored: true</programlisting>
</para>
</formalpara>
</section>
<section xml:id="contract-dsl-passing-values-from-files">
<title>Passing Values from Files</title>
<simpara>Starting with version <literal>1.2.0</literal>, you can pass values from files. Assume that you have the
following resources in our project.</simpara>
<programlisting language="bash" linenumbering="unnumbered">└── src
    └── test
        └── resources
            └── contracts
                ├── readFromFile.groovy
                ├── request.json
                └── response.json</programlisting>
<simpara>Further assume that your contract is as follows:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">import org.springframework.cloud.contract.spec.Contract

Contract.make {
	request {
		method('PUT')
		headers {
			contentType(applicationJson())
		}
		body(file("request.json"))
		url("/1")
	}
	response {
		status 200
		body(file("response.json"))
		headers {
			contentType(textPlain())
		}
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">request:
  method: GET
  url: /foo
  bodyFromFile: request.json
response:
  status: 200
  bodyFromFile: response.json</programlisting>
</para>
</formalpara>
<simpara>Further assume that the JSON files is as follows:</simpara>
<simpara><emphasis role="strong">request.json</emphasis></simpara>
<programlisting language="json" linenumbering="unnumbered">{ "status" : "REQUEST" }</programlisting>
<simpara><emphasis role="strong">response.json</emphasis></simpara>
<programlisting language="json" linenumbering="unnumbered">{ "status" : "RESPONSE" }</programlisting>
<simpara>When test or stub generation takes place, the contents of the file is passed to the body
of a request or a response. The name of the file needs to be a file with location
relative to the folder in which the contract lays.</simpara>
</section>
<section xml:id="contract-dsl-http-top-level-elements">
<title>HTTP Top-Level Elements</title>
<simpara>The following methods can be called in the top-level closure of a contract definition.
<literal>request</literal> and <literal>response</literal> are mandatory. <literal>priority</literal> is optional.</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	// Definition of HTTP request part of the contract
	// (this can be a valid request or invalid depending
	// on type of contract being specified).
	request {
		//...
	}

	// Definition of HTTP response part of the contract
	// (a service implementing this contract should respond
	// with following response after receiving request
	// specified in "request" part above).
	response {
		//...
	}

	// Contract priority, which can be used for overriding
	// contracts (1 is highest). Priority is optional.
	priority 1
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">priority: 8
request:
...
response:
...</programlisting>
</para>
</formalpara>
<important>
<simpara>If you want to make your contract have a <emphasis role="strong">higher</emphasis> value of priority
you need to pass a <emphasis role="strong">lower</emphasis> number to the <literal>priority</literal> tag / method. E.g. <literal>priority</literal> with
value <literal>5</literal> has <emphasis role="strong">higher</emphasis> priority than <literal>priority</literal> with value <literal>10</literal>.</simpara>
</important>
</section>
</section>
<section xml:id="_request">
<title>Request</title>
<simpara>The HTTP protocol requires only <emphasis role="strong">method and url</emphasis> to be specified in a request. The
same information is mandatory in request definition of the Contract.</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	request {
		// HTTP request method (GET/POST/PUT/DELETE).
		method 'GET'

		// Path component of request URL is specified as follows.
		urlPath('/users')
	}

	response {
		//...
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">method: PUT
url: /foo</programlisting>
</para>
</formalpara>
<simpara>It is possible to specify an absolute rather than relative <literal>url</literal>, but using <literal>urlPath</literal> is
the recommended way, as doing so makes the tests <emphasis role="strong">host-independent</emphasis>.</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'GET'

		// Specifying `url` and `urlPath` in one contract is illegal.
		url('http://localhost:8888/users')
	}

	response {
		//...
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">request:
  method: PUT
  urlPath: /foo</programlisting>
</para>
</formalpara>
<simpara><literal>request</literal> may contain <emphasis role="strong">query parameters</emphasis>.</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...

		urlPath('/users') {

			// Each parameter is specified in form
			// `'paramName' : paramValue` where parameter value
			// may be a simple literal or one of matcher functions,
			// all of which are used in this example.
			queryParameters {

				// If a simple literal is used as value
				// default matcher function is used (equalTo)
				parameter 'limit': 100

				// `equalTo` function simply compares passed value
				// using identity operator (==).
				parameter 'filter': equalTo("email")

				// `containing` function matches strings
				// that contains passed substring.
				parameter 'gender': value(consumer(containing("[mf]")), producer('mf'))

				// `matching` function tests parameter
				// against passed regular expression.
				parameter 'offset': value(consumer(matching("[0-9]+")), producer(123))

				// `notMatching` functions tests if parameter
				// does not match passed regular expression.
				parameter 'loginStartsWith': value(consumer(notMatching(".{0,2}")), producer(3))
			}
		}

		//...
	}

	response {
		//...
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">request:
...
  queryParameters:
    a: b
    b: c
  headers:
    foo: bar
    fooReq: baz
  body:
    foo: bar
  matchers:
    body:
      - path: $.foo
        type: by_regex
        value: bar
    headers:
      - key: foo
        regex: bar
response:
  status: 200
  headers:
    foo2: bar
    foo3: foo33
    fooRes: baz
  body:
    foo2: bar
    foo3: baz
  matchers:
    body:
      - path: $.foo2
        type: by_regex
        value: bar
      - path: $.foo3
        type: by_command
        value: executeMe($it)
    headers:
      - key: foo2
        regex: bar
      - key: foo3
        command: andMeToo($it)</programlisting>
</para>
</formalpara>
<simpara><literal>request</literal> may contain additional <emphasis role="strong">request headers</emphasis>, as shown in the following example:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...

		// Each header is added in form `'Header-Name' : 'Header-Value'`.
		// there are also some helper methods
		headers {
			header 'key': 'value'
			contentType(applicationJson())
		}

		//...
	}

	response {
		//...
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">request:
...
headers:
  foo: bar
  fooReq: baz</programlisting>
</para>
</formalpara>
<simpara><literal>request</literal> may contain a <emphasis role="strong">request body</emphasis>:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...

		// Currently only JSON format of request body is supported.
		// Format will be determined from a header or body's content.
		body '''{ "login" : "john", "name": "John The Contract" }'''
	}

	response {
		//...
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">request:
...
body:
  foo: bar</programlisting>
</para>
</formalpara>
<simpara><literal>request</literal> may contain <emphasis role="strong">multipart</emphasis> elements. To include multipart elements, use the
<literal>multipart</literal> method/section, as shown in the following examples</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract contractDsl = org.springframework.cloud.contract.spec.Contract.make {
	request {
		method "PUT"
		url "/multipart"
		headers {
			contentType('multipart/form-data;boundary=AaB03x')
		}
		multipart(
				// key (parameter name), value (parameter value) pair
				formParameter: $(c(regex('".+"')), p('"formParameterValue"')),
				someBooleanParameter: $(c(regex(anyBoolean())), p('true')),
				// a named parameter (e.g. with `file` name) that represents file with
				// `name` and `content`. You can also call `named("fileName", "fileContent")`
				file: named(
						// name of the file
						name: $(c(regex(nonEmpty())), p('filename.csv')),
						// content of the file
						content: $(c(regex(nonEmpty())), p('file content')))
		)
	}
	response {
		status 200
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">request:
  method: PUT
  url: /multipart
  headers:
    Content-Type: multipart/form-data;boundary=AaB03x
  multipart:
    params:
    # key (parameter name), value (parameter value) pair
      formParameter: '"formParameterValue"'
      someBooleanParameter: true
    named:
      - paramName: file
        fileName: filename.csv
        fileContent: file content
  matchers:
    multipart:
      params:
        - key: formParameter
          regex: ".+"
        - key: someBooleanParameter
          predefined: any_boolean
      named:
        - paramName: file
          fileName:
            predefined: non_empty
          fileContent:
            predefined: non_empty
response:
  status: 200</programlisting>
</para>
</formalpara>
<simpara>In the preceding example, we define parameters in either of two ways:</simpara>
<itemizedlist>
<title>Groovy DSL</title>
<listitem>
<simpara>Directly, by using the map notation, where the value can be a dynamic property (such as
<literal>formParameter: $(consumer(&#8230;&#8203;), producer(&#8230;&#8203;))</literal>).</simpara>
</listitem>
<listitem>
<simpara>By using the <literal>named(&#8230;&#8203;)</literal> method that lets you set a named parameter. A named parameter
can set a <literal>name</literal> and <literal>content</literal>. You can call it either via a method with two  arguments,
such as <literal>named("fileName", "fileContent")</literal>, or via a map notation, such as
<literal>named(name: "fileName", content: "fileContent")</literal>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>YAML</title>
<listitem>
<simpara>The multipart parameters are set via <literal>multipart.params</literal> section</simpara>
</listitem>
<listitem>
<simpara>The named parameters (the <literal>fileName</literal> and <literal>fileContent</literal> for a given parameter name)
can be set via the <literal>multipart.named</literal> section. That section contains
the <literal>paramName</literal> (name of the parameter), <literal>fileName</literal> (name of the file),
<literal>fileContent</literal> (content of the file) fields</simpara>
</listitem>
<listitem>
<simpara>The dynamic bits can be set via the <literal>matchers.multipart</literal> section</simpara>
<itemizedlist>
<listitem>
<simpara>for parameters use the <literal>params</literal> section that can accept
<literal>regex</literal> or a <literal>predefined</literal> regular expression</simpara>
</listitem>
<listitem>
<simpara>for named params use the <literal>named</literal> section where first you
define the parameter name via <literal>paramName</literal> and then you can pass the
parametrization of either <literal>fileName</literal> or <literal>fileContent</literal> via
<literal>regex</literal> or a <literal>predefined</literal> regular expression</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>From this contract, the generated test is as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">// given:
 MockMvcRequestSpecification request = given()
   .header("Content-Type", "multipart/form-data;boundary=AaB03x")
   .param("formParameter", "\"formParameterValue\"")
   .param("someBooleanParameter", "true")
   .multiPart("file", "filename.csv", "file content".getBytes());

// when:
 ResponseOptions response = given().spec(request)
   .put("/multipart");

// then:
 assertThat(response.statusCode()).isEqualTo(200);</programlisting>
<simpara>The WireMock stub is as follows:</simpara>
<programlisting language="json" linenumbering="unnumbered">			'''
{
  "request" : {
	"url" : "/multipart",
	"method" : "PUT",
	"headers" : {
	  "Content-Type" : {
		"matches" : "multipart/form-data;boundary=AaB03x.*"
	  }
	},
	"bodyPatterns" : [ {
		"matches" : ".*--(.*)\\r\\nContent-Disposition: form-data; name=\\"formParameter\\"\\r\\n(Content-Type: .*\\r\\n)?(Content-Length: \\\\d+\\r\\n)?\\r\\n\\".+\\"\\r\\n--\\\\1.*"
  		}, {
    			"matches" : ".*--(.*)\\r\\nContent-Disposition: form-data; name=\\"someBooleanParameter\\"\\r\\n(Content-Type: .*\\r\\n)?(Content-Length: \\\\d+\\r\\n)?\\r\\n(true|false)\\r\\n--\\\\1.*"
  		}, {
	  "matches" : ".*--(.*)\\r\\nContent-Disposition: form-data; name=\\"file\\"; filename=\\"[\\\\S\\\\s]+\\"\\r\\n(Content-Type: .*\\r\\n)?(Content-Length: \\\\d+\\r\\n)?\\r\\n[\\\\S\\\\s]+\\r\\n--\\\\1.*"
	} ]
  },
  "response" : {
	"status" : 200,
	"transformers" : [ "response-template", "foo-transformer" ]
  }
}
	'''</programlisting>
</section>
<section xml:id="_response">
<title>Response</title>
<simpara>The response must contain an <emphasis role="strong">HTTP status code</emphasis> and may contain other information. The
following code shows an example:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...
	}
	response {
		// Status code sent by the server
		// in response to request specified above.
		status 200
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">response:
...
status: 200</programlisting>
</para>
</formalpara>
<simpara>Besides status, the response may contain <emphasis role="strong">headers</emphasis> and a <emphasis role="strong">body</emphasis>, both of which are
specified the same way as in the request (see the previous paragraph).</simpara>
</section>
<section xml:id="_dynamic_properties">
<title>Dynamic properties</title>
<simpara>The contract can contain some dynamic properties: timestamps, IDs, and so on. You do not
want to force the consumers to stub their clocks to always return the same value of time
so that it gets matched by the stub.</simpara>
<simpara>For Groovy DSL you can provide the dynamic parts in your contracts
in two ways: pass them directly in the body or set them in separate sections called
<literal>testMatchers</literal> and <literal>stubMatchers</literal>.</simpara>
<simpara>For YAML you can only use the <literal>matchers</literal> section.</simpara>
<section xml:id="_dynamic_properties_inside_the_body">
<title>Dynamic properties inside the body</title>
<important>
<simpara>This section is valid only for Groovy DSL. Check out the
<xref linkend="contract-matchers"/> section for YAML examples of a similar feature.</simpara>
</important>
<simpara>You can set the properties inside the body either with the <literal>value</literal> method or, if you use
the Groovy map notation, with <literal>$()</literal>. The following example shows how to set dynamic
properties with the value method:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">value(consumer(...), producer(...))
value(c(...), p(...))
value(stub(...), test(...))
value(client(...), server(...))</programlisting>
<simpara>The following example shows how to set dynamic properties with <literal>$()</literal>:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">$(consumer(...), producer(...))
$(c(...), p(...))
$(stub(...), test(...))
$(client(...), server(...))</programlisting>
<simpara>Both approaches work equally well. <literal>stub</literal> and <literal>client</literal> methods are aliases over the <literal>consumer</literal>
method. Subsequent sections take a closer look at what you can do with those values.</simpara>
</section>
<section xml:id="_regular_expressions">
<title>Regular expressions</title>
<important>
<simpara>This section is valid only for Groovy DSL. Check out the
<xref linkend="contract-matchers"/> section for YAML examples of a similar feature.</simpara>
</important>
<simpara>You can use regular expressions to write your requests in Contract DSL. Doing so is
particularly useful when you want to indicate that a given response should be provided
for requests that follow a given pattern. Also, you can use regular expressions when you
need to use patterns and not exact values both for your test and your server side tests.</simpara>
<simpara>The following example shows how to use regular expressions to write a request:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method('GET')
		url $(consumer(~/\/[0-9]{2}/), producer('/12'))
	}
	response {
		status 200
		body(
				id: $(anyNumber()),
				surname: $(
						consumer('Kowalsky'),
						producer(regex('[a-zA-Z]+'))
				),
				name: 'Jan',
				created: $(consumer('2014-02-02 12:23:43'), producer(execute('currentDate(it)'))),
				correlationId: value(consumer('5d1f9fef-e0dc-4f3d-a7e4-72d2220dd827'),
						producer(regex('[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'))
				)
		)
		headers {
			header 'Content-Type': 'text/plain'
		}
	}
}</programlisting>
<simpara>You can also provide only one side of the communication with a regular expression. If you
do so, then the contract engine automatically provides the generated string that matches
the provided regular expression. The following code shows an example:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'PUT'
		url value(consumer(regex('/foo/[0-9]{5}')))
		body([
			requestElement: $(consumer(regex('[0-9]{5}')))
		])
		headers {
			header('header', $(consumer(regex('application\\/vnd\\.fraud\\.v1\\+json;.*'))))
		}
	}
	response {
		status 200
		body([
			responseElement: $(producer(regex('[0-9]{7}')))
		])
		headers {
			contentType("application/vnd.fraud.v1+json")
		}
	}
}</programlisting>
<simpara>In the preceding example, the opposite side of the communication has the respective data
generated for request and response.</simpara>
<simpara>Spring Cloud Contract comes with a series of predefined regular expressions that you can
use in your contracts, as shown in the following example:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">protected static final Pattern TRUE_OR_FALSE = Pattern.compile(/(true|false)/)
protected static final Pattern ONLY_ALPHA_UNICODE = Pattern.compile(/[\p{L}]*/)
protected static final Pattern NUMBER = Pattern.compile('-?(\\d*\\.\\d+|\\d+)')
protected static final Pattern IP_ADDRESS = Pattern.compile('([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])')
protected static final Pattern HOSTNAME_PATTERN = Pattern.compile('((http[s]?|ftp):/)/?([^:/\\s]+)(:[0-9]{1,5})?')
protected static final Pattern EMAIL = Pattern.compile('[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}')
protected static final Pattern URL = UrlHelper.URL
protected static final Pattern UUID = Pattern.compile('[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}')
protected static final Pattern ANY_DATE = Pattern.compile('(\\d\\d\\d\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])')
protected static final Pattern ANY_DATE_TIME = Pattern.compile('([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])')
protected static final Pattern ANY_TIME = Pattern.compile('(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])')
protected static final Pattern NON_EMPTY = Pattern.compile(/[\S\s]+/)
protected static final Pattern NON_BLANK = Pattern.compile(/^\s*\S[\S\s]*/)
protected static final Pattern ISO8601_WITH_OFFSET = Pattern.compile(/([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.\d{3})?(Z|[+-][01]\d:[0-5]\d)/)

protected static Pattern anyOf(String... values){
	return Pattern.compile(values.collect({"^$it\$"}).join("|"))
}

String onlyAlphaUnicode() {
	return ONLY_ALPHA_UNICODE.pattern()
}

String number() {
	return NUMBER.pattern()
}

String anyBoolean() {
	return TRUE_OR_FALSE.pattern()
}

String ipAddress() {
	return IP_ADDRESS.pattern()
}

String hostname() {
	return HOSTNAME_PATTERN.pattern()
}

String email() {
	return EMAIL.pattern()
}

String url() {
	return URL.pattern()
}

String uuid(){
	return UUID.pattern()
}

String isoDate() {
	return ANY_DATE.pattern()
}

String isoDateTime() {
	return ANY_DATE_TIME.pattern()
}

String isoTime() {
	return ANY_TIME.pattern()
}

String iso8601WithOffset() {
	return ISO8601_WITH_OFFSET.pattern()
}

String nonEmpty() {
	return NON_EMPTY.pattern()
}

String nonBlank() {
	return NON_BLANK.pattern()
}</programlisting>
<simpara>In your contract, you can use it as shown in the following example:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Contract dslWithOptionalsInString = Contract.make {
	priority 1
	request {
		method POST()
		url '/users/password'
		headers {
			contentType(applicationJson())
		}
		body(
				email: $(consumer(optional(regex(email()))), producer('abc@abc.com')),
				callback_url: $(consumer(regex(hostname())), producer('http://partners.com'))
		)
	}
	response {
		status 404
		headers {
			contentType(applicationJson())
		}
		body(
				code: value(consumer("123123"), producer(optional("123123"))),
				message: "User not found by email = [${value(producer(regex(email())), consumer('not.existing@user.com'))}]"
		)
	}
}</programlisting>
</section>
<section xml:id="_passing_optional_parameters">
<title>Passing Optional Parameters</title>
<important>
<simpara>This section is valid only for Groovy DSL. Check out the
<xref linkend="contract-matchers"/> section for YAML examples of a similar feature.</simpara>
</important>
<simpara>It is possible to provide optional parameters in your contract. However, you can provide
optional parameters only for the following:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>STUB</emphasis> side of the Request</simpara>
</listitem>
<listitem>
<simpara><emphasis>TEST</emphasis> side of the Response</simpara>
</listitem>
</itemizedlist>
<simpara>The following example shows how to provide optional parameters:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	priority 1
	request {
		method 'POST'
		url '/users/password'
		headers {
			contentType(applicationJson())
		}
		body(
				email: $(consumer(optional(regex(email()))), producer('abc@abc.com')),
				callback_url: $(consumer(regex(hostname())), producer('http://partners.com'))
		)
	}
	response {
		status 404
		headers {
			header 'Content-Type': 'application/json'
		}
		body(
				code: value(consumer("123123"), producer(optional("123123")))
		)
	}
}</programlisting>
<simpara>By wrapping a part of the body with the <literal>optional()</literal> method, you create a regular
expression that must be present 0 or more times.</simpara>
<simpara>If you use Spock for, the following test would be generated from the previous example:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">"""
 given:
  def request = given()
    .header("Content-Type", "application/json")
    .body('''{"email":"abc@abc.com","callback_url":"http://partners.com"}''')

 when:
  def response = given().spec(request)
    .post("/users/password")

 then:
  response.statusCode == 404
  response.header('Content-Type')  == 'application/json'
 and:
  DocumentContext parsedJson = JsonPath.parse(response.body.asString())
  assertThatJson(parsedJson).field("['code']").matches("(123123)?")
"""</programlisting>
<simpara>The following stub would also be generated:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">'''
{
  "request" : {
	"url" : "/users/password",
	"method" : "POST",
	"bodyPatterns" : [ {
	  "matchesJsonPath" : "$[?(@.['email'] =~ /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,6})?/)]"
	}, {
	  "matchesJsonPath" : "$[?(@.['callback_url'] =~ /((http[s]?|ftp):\\\\/)\\\\/?([^:\\\\/\\\\s]+)(:[0-9]{1,5})?/)]"
	} ],
	"headers" : {
	  "Content-Type" : {
		"equalTo" : "application/json"
	  }
	}
  },
  "response" : {
	"status" : 404,
	"body" : "{\\"code\\":\\"123123\\",\\"message\\":\\"User not found by email == [not.existing@user.com]\\"}",
	"headers" : {
	  "Content-Type" : "application/json"
	}
  },
  "priority" : 1
}
'''</programlisting>
</section>
<section xml:id="_executing_custom_methods_on_the_server_side">
<title>Executing Custom Methods on the Server Side</title>
<important>
<simpara>This section is valid only for Groovy DSL. Check out the
<xref linkend="contract-matchers"/> section for YAML examples of a similar feature.</simpara>
</important>
<simpara>You can define a method call that executes on the server side during the test. Such a
method can be added to the class defined as "baseClassForTests" in the configuration. The
following code shows an example of the contract portion of the test case:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'PUT'
		url $(consumer(regex('^/api/[0-9]{2}$')), producer('/api/12'))
		headers {
			header 'Content-Type': 'application/json'
		}
		body '''\
				[{
					"text": "Gonna see you at Warsaw"
				}]
			'''
	}
	response {
		body (
				path: $(consumer('/api/12'), producer(regex('^/api/[0-9]{2}$'))),
				correlationId: $(consumer('1223456'), producer(execute('isProperCorrelationId($it)')))
		)
		status 200
	}
}</programlisting>
<simpara>The following code shows the base class portion of the test case:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">abstract class BaseMockMvcSpec extends Specification {

	def setup() {
		RestAssuredMockMvc.standaloneSetup(new PairIdController())
	}

	void isProperCorrelationId(Integer correlationId) {
		assert correlationId == 123456
	}

	void isEmpty(String value) {
		assert value == null
	}

}</programlisting>
<important>
<simpara>You cannot use both a String and <literal>execute</literal> to perform concatenation. For
example, calling <literal>header('Authorization', 'Bearer ' + execute('authToken()'))</literal> leads to
improper results. Instead, call <literal>header('Authorization', execute('authToken()'))</literal> and
ensure that the <literal>authToken()</literal> method returns everything you need.</simpara>
</important>
<simpara>The type of the object read from the JSON can be one of the following, depending on the
JSON path:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>String</literal>: If you point to a <literal>String</literal> value in the JSON.</simpara>
</listitem>
<listitem>
<simpara><literal>JSONArray</literal>: If you point to a <literal>List</literal> in the JSON.</simpara>
</listitem>
<listitem>
<simpara><literal>Map</literal>: If you point to a <literal>Map</literal> in the JSON.</simpara>
</listitem>
<listitem>
<simpara><literal>Number</literal>: If you point to <literal>Integer</literal>, <literal>Double</literal> etc. in the JSON.</simpara>
</listitem>
<listitem>
<simpara><literal>Boolean</literal>: If you point to a <literal>Boolean</literal> in the JSON.</simpara>
</listitem>
</itemizedlist>
<simpara>In the request part of the contract, you can specify that the <literal>body</literal> should be taken from
a method.</simpara>
<important>
<simpara>You must provide both the consumer and the producer side. The <literal>execute</literal> part
is applied for the whole body - not for parts of it.</simpara>
</important>
<simpara>The following example shows how to read an object from JSON:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Contract contractDsl = Contract.make {
	request {
		method 'GET'
		url '/something'
		body(
				$(c("foo"), p(execute("hashCode()")))
		)
	}
	response {
		status 200
	}
}</programlisting>
<simpara>The preceding example results in calling the <literal>hashCode()</literal> method in the request body.
It should resemble the following code:</simpara>
<programlisting language="java" linenumbering="unnumbered">// given:
 MockMvcRequestSpecification request = given()
   .body(hashCode());

// when:
 ResponseOptions response = given().spec(request)
   .get("/something");

// then:
 assertThat(response.statusCode()).isEqualTo(200);</programlisting>
</section>
<section xml:id="_referencing_the_request_from_the_response">
<title>Referencing the Request from the Response</title>
<simpara>The best situation is to provide fixed values, but sometimes you need to reference a
request in your response.</simpara>
<simpara>If you&#8217;re writing contracts using Groovy DSL, you can use the <literal>fromRequest()</literal> method, which lets
you reference a bunch of elements from the HTTP request. You can use the following
options:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>fromRequest().url()</literal>: Returns the request URL and query parameters.</simpara>
</listitem>
<listitem>
<simpara><literal>fromRequest().query(String key)</literal>: Returns the first query parameter with a given name.</simpara>
</listitem>
<listitem>
<simpara><literal>fromRequest().query(String key, int index)</literal>: Returns the nth query parameter with a
given name.</simpara>
</listitem>
<listitem>
<simpara><literal>fromRequest().path()</literal>: Returns the full path.</simpara>
</listitem>
<listitem>
<simpara><literal>fromRequest().path(int index)</literal>: Returns the nth path element.</simpara>
</listitem>
<listitem>
<simpara><literal>fromRequest().header(String key)</literal>: Returns the first header with a given name.</simpara>
</listitem>
<listitem>
<simpara><literal>fromRequest().header(String key, int index)</literal>: Returns the nth header with a given name.</simpara>
</listitem>
<listitem>
<simpara><literal>fromRequest().body()</literal>: Returns the full request body.</simpara>
</listitem>
<listitem>
<simpara><literal>fromRequest().body(String jsonPath)</literal>: Returns the element from the request that
matches the JSON Path.</simpara>
</listitem>
</itemizedlist>
<simpara>If you&#8217;re using the YAML contract definition you have to use the
<link xl:href="https://handlebarsjs.com/">Handlebars</link> <literal>{{{ }}}</literal> notation with custom, Spring Cloud Contract
 functions to achieve this.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>{{{ request.url }}}</literal>: Returns the request URL and query parameters.</simpara>
</listitem>
<listitem>
<simpara><literal>{{{ request.query.key.[index] }}}</literal>: Returns the nth query parameter with a given name.
E.g. for key <literal>foo</literal>, first entry <literal>{{{ request.query.foo.[0] }}}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>{{{ request.path }}}</literal>: Returns the full path.</simpara>
</listitem>
<listitem>
<simpara><literal>{{{ request.path.[index] }}}</literal>: Returns the nth path element. E.g.
for first entry <literal>`</literal>{{{ request.path.[0] }}}</simpara>
</listitem>
<listitem>
<simpara><literal>{{{ request.headers.key }}}</literal>: Returns the first header with a given name.</simpara>
</listitem>
<listitem>
<simpara><literal>{{{ request.headers.key.[index] }}}</literal>: Returns the nth header with a given name.</simpara>
</listitem>
<listitem>
<simpara><literal>{{{ request.body }}}</literal>: Returns the full request body.</simpara>
</listitem>
<listitem>
<simpara><literal>{{{ jsonpath this 'your.json.path' }}}</literal>: Returns the element from the request that
matches the JSON Path. E.g. for json path <literal>$.foo</literal> - <literal>{{{ jsonpath this '$.foo' }}}</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Consider the following contract:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">Contract contractDsl = Contract.make {
	request {
		method 'GET'
		url('/api/v1/xxxx') {
			queryParameters {
				parameter("foo", "bar")
				parameter("foo", "bar2")
			}
		}
		headers {
			header(authorization(), "secret")
			header(authorization(), "secret2")
		}
		body(foo: "bar", baz: 5)
	}
	response {
		status 200
		headers {
			header(authorization(), "foo ${fromRequest().header(authorization())} bar")
		}
		body(
				url: fromRequest().url(),
				path: fromRequest().path(),
				pathIndex: fromRequest().path(1),
				param: fromRequest().query("foo"),
				paramIndex: fromRequest().query("foo", 1),
				authorization: fromRequest().header("Authorization"),
				authorization2: fromRequest().header("Authorization", 1),
				fullBody: fromRequest().body(),
				responseFoo: fromRequest().body('$.foo'),
				responseBaz: fromRequest().body('$.baz'),
				responseBaz2: "Bla bla ${fromRequest().body('$.foo')} bla bla"
		)
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">request:
  method: GET
  url: /api/v1/xxxx
  queryParameters:
    foo:
      - bar
      - bar2
  headers:
    Authorization:
      - secret
      - secret2
  body:
    foo: bar
    baz: 5
response:
  status: 200
  headers:
    Authorization: "foo {{{ request.headers.Authorization.0 }}} bar"
  body:
    url: "{{{ request.url }}}"
    path: "{{{ request.path }}}"
    pathIndex: "{{{ request.path.1 }}}"
    param: "{{{ request.query.foo }}}"
    paramIndex: "{{{ request.query.foo.1 }}}"
    authorization: "{{{ request.headers.Authorization.0 }}}"
    authorization2: "{{{ request.headers.Authorization.1 }}"
    fullBody: "{{{ request.body }}}"
    responseFoo: "{{{ jsonpath this '$.foo' }}}"
    responseBaz: "{{{ jsonpath this '$.baz' }}}"
    responseBaz2: "Bla bla {{{ jsonpath this '$.foo' }}} bla bla"</programlisting>
</para>
</formalpara>
<simpara>Running a JUnit test generation leads to a test that resembles the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">// given:
 MockMvcRequestSpecification request = given()
   .header("Authorization", "secret")
   .header("Authorization", "secret2")
   .body("{\"foo\":\"bar\",\"baz\":5}");

// when:
 ResponseOptions response = given().spec(request)
   .queryParam("foo","bar")
   .queryParam("foo","bar2")
   .get("/api/v1/xxxx");

// then:
 assertThat(response.statusCode()).isEqualTo(200);
 assertThat(response.header("Authorization")).isEqualTo("foo secret bar");
// and:
 DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
 assertThatJson(parsedJson).field("['fullBody']").isEqualTo("{\"foo\":\"bar\",\"baz\":5}");
 assertThatJson(parsedJson).field("['authorization']").isEqualTo("secret");
 assertThatJson(parsedJson).field("['authorization2']").isEqualTo("secret2");
 assertThatJson(parsedJson).field("['path']").isEqualTo("/api/v1/xxxx");
 assertThatJson(parsedJson).field("['param']").isEqualTo("bar");
 assertThatJson(parsedJson).field("['paramIndex']").isEqualTo("bar2");
 assertThatJson(parsedJson).field("['pathIndex']").isEqualTo("v1");
 assertThatJson(parsedJson).field("['responseBaz']").isEqualTo(5);
 assertThatJson(parsedJson).field("['responseFoo']").isEqualTo("bar");
 assertThatJson(parsedJson).field("['url']").isEqualTo("/api/v1/xxxx?foo=bar&amp;foo=bar2");
 assertThatJson(parsedJson).field("['responseBaz2']").isEqualTo("Bla bla bar bla bla");</programlisting>
<simpara>As you can see, elements from the request have been properly referenced in the response.</simpara>
<simpara>The generated WireMock stub should resemble the following example:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "request" : {
    "urlPath" : "/api/v1/xxxx",
    "method" : "POST",
    "headers" : {
      "Authorization" : {
        "equalTo" : "secret2"
      }
    },
    "queryParameters" : {
      "foo" : {
        "equalTo" : "bar2"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.['baz'] == 5)]"
    }, {
      "matchesJsonPath" : "$[?(@.['foo'] == 'bar')]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\"authorization\":\"{{{request.headers.Authorization.[0]}}}\",\"path\":\"{{{request.path}}}\",\"responseBaz\":{{{jsonpath this '$.baz'}}} ,\"param\":\"{{{request.query.foo.[0]}}}\",\"pathIndex\":\"{{{request.path.[1]}}}\",\"responseBaz2\":\"Bla bla {{{jsonpath this '$.foo'}}} bla bla\",\"responseFoo\":\"{{{jsonpath this '$.foo'}}}\",\"authorization2\":\"{{{request.headers.Authorization.[1]}}}\",\"fullBody\":\"{{{escapejsonbody}}}\",\"url\":\"{{{request.url}}}\",\"paramIndex\":\"{{{request.query.foo.[1]}}}\"}",
    "headers" : {
      "Authorization" : "{{{request.headers.Authorization.[0]}}};foo"
    },
    "transformers" : [ "response-template" ]
  }
}</programlisting>
<simpara>Sending a request such as the one presented in the <literal>request</literal> part of the contract results
in sending the following response body:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "url" : "/api/v1/xxxx?foo=bar&amp;foo=bar2",
  "path" : "/api/v1/xxxx",
  "pathIndex" : "v1",
  "param" : "bar",
  "paramIndex" : "bar2",
  "authorization" : "secret",
  "authorization2" : "secret2",
  "fullBody" : "{\"foo\":\"bar\",\"baz\":5}",
  "responseFoo" : "bar",
  "responseBaz" : 5,
  "responseBaz2" : "Bla bla bar bla bla"
}</programlisting>
<important>
<simpara>This feature works only with WireMock having a version greater than or equal
to 2.5.1. The Spring Cloud Contract Verifier uses WireMock&#8217;s
<literal>response-template</literal> response transformer. It uses Handlebars to convert the Mustache <literal>{{{ }}}</literal> templates into
proper values. Additionally, it registers two helper functions:</simpara>
</important>
<itemizedlist>
<listitem>
<simpara><literal>escapejsonbody</literal>: Escapes the request body in a format that can be embedded in a JSON.</simpara>
</listitem>
<listitem>
<simpara><literal>jsonpath</literal>: For a given parameter, find an object in the request body.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_registering_your_own_wiremock_extension">
<title>Registering Your Own WireMock Extension</title>
<simpara>WireMock lets you register custom extensions. By default, Spring Cloud Contract registers
the transformer, which lets you reference a request from a response. If you want to
provide your own extensions, you can register an implementation of the
<literal>org.springframework.cloud.contract.verifier.dsl.wiremock.WireMockExtensions</literal> interface.
Since we use the spring.factories extension approach, you can create an entry in
<literal>META-INF/spring.factories</literal> file similar to the following:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.verifier.dsl.wiremock.WireMockExtensions=\
org.springframework.cloud.contract.stubrunner.provider.wiremock.TestWireMockExtensions</programlisting>
<simpara>The following is an example of a custom extension:</simpara>
<formalpara>
<title>TestWireMockExtensions.groovy</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">package org.springframework.cloud.contract.verifier.dsl.wiremock

import com.github.tomakehurst.wiremock.extension.Extension

/**
 * Extension that registers the default transformer and the custom one
 */
class TestWireMockExtensions implements WireMockExtensions {
	@Override
	List&lt;Extension&gt; extensions() {
		return [
				new DefaultResponseTransformer(),
				new CustomExtension()
		]
	}
}

class CustomExtension implements Extension {

	@Override
	String getName() {
		return "foo-transformer"
	}
}</programlisting>
</para>
</formalpara>
<important>
<simpara>Remember to override the <literal>applyGlobally()</literal> method and set it to <literal>false</literal> if you
want the transformation to be applied only for a mapping that explicitly requires it.</simpara>
</important>
</section>
<section xml:id="contract-matchers">
<title>Dynamic Properties in the Matchers Sections</title>
<simpara>If you work with <link xl:href="https://docs.pact.io/">Pact</link>, the following discussion may seem familiar.
Quite a few users are used to having a separation between the body and setting the
dynamic parts of a contract.</simpara>
<simpara>You can use two separate sections:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>stubMatchers</literal>, which lets you define the dynamic values that should end up in a stub.
You can set it in the <literal>request</literal> or <literal>inputMessage</literal> part of your contract.</simpara>
</listitem>
<listitem>
<simpara><literal>testMatchers</literal>, which is present in the <literal>response</literal> or <literal>outputMessage</literal> side of the
contract.</simpara>
</listitem>
</itemizedlist>
<simpara>Currently, Spring Cloud Contract Verifier supports only JSON Path-based matchers with the
following matching possibilities:</simpara>
<itemizedlist>
<title>Groovy DSL</title>
<listitem>
<simpara>For <literal>stubMatchers</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>byEquality()</literal>: The value taken from the request via the provided JSON Path must be
equal to the value provided in the contract.</simpara>
</listitem>
<listitem>
<simpara><literal>byRegex(&#8230;&#8203;)</literal>: The value taken from the request via the provided JSON Path must
match the regex.</simpara>
</listitem>
<listitem>
<simpara><literal>byDate()</literal>: The value taken from the request via the provided JSON Path must
match the regex for an ISO Date value.</simpara>
</listitem>
<listitem>
<simpara><literal>byTimestamp()</literal>: The value taken from the request via the provided JSON Path must
match the regex for an ISO DateTime value.</simpara>
</listitem>
<listitem>
<simpara><literal>byTime()</literal>: The value taken from the request via the provided JSON Path must
match the regex for an ISO Time value.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>For <literal>testMatchers</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>byEquality()</literal>: The value taken from the response via the provided JSON Path must be
equal to the provided value in the contract.</simpara>
</listitem>
<listitem>
<simpara><literal>byRegex(&#8230;&#8203;)</literal>: The value taken from the response via the provided JSON Path must
match the regex.</simpara>
</listitem>
<listitem>
<simpara><literal>byDate()</literal>: The value taken from the response via the provided JSON Path must match
the regex for an ISO Date value.</simpara>
</listitem>
<listitem>
<simpara><literal>byTimestamp()</literal>: The value taken from the response via the provided JSON Path must
match the regex for an ISO DateTime value.</simpara>
</listitem>
<listitem>
<simpara><literal>byTime()</literal>: The value taken from the response via the provided JSON Path must match
the regex for an ISO Time value.</simpara>
</listitem>
<listitem>
<simpara><literal>byType()</literal>: The value taken from the response via the provided JSON Path needs to be
of the same type as the type defined in the body of the response in the contract.
<literal>byType</literal> can take a closure, in which you can set <literal>minOccurrence</literal> and <literal>maxOccurrence</literal>.
That way, you can assert the size of the flattened collection. To check the size of an
unflattened collection, use a custom method with the <literal>byCommand(&#8230;&#8203;)</literal> testMatcher.</simpara>
</listitem>
<listitem>
<simpara><literal>byCommand(&#8230;&#8203;)</literal>: The value taken from the response via the provided JSON Path is
passed as an input to the custom method that you provide. For example,
<literal>byCommand('foo($it)')</literal> results in calling a <literal>foo</literal> method to which the value matching the
JSON Path gets passed. The type of the object read from the JSON can be one of the
following, depending on the JSON path:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>String</literal>: If you point to a <literal>String</literal> value.</simpara>
</listitem>
<listitem>
<simpara><literal>JSONArray</literal>: If you point to a <literal>List</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>Map</literal>: If you point to a <literal>Map</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>Number</literal>: If you point to <literal>Integer</literal>, <literal>Double</literal>, or other kind of number.</simpara>
</listitem>
<listitem>
<simpara><literal>Boolean</literal>: If you point to a <literal>Boolean</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<formalpara>
<title>YAML</title>
<para><emphasis>Please read the Groovy section for detailed explanation of
what the types mean</emphasis></para>
</formalpara>
<simpara>For YAML the structure of a matcher looks like this</simpara>
<programlisting language="yml" linenumbering="unnumbered">- path: $.foo
  type: by_regex
  value: bar</programlisting>
<simpara>Or if you want to use one of the predefined regular expressions
<literal>[only_alpha_unicode, number, any_boolean, ip_address, hostname,
email, url, uuid, iso_date, iso_date_time, iso_time, iso_8601_with_offset, non_empty, non_blank]</literal>:</simpara>
<programlisting language="yml" linenumbering="unnumbered">- path: $.foo
  type: by_regex
  predefined: only_alpha_unicode</programlisting>
<simpara>Below you can find the allowed list of `type`s.</simpara>
<itemizedlist>
<listitem>
<simpara>For <literal>stubMatchers</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>by_equality</literal></simpara>
</listitem>
<listitem>
<simpara><literal>by_regex</literal></simpara>
</listitem>
<listitem>
<simpara><literal>by_date</literal></simpara>
</listitem>
<listitem>
<simpara><literal>by_timestamp</literal></simpara>
</listitem>
<listitem>
<simpara><literal>by_time</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>For <literal>testMatchers</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>by_equality</literal></simpara>
</listitem>
<listitem>
<simpara><literal>by_regex</literal></simpara>
</listitem>
<listitem>
<simpara><literal>by_date</literal></simpara>
</listitem>
<listitem>
<simpara><literal>by_timestamp</literal></simpara>
</listitem>
<listitem>
<simpara><literal>by_time</literal></simpara>
</listitem>
<listitem>
<simpara><literal>by_type</literal></simpara>
<itemizedlist>
<listitem>
<simpara>there are 2 additional fields accepted: <literal>minOccurrence</literal> and <literal>maxOccurrence</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>by_command</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Consider the following example:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">Contract contractDsl = Contract.make {
	request {
		method 'GET'
		urlPath '/get'
		body([
				duck: 123,
				alpha: "abc",
				number: 123,
				aBoolean: true,
				date: "2017-01-01",
				dateTime: "2017-01-01T01:23:45",
				time: "01:02:34",
				valueWithoutAMatcher: "foo",
				valueWithTypeMatch: "string",
				key: [
						'complex.key' : 'foo'
				]
		])
		stubMatchers {
			jsonPath('$.duck', byRegex("[0-9]{3}"))
			jsonPath('$.duck', byEquality())
			jsonPath('$.alpha', byRegex(onlyAlphaUnicode()))
			jsonPath('$.alpha', byEquality())
			jsonPath('$.number', byRegex(number()))
			jsonPath('$.aBoolean', byRegex(anyBoolean()))
			jsonPath('$.date', byDate())
			jsonPath('$.dateTime', byTimestamp())
			jsonPath('$.time', byTime())
			jsonPath("\$.['key'].['complex.key']", byEquality())
		}
		headers {
			contentType(applicationJson())
		}
	}
	response {
		status 200
		body([
				duck: 123,
				alpha: "abc",
				number: 123,
				aBoolean: true,
				date: "2017-01-01",
				dateTime: "2017-01-01T01:23:45",
				time: "01:02:34",
				valueWithoutAMatcher: "foo",
				valueWithTypeMatch: "string",
				valueWithMin: [
					1,2,3
				],
				valueWithMax: [
					1,2,3
				],
				valueWithMinMax: [
					1,2,3
				],
				valueWithMinEmpty: [],
				valueWithMaxEmpty: [],
				key: [
				        'complex.key' : 'foo'
				]
		])
		testMatchers {
			// asserts the jsonpath value against manual regex
			jsonPath('$.duck', byRegex("[0-9]{3}"))
			// asserts the jsonpath value against the provided value
			jsonPath('$.duck', byEquality())
			// asserts the jsonpath value against some default regex
			jsonPath('$.alpha', byRegex(onlyAlphaUnicode()))
			jsonPath('$.alpha', byEquality())
			jsonPath('$.number', byRegex(number()))
			jsonPath('$.aBoolean', byRegex(anyBoolean()))
			// asserts vs inbuilt time related regex
			jsonPath('$.date', byDate())
			jsonPath('$.dateTime', byTimestamp())
			jsonPath('$.time', byTime())
			// asserts that the resulting type is the same as in response body
			jsonPath('$.valueWithTypeMatch', byType())
			jsonPath('$.valueWithMin', byType {
				// results in verification of size of array (min 1)
				minOccurrence(1)
			})
			jsonPath('$.valueWithMax', byType {
				// results in verification of size of array (max 3)
				maxOccurrence(3)
			})
			jsonPath('$.valueWithMinMax', byType {
				// results in verification of size of array (min 1 &amp; max 3)
				minOccurrence(1)
				maxOccurrence(3)
			})
			jsonPath('$.valueWithMinEmpty', byType {
				// results in verification of size of array (min 0)
				minOccurrence(0)
			})
			jsonPath('$.valueWithMaxEmpty', byType {
				// results in verification of size of array (max 0)
				maxOccurrence(0)
			})
			// will execute a method `assertThatValueIsANumber`
			jsonPath('$.duck', byCommand('assertThatValueIsANumber($it)'))
			jsonPath("\$.['key'].['complex.key']", byEquality())
		}
		headers {
			contentType(applicationJson())
		}
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">request:
  method: GET
  urlPath: /get
  body:
    duck: 123
    alpha: "abc"
    number: 123
    aBoolean: true
    date: "2017-01-01"
    dateTime: "2017-01-01T01:23:45"
    time: "01:02:34"
    valueWithoutAMatcher: "foo"
    valueWithTypeMatch: "string"
    key:
      "complex.key": 'foo'
  matchers:
    headers:
      - key: Content-Type
        regex: "application/json.*"
    body:
      - path: $.duck
        type: by_regex
        value: "[0-9]{3}"
      - path: $.duck
        type: by_equality
      - path: $.alpha
        type: by_regex
        predefined: only_alpha_unicode
      - path: $.alpha
        type: by_equality
      - path: $.number
        type: by_regex
        predefined: number
      - path: $.aBoolean
        type: by_regex
        predefined: any_boolean
      - path: $.date
        type: by_date
      - path: $.dateTime
        type: by_timestamp
      - path: $.time
        type: by_time
      - path: "$.['key'].['complex.key']"
        type: by_equality
  headers:
    Content-Type: application/json
response:
  status: 200
  body:
    duck: 123
    alpha: "abc"
    number: 123
    aBoolean: true
    date: "2017-01-01"
    dateTime: "2017-01-01T01:23:45"
    time: "01:02:34"
    valueWithoutAMatcher: "foo"
    valueWithTypeMatch: "string"
    valueWithMin:
      - 1
      - 2
      - 3
    valueWithMax:
      - 1
      - 2
      - 3
    valueWithMinMax:
      - 1
      - 2
      - 3
    valueWithMinEmpty: []
    valueWithMaxEmpty: []
    key:
      'complex.key' : 'foo'
  matchers:
    headers:
      - key: Content-Type
        regex: "application/json.*"
    body:
      - path: $.duck
        type: by_regex
        value: "[0-9]{3}"
      - path: $.duck
        type: by_equality
      - path: $.alpha
        type: by_regex
        predefined: only_alpha_unicode
      - path: $.alpha
        type: by_equality
      - path: $.number
        type: by_regex
        predefined: number
      - path: $.aBoolean
        type: by_regex
        predefined: any_boolean
      - path: $.date
        type: by_date
      - path: $.dateTime
        type: by_timestamp
      - path: $.time
        type: by_time
      - path: $.valueWithTypeMatch
        type: by_type
      - path: $.valueWithMin
        type: by_type
        minOccurrence: 1
      - path: $.valueWithMax
        type: by_type
        maxOccurrence: 3
      - path: $.valueWithMinMax
        type: by_type
        minOccurrence: 1
        maxOccurrence: 3
      - path: $.valueWithMinEmpty
        type: by_type
        minOccurrence: 0
      - path: $.valueWithMaxEmpty
        type: by_type
        maxOccurrence: 0
      - path: $.duck
        type: by_command
        value: assertThatValueIsANumber($it)
  headers:
    Content-Type: application/json</programlisting>
</para>
</formalpara>
<simpara>In the preceding example, you can see the dynamic portions of the contract in the
<literal>matchers</literal> sections. For the request part, you can see that, for all fields but
<literal>valueWithoutAMatcher</literal>, the values of the regular expressions that the stub should
contain are explicitly set. For the <literal>valueWithoutAMatcher</literal>, the verification takes place
in the same way as without the use of matchers. In that case, the test performs an
equality check.</simpara>
<simpara>For the response side in the <literal>testMatchers</literal> section, we define the dynamic parts in a
similar manner. The only difference is that the <literal>byType</literal> matchers are also present. The
verifier engine checks four fields to verify whether the response from the test
has a value for which the JSON path matches the given field, is of the same type as the one
defined in the response body, and passes the following check (based on the method being called):</simpara>
<itemizedlist>
<listitem>
<simpara>For <literal>$.valueWithTypeMatch</literal>, the engine checks whether the type is the same.</simpara>
</listitem>
<listitem>
<simpara>For <literal>$.valueWithMin</literal>, the engine check the type and asserts whether the size is greater
than or equal to the minimum occurrence.</simpara>
</listitem>
<listitem>
<simpara>For <literal>$.valueWithMax</literal>, the engine checks the type and asserts whether the size is
smaller than or equal to the maximum occurrence.</simpara>
</listitem>
<listitem>
<simpara>For <literal>$.valueWithMinMax</literal>, the engine checks the type and asserts whether the size is
between the min and maximum occurrence.</simpara>
</listitem>
</itemizedlist>
<simpara>The resulting test would resemble the following example (note that an <literal>and</literal> section
separates the autogenerated assertions and the assertion from matchers):</simpara>
<programlisting language="java" linenumbering="unnumbered">// given:
 MockMvcRequestSpecification request = given()
   .header("Content-Type", "application/json")
   .body("{\"duck\":123,\"alpha\":\"abc\",\"number\":123,\"aBoolean\":true,\"date\":\"2017-01-01\",\"dateTime\":\"2017-01-01T01:23:45\",\"time\":\"01:02:34\",\"valueWithoutAMatcher\":\"foo\",\"valueWithTypeMatch\":\"string\"}");

// when:
 ResponseOptions response = given().spec(request)
   .get("/get");

// then:
 assertThat(response.statusCode()).isEqualTo(200);
 assertThat(response.header("Content-Type")).matches("application/json.*");
// and:
 DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
 assertThatJson(parsedJson).field("valueWithoutAMatcher").isEqualTo("foo");
// and:
 assertThat(parsedJson.read("$.duck", String.class)).matches("[0-9]{3}");
 assertThat(parsedJson.read("$.duck", Integer.class)).isEqualTo(123);
 assertThat(parsedJson.read("$.alpha", String.class)).matches("[\\p{L}]*");
 assertThat(parsedJson.read("$.alpha", String.class)).isEqualTo("abc");
 assertThat(parsedJson.read("$.number", String.class)).matches("-?\\d*(\\.\\d+)?");
 assertThat(parsedJson.read("$.aBoolean", String.class)).matches("(true|false)");
 assertThat(parsedJson.read("$.date", String.class)).matches("(\\d\\d\\d\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])");
 assertThat(parsedJson.read("$.dateTime", String.class)).matches("([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])");
 assertThat(parsedJson.read("$.time", String.class)).matches("(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])");
 assertThat((Object) parsedJson.read("$.valueWithTypeMatch")).isInstanceOf(java.lang.String.class);
 assertThat((Object) parsedJson.read("$.valueWithMin")).isInstanceOf(java.util.List.class);
 assertThat((java.lang.Iterable) parsedJson.read("$.valueWithMin", java.util.Collection.class)).hasSizeGreaterThanOrEqualTo(1);
 assertThat((Object) parsedJson.read("$.valueWithMax")).isInstanceOf(java.util.List.class);
 assertThat((java.lang.Iterable) parsedJson.read("$.valueWithMax", java.util.Collection.class)).hasSizeLessThanOrEqualTo(3);
 assertThat((Object) parsedJson.read("$.valueWithMinMax")).isInstanceOf(java.util.List.class);
 assertThat((java.lang.Iterable) parsedJson.read("$.valueWithMinMax", java.util.Collection.class)).hasSizeBetween(1, 3);
 assertThat((Object) parsedJson.read("$.valueWithMinEmpty")).isInstanceOf(java.util.List.class);
 assertThat((java.lang.Iterable) parsedJson.read("$.valueWithMinEmpty", java.util.Collection.class)).hasSizeGreaterThanOrEqualTo(0);
 assertThat((Object) parsedJson.read("$.valueWithMaxEmpty")).isInstanceOf(java.util.List.class);
 assertThat((java.lang.Iterable) parsedJson.read("$.valueWithMaxEmpty", java.util.Collection.class)).hasSizeLessThanOrEqualTo(0);
 assertThatValueIsANumber(parsedJson.read("$.duck"));</programlisting>
<important>
<simpara>Notice that, for the <literal>byCommand</literal> method, the example calls the
<literal>assertThatValueIsANumber</literal>. This method must be defined in the test base class or be
statically imported to your tests. Notice that the <literal>byCommand</literal> call was converted to
<literal>assertThatValueIsANumber(parsedJson.read("$.duck"));</literal>. That means that the engine took
the method name and passed the proper JSON path as a parameter to it.</simpara>
</important>
<simpara>The resulting WireMock stub is in the following example:</simpara>
<programlisting language="json" linenumbering="unnumbered">				'''
{
  "request" : {
	"urlPath" : "/get",
	"method" : "POST",
	"headers" : {
	  "Content-Type" : {
		"matches" : "application/json.*"
	  }
	},
	"bodyPatterns" : [ {
	  "matchesJsonPath" : "$[?(@.['valueWithoutAMatcher'] == 'foo')]"
	}, {
	  "matchesJsonPath" : "$[?(@.['valueWithTypeMatch'] == 'string')]"
	}, {
	  "matchesJsonPath" : "$.['list'].['some'].['nested'][?(@.['anothervalue'] == 4)]"
	}, {
	  "matchesJsonPath" : "$.['list'].['someother'].['nested'][?(@.['anothervalue'] == 4)]"
	}, {
	  "matchesJsonPath" : "$.['list'].['someother'].['nested'][?(@.['json'] == 'with value')]"
	}, {
	  "matchesJsonPath" : "$[?(@.duck =~ /([0-9]{3})/)]"
	}, {
	  "matchesJsonPath" : "$[?(@.duck == 123)]"
	}, {
	  "matchesJsonPath" : "$[?(@.alpha =~ /([\\\\p{L}]*)/)]"
	}, {
	  "matchesJsonPath" : "$[?(@.alpha == 'abc')]"
	}, {
	  "matchesJsonPath" : "$[?(@.number =~ /(-?(\\\\d*\\\\.\\\\d+|\\\\d+))/)]"
	}, {
	  "matchesJsonPath" : "$[?(@.aBoolean =~ /((true|false))/)]"
	}, {
	  "matchesJsonPath" : "$[?(@.date =~ /((\\\\d\\\\d\\\\d\\\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))/)]"
	}, {
	  "matchesJsonPath" : "$[?(@.dateTime =~ /(([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9]))/)]"
	}, {
	  "matchesJsonPath" : "$[?(@.time =~ /((2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9]))/)]"
	}, {
	  "matchesJsonPath" : "$.list.some.nested[?(@.json =~ /(.*)/)]"
	} ]
  },
  "response" : {
	"status" : 200,
	"body" : "{\\"date\\":\\"2017-01-01\\",\\"dateTime\\":\\"2017-01-01T01:23:45\\",\\"number\\":123,\\"aBoolean\\":true,\\"duck\\":123,\\"alpha\\":\\"abc\\",\\"valueWithMin\\":[1,2,3],\\"time\\":\\"01:02:34\\",\\"valueWithTypeMatch\\":\\"string\\",\\"valueWithMax\\":[1,2,3],\\"valueWithMinMax\\":[1,2,3],\\"valueWithoutAMatcher\\":\\"foo\\"}",
	"headers" : {
	  "Content-Type" : "application/json"
	}
  }
}
'''</programlisting>
<important>
<simpara>If you use a <literal>matcher</literal>, then the part of the request aned response that the
<literal>matcher</literal> addresses with the JSON Path gets removed from the assertion. In the case of
verifying a collection, you must create matchers for <emphasis role="strong">all</emphasis> the elements of the
collection.</simpara>
</important>
<simpara>Consider the following example:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Contract.make {
    request {
        method 'GET'
        url("/foo")
    }
    response {
        status 200
        body(events: [[
                                 operation          : 'EXPORT',
                                 eventId            : '16f1ed75-0bcc-4f0d-a04d-3121798faf99',
                                 status             : 'OK'
                         ], [
                                 operation          : 'INPUT_PROCESSING',
                                 eventId            : '3bb4ac82-6652-462f-b6d1-75e424a0024a',
                                 status             : 'OK'
                         ]
                ]
        )
        testMatchers {
            jsonPath('$.events[0].operation', byRegex('.+'))
            jsonPath('$.events[0].eventId', byRegex('^([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})$'))
            jsonPath('$.events[0].status', byRegex('.+'))
        }
    }
}</programlisting>
<simpara>The preceding code leads to creating the following test (the code block shows only the assertion section):</simpara>
<programlisting language="java" linenumbering="unnumbered">and:
	DocumentContext parsedJson = JsonPath.parse(response.body.asString())
	assertThatJson(parsedJson).array("['events']").contains("['eventId']").isEqualTo("16f1ed75-0bcc-4f0d-a04d-3121798faf99")
	assertThatJson(parsedJson).array("['events']").contains("['operation']").isEqualTo("EXPORT")
	assertThatJson(parsedJson).array("['events']").contains("['operation']").isEqualTo("INPUT_PROCESSING")
	assertThatJson(parsedJson).array("['events']").contains("['eventId']").isEqualTo("3bb4ac82-6652-462f-b6d1-75e424a0024a")
	assertThatJson(parsedJson).array("['events']").contains("['status']").isEqualTo("OK")
and:
	assertThat(parsedJson.read("\$.events[0].operation", String.class)).matches(".+")
	assertThat(parsedJson.read("\$.events[0].eventId", String.class)).matches("^([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})\$")
	assertThat(parsedJson.read("\$.events[0].status", String.class)).matches(".+")</programlisting>
<simpara>As you can see, the assertion is malformed. Only the first element of the array got
asserted. In order to fix this, you should apply the assertion to the whole <literal>$.events</literal>
collection and assert it with the <literal>byCommand(&#8230;&#8203;)</literal> method.</simpara>
</section>
</section>
<section xml:id="_jax_rs_support">
<title>JAX-RS Support</title>
<simpara>The Spring Cloud Contract Verifier supports the JAX-RS 2 Client API. The base class needs
to define <literal>protected WebTarget webTarget</literal> and server initialization. The only option for
testing JAX-RS API is to start a web server. Also, a request with a body needs to have a
content type set. Otherwise, the default of <literal>application/octet-stream</literal> gets used.</simpara>
<simpara>In order to use JAX-RS mode, use the following settings:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">testMode == 'JAXRSCLIENT'</programlisting>
<simpara>The following example shows a generated test API:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">'''
 // when:
  Response response = webTarget
    .path("/users")
    .queryParam("limit", "10")
    .queryParam("offset", "20")
    .queryParam("filter", "email")
    .queryParam("sort", "name")
    .queryParam("search", "55")
    .queryParam("age", "99")
    .queryParam("name", "Denis.Stepanov")
    .queryParam("email", "bob@email.com")
    .request()
    .method("GET");

  String responseAsString = response.readEntity(String.class);

 // then:
  assertThat(response.getStatus()).isEqualTo(200);
 // and:
  DocumentContext parsedJson = JsonPath.parse(responseAsString);
  assertThatJson(parsedJson).field("['property1']").isEqualTo("a");
'''</programlisting>
</section>
<section xml:id="_async_support">
<title>Async Support</title>
<simpara>If you&#8217;re using asynchronous communication on the server side (your controllers are
returning <literal>Callable</literal>, <literal>DeferredResult</literal>, and so on), then, inside your contract, you must
provide a <literal>sync()</literal> method in the <literal>response</literal> section. The following code shows an example:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method GET()
        url '/get'
    }
    response {
        status 200
        body 'Passed'
        async()
    }
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">response:
    async: true</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_working_with_context_paths">
<title>Working with Context Paths</title>
<simpara>Spring Cloud Contract supports context paths.</simpara>
<important>
<simpara>The only change needed to fully support context paths is the switch on the
<emphasis role="strong">PRODUCER</emphasis> side. Also, the autogenerated tests must use <emphasis role="strong">EXPLICIT</emphasis> mode. The  consumer
side remains untouched. In order for the generated test to pass, you must use <emphasis role="strong">EXPLICIT</emphasis>
mode.</simpara>
</important>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
    &lt;configuration&gt;
        &lt;testMode&gt;EXPLICIT&lt;/testMode&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">contracts {
		testMode = 'EXPLICIT'
}</programlisting>
</para>
</formalpara>
<simpara>That way, you generate a test that <emphasis role="strong">DOES NOT</emphasis> use MockMvc. It means that you generate
real requests and you need to setup your generated test&#8217;s base class to work on a real
socket.</simpara>
<simpara>Consider the following contract:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'GET'
		url '/my-context-path/url'
	}
	response {
		status 200
	}
}</programlisting>
<simpara>The following example shows how to set up a base class and Rest Assured:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">import io.restassured.RestAssured;
import org.junit.Before;
import org.springframework.boot.context.embedded.LocalServerPort;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest(classes = ContextPathTestingBaseClass.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class ContextPathTestingBaseClass {

	@LocalServerPort int port;

	@Before
	public void setup() {
		RestAssured.baseURI = "http://localhost";
		RestAssured.port = this.port;
	}
}</programlisting>
<simpara>If you do it this way:</simpara>
<itemizedlist>
<listitem>
<simpara>All of your requests in the autogenerated tests are sent to the real endpoint with your
context path included (for example, <literal>/my-context-path/url</literal>).</simpara>
</listitem>
<listitem>
<simpara>Your contracts reflect that you have a context path. Your generated stubs also have
that information (for example, in the stubs, you have to call <literal>/my-context-path/url</literal>).</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_messaging_top_level_elements">
<title>Messaging Top-Level Elements</title>
<simpara>The DSL for messaging looks a little bit different than the one that focuses on HTTP. The
following sections explain the differences:</simpara>
<itemizedlist>
<listitem>
<simpara><xref linkend="contract-dsl-output-triggered-method"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="contract-dsl-output-triggered-message"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="contract-dsl-consumer-producer"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="contract-dsl-common"/></simpara>
</listitem>
</itemizedlist>
<section xml:id="contract-dsl-output-triggered-method">
<title>Output Triggered by a Method</title>
<simpara>The output message can be triggered by calling a method (such as a <literal>Scheduler</literal> when a was
started and a message was sent), as shown in the following example:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">def dsl = Contract.make {
	// Human readable description
	description 'Some description'
	// Label by means of which the output message can be triggered
	label 'some_label'
	// input to the contract
	input {
		// the contract will be triggered by a method
		triggeredBy('bookReturnedTriggered()')
	}
	// output message of the contract
	outputMessage {
		// destination to which the output message will be sent
		sentTo('output')
		// the body of the output message
		body('''{ "bookName" : "foo" }''')
		// the headers of the output message
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered"># Human readable description
description: Some description
# Label by means of which the output message can be triggered
label: some_label
input:
  # the contract will be triggered by a method
  triggeredBy: bookReturnedTriggered()
# output message of the contract
outputMessage:
  # destination to which the output message will be sent
  sentTo: output
  # the body of the output message
  body:
    bookName: foo
  # the headers of the output message
  headers:
    BOOK-NAME: foo</programlisting>
</para>
</formalpara>
<simpara>In the previous example case, the output message is sent to <literal>output</literal> if a method called
<literal>bookReturnedTriggered</literal> is executed. On the message <emphasis role="strong">publisher&#8217;s</emphasis> side, we generate a
test that calls that method to trigger the message. On the <emphasis role="strong">consumer</emphasis> side, you can use
the <literal>some_label</literal> to trigger the message.</simpara>
</section>
<section xml:id="contract-dsl-output-triggered-message">
<title>Output Triggered by a Message</title>
<simpara>The output message can be triggered by receiving a message, as shown in the following
example:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">def dsl = Contract.make {
	description 'Some Description'
	label 'some_label'
	// input is a message
	input {
		// the message was received from this destination
		messageFrom('input')
		// has the following body
		messageBody([
		        bookName: 'foo'
		])
		// and the following headers
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('output')
		body([
		        bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered"># Human readable description
description: Some description
# Label by means of which the output message can be triggered
label: some_label
# input is a message
input:
  messageFrom: input
  # has the following body
  messageBody:
    bookName: 'foo'
  # and the following headers
  messageHeaders:
    sample: 'header'
# output message of the contract
outputMessage:
  # destination to which the output message will be sent
  sentTo: output
  # the body of the output message
  body:
    bookName: foo
  # the headers of the output message
  headers:
    BOOK-NAME: foo</programlisting>
</para>
</formalpara>
<simpara>In the preceding example, the output message is sent to <literal>output</literal> if a proper message is
received on the <literal>input</literal> destination. On the message <emphasis role="strong">publisher&#8217;s</emphasis> side, the engine
generates a test that sends the input message to the defined destination. On the
<emphasis role="strong">consumer</emphasis> side, you can either send a message to the input destination or use a label
(<literal>some_label</literal> in the example) to trigger the message.</simpara>
</section>
<section xml:id="contract-dsl-consumer-producer">
<title>Consumer/Producer</title>
<important>
<simpara>This section is valid only for Groovy DSL.</simpara>
</important>
<simpara>In HTTP, you have a notion of <literal>client</literal>/<literal>stub and `server</literal>/<literal>test</literal> notation. You can also
use those paradigms in messaging. In addition, Spring Cloud Contract Verifier also
provides the <literal>consumer</literal> and <literal>producer</literal> methods, as presented in the following example
(note that you can use either <literal>$</literal> or <literal>value</literal> methods to provide <literal>consumer</literal> and <literal>producer</literal>
parts):</simpara>
<programlisting language="groovy" linenumbering="unnumbered">Contract.make {
	label 'some_label'
	input {
		messageFrom value(consumer('jms:output'), producer('jms:input'))
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo $(consumer('jms:input'), producer('jms:output'))
		body([
				bookName: 'foo'
		])
	}
}</programlisting>
</section>
<section xml:id="contract-dsl-common">
<title>Common</title>
<simpara>In the <literal>input</literal> or <literal>outputMessage</literal> section you can call <literal>assertThat</literal> with the name
of a <literal>method</literal> (e.g. <literal>assertThatMessageIsOnTheQueue()</literal>) that you have defined in the
base class or in a static import. Spring Cloud Contract will execute that method
in the generated test.</simpara>
</section>
</section>
<section xml:id="_multiple_contracts_in_one_file">
<title>Multiple Contracts in One File</title>
<simpara>You can define multiple contracts in one file. Such a contract might resemble the
following example:</simpara>
<formalpara>
<title>Groovy DSL</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">import org.springframework.cloud.contract.spec.Contract

[
        Contract.make {
            name("should post a user")
            request {
                method 'POST'
                url('/users/1')
            }
            response {
                status 200
            }
        },
        Contract.make {
            request {
                method 'POST'
                url('/users/2')
            }
            response {
                status 200
            }
        }
]</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">---
name: should post a user
request:
  method: POST
  url: /users/1
response:
  status: 200

---
request:
  method: POST
  url: /users/2
response:
  status: 200</programlisting>
</para>
</formalpara>
<simpara>In the preceding example, one contract has the <literal>name</literal> field and the other does not. This
leads to generation of two tests that look more or less like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">package org.springframework.cloud.contract.verifier.tests.com.hello;

import com.example.TestBase;
import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import com.jayway.restassured.module.mockmvc.specification.MockMvcRequestSpecification;
import com.jayway.restassured.response.ResponseOptions;
import org.junit.Test;

import static com.jayway.restassured.module.mockmvc.RestAssuredMockMvc.*;
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson;
import static org.assertj.core.api.Assertions.assertThat;

public class V1Test extends TestBase {

	@Test
	public void validate_should_post_a_user() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.post("/users/1");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
	}

	@Test
	public void validate_withList_1() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.post("/users/2");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
	}

}</programlisting>
<simpara>Notice that, for the contract that has the <literal>name</literal> field, the generated test method is named
<literal>validate_should_post_a_user</literal>. For the one that does not have the name, it is called
<literal>validate_withList_1</literal>. It corresponds to the name of the file <literal>WithList.groovy</literal> and the
index of the contract in the list.</simpara>
<simpara>The generated stubs is shown in the following example:</simpara>
<screen>should post a user.json
1_WithList.json</screen>
<simpara>As you can see, the first file got the <literal>name</literal> parameter from the contract. The second
got the name of the contract file (<literal>WithList.groovy</literal>) prefixed with the index (in this
case, the contract had an index of <literal>1</literal> in the list of contracts in the file).</simpara>
<tip>
<simpara>As you can see, it iss much better if you name your contracts because doing so makes
your tests far more meaningful.</simpara>
</tip>
</section>
</chapter>
<chapter xml:id="_customization">
<title>Customization</title>
<important>
<simpara>This section is valid only for Groovy DSL</simpara>
</important>
<simpara>You can customize the Spring Cloud Contract Verifier by extending the DSL, as shown in
the remainder of this section.</simpara>
<section xml:id="_extending_the_dsl">
<title>Extending the DSL</title>
<simpara>You can provide your own functions to the DSL. The key requirement for this feature is to
maintain the static compatibility. Later in this document, you can see examples of:</simpara>
<itemizedlist>
<listitem>
<simpara>Creating a JAR with reusable classes.</simpara>
</listitem>
<listitem>
<simpara>Referencing of these classes in the DSLs.</simpara>
</listitem>
</itemizedlist>
<simpara>You can find the full example
<link xl:href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples">here</link>.</simpara>
<section xml:id="_common_jar">
<title>Common JAR</title>
<simpara>The following examples show three classes that can be reused in the DSLs.</simpara>
<simpara><emphasis role="strong">PatternUtils</emphasis> contains functions used by both the <emphasis role="strong">consumer</emphasis> and the <emphasis role="strong">producer</emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.example;

import java.util.regex.Pattern;

/**
 * If you want to use {@link Pattern} directly in your tests
 * then you can create a class resembling this one. It can
 * contain all the {@link Pattern} you want to use in the DSL.
 *
 * &lt;pre&gt;
 * {@code
 * request {
 *     body(
 *         [ age: $(c(PatternUtils.oldEnough()))]
 *     )
 * }
 * &lt;/pre&gt;
 *
 * Notice that we're using both {@code $()} for dynamic values
 * and {@code c()} for the consumer side.
 *
 * @author Marcin Grzejszczak
 */
//tag::impl[]
public class PatternUtils {

	public static String tooYoung() {
		//remove::start[]
		return "[0-1][0-9]";
		//remove::end[return]
	}

	public static Pattern oldEnough() {
		//remove::start[]
		return Pattern.compile("[2-9][0-9]");
		//remove::end[return]
	}

	/**
	 * Makes little sense but it's just an example ;)
	 */
	public static Pattern ok() {
		//remove::start[]
		return Pattern.compile("OK");
		//remove::end[return]
	}
}
//end::impl[]</programlisting>
<simpara><emphasis role="strong">ConsumerUtils</emphasis> contains functions used by the <emphasis role="strong">consumer</emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.example;

import org.springframework.cloud.contract.spec.internal.ClientDslProperty;

/**
 * DSL Properties passed to the DSL from the consumer's perspective.
 * That means that on the input side {@code Request} for HTTP
 * or {@code Input} for messaging you can have a regular expression.
 * On the {@code Response} for HTTP or {@code Output} for messaging
 * you have to have a concrete value.
 *
 * @author Marcin Grzejszczak
 */
//tag::impl[]
public class ConsumerUtils {
	/**
	 * Consumer side property. By using the {@link ClientDslProperty}
	 * you can omit most of boilerplate code from the perspective
	 * of dynamic values. Example
	 *
	 * &lt;pre&gt;
	 * {@code
	 * request {
	 *     body(
	 *         [ age: $(ConsumerUtils.oldEnough())]
	 *     )
	 * }
	 * &lt;/pre&gt;
	 *
	 * That way it's in the implementation that we decide what value we will pass to the consumer
	 * and which one to the producer.
	 *
	 * @author Marcin Grzejszczak
	 */
	public static ClientDslProperty oldEnough() {
		//remove::start[]
		// this example is not the best one and
		// theoretically you could just pass the regex instead of `ServerDslProperty` but
		// it's just to show some new tricks :)
		return new ClientDslProperty(PatternUtils.oldEnough(), 40);
		//remove::end[return]
	}

}
//end::impl[]</programlisting>
<simpara><emphasis role="strong">ProducerUtils</emphasis> contains functions used by the <emphasis role="strong">producer</emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.example;

import org.springframework.cloud.contract.spec.internal.ServerDslProperty;

/**
 * DSL Properties passed to the DSL from the producer's perspective.
 * That means that on the input side {@code Request} for HTTP
 * or {@code Input} for messaging you have to have a concrete value.
 * On the {@code Response} for HTTP or {@code Output} for messaging
 * you can have a regular expression.
 *
 * @author Marcin Grzejszczak
 */
//tag::impl[]
public class ProducerUtils {

	/**
	 * Producer side property. By using the {@link ProducerUtils}
	 * you can omit most of boilerplate code from the perspective
	 * of dynamic values. Example
	 *
	 * &lt;pre&gt;
	 * {@code
	 * response {
	 *     body(
	 *         [ status: $(ProducerUtils.ok())]
	 *     )
	 * }
	 * &lt;/pre&gt;
	 *
	 * That way it's in the implementation that we decide what value we will pass to the consumer
	 * and which one to the producer.
	 */
	public static ServerDslProperty ok() {
		// this example is not the best one and
		// theoretically you could just pass the regex instead of `ServerDslProperty` but
		// it's just to show some new tricks :)
		return new ServerDslProperty( PatternUtils.ok(), "OK");
	}
}
//end::impl[]</programlisting>
</section>
<section xml:id="_adding_the_dependency_to_the_project">
<title>Adding the Dependency to the Project</title>
<simpara>In order for the plugins and IDE to be able to reference the common JAR classes, you need
to pass the dependency to your project.</simpara>
</section>
<section xml:id="_test_the_dependency_in_the_project_s_dependencies">
<title>Test the Dependency in the Project&#8217;s Dependencies</title>
<simpara>First, add the common jar dependency as a test dependency. Because your contracts files
are available on the test resources path,  the common jar classes automatically become
visible in your Groovy files. The following examples show how to test the dependency:</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
	&lt;groupId&gt;com.example&lt;/groupId&gt;
	&lt;artifactId&gt;beer-common&lt;/artifactId&gt;
	&lt;version&gt;${project.version}&lt;/version&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">testCompile("com.example:beer-common:0.0.1-SNAPSHOT")</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_test_a_dependency_in_the_plugin_s_dependencies">
<title>Test a Dependency in the Plugin&#8217;s Dependencies</title>
<simpara>Now, you must add the dependency for the plugin to reuse at runtime, as shown in the
following example:</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example&lt;/packageWithBaseClasses&gt;
		&lt;baseClassMappings&gt;
			&lt;baseClassMapping&gt;
				&lt;contractPackageRegex&gt;.*intoxication.*&lt;/contractPackageRegex&gt;
				&lt;baseClassFQN&gt;com.example.intoxication.BeerIntoxicationBase&lt;/baseClassFQN&gt;
			&lt;/baseClassMapping&gt;
		&lt;/baseClassMappings&gt;
	&lt;/configuration&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.example&lt;/groupId&gt;
			&lt;artifactId&gt;beer-common&lt;/artifactId&gt;
			&lt;version&gt;${project.version}&lt;/version&gt;
			&lt;scope&gt;compile&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/plugin&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">classpath "com.example:beer-common:0.0.1-SNAPSHOT"</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_referencing_classes_in_dsls">
<title>Referencing classes in DSLs</title>
<simpara>You can now reference your classes in your DSL, as shown in the following example:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">package contracts.beer.rest

import com.example.ConsumerUtils
import com.example.ProducerUtils
import org.springframework.cloud.contract.spec.Contract

Contract.make {
	description("""
Represents a successful scenario of getting a beer

```
given:
	client is old enough
when:
	he applies for a beer
then:
	we'll grant him the beer
```

""")
	request {
		method 'POST'
		url '/check'
		body(
				age: $(ConsumerUtils.oldEnough())
		)
		headers {
			contentType(applicationJson())
		}
	}
	response {
		status 200
		body("""
			{
				"status": "${value(ProducerUtils.ok())}"
			}
			""")
		headers {
			contentType(applicationJson())
		}
	}
}</programlisting>
</section>
</section>
</chapter>
<chapter xml:id="_using_the_pluggable_architecture">
<title>Using the Pluggable Architecture</title>
<simpara>You may encounter cases where you have your contracts have been defined in other formats,
such as YAML, RAML or PACT. In those cases, you still want to benefit from the automatic
generation of tests and stubs. You can add your own implementation for generating both
tests and stubs. Also, you can customize the way tests are generated (for example, you
can generate tests for other languages) and the way stubs are generated (for example, you
can generate stubs for other HTTP server implementations).</simpara>
<section xml:id="_custom_contract_converter">
<title>Custom Contract Converter</title>
<simpara>The <literal>ContractConverter</literal> interface lets you register your own implementation of a contract
structure converter. The following code listing shows the <literal>ContractConverter</literal> interface:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">package org.springframework.cloud.contract.spec

/**
 * Converter to be used to convert FROM {@link File} TO {@link Contract}
 * and from {@link Contract} to {@code T}
 *
 * @param &lt;T&gt; - type to which we want to convert the contract
 *
 * @author Marcin Grzejszczak
 * @since 1.1.0
 */
interface ContractConverter&lt;T&gt; {

	/**
	 * Should this file be accepted by the converter. Can use the file extension
	 * to check if the conversion is possible.
	 *
	 * @param file - file to be considered for conversion
	 * @return - {@code true} if the given implementation can convert the file
	 */
	boolean isAccepted(File file)

	/**
	 * Converts the given {@link File} to its {@link Contract} representation
	 *
	 * @param file - file to convert
	 * @return - {@link Contract} representation of the file
	 */
	Collection&lt;Contract&gt; convertFrom(File file)

	/**
	 * Converts the given {@link Contract} to a {@link T} representation
	 *
	 * @param contract - the parsed contract
	 * @return - {@link T} the type to which we do the conversion
	 */
	T convertTo(Collection&lt;Contract&gt; contract)
}</programlisting>
<simpara>Your implementation must define the condition on which it should start the
conversion. Also, you must define how to perform that conversion in both directions.</simpara>
<important>
<simpara>Once you create your implementation, you must create a
<literal>/META-INF/spring.factories</literal> file in which you provide the fully qualified name of your
implementation.</simpara>
</important>
<simpara>The following example shows a typical <literal>spring.factories</literal> file:</simpara>
<screen>org.springframework.cloud.contract.spec.ContractConverter=\
org.springframework.cloud.contract.verifier.converter.YamlContractConverter</screen>
<section xml:id="_pact_converter">
<title>Pact Converter</title>
<simpara>Spring Cloud Contract includes support for <link xl:href="https://docs.pact.io/">Pact</link> representation of
contracts. Instead of using the Groovy DSL, you can use Pact files. In this section, we
present how to add Pact support for your project.</simpara>
</section>
<section xml:id="_pact_contract">
<title>Pact Contract</title>
<simpara>Consider following example of a Pact contract, which is a file under the
<literal>src/test/resources/contracts</literal> folder.</simpara>
<programlisting language="javascript" linenumbering="unnumbered">{
  "provider": {
    "name": "Provider"
  },
  "consumer": {
    "name": "Consumer"
  },
  "interactions": [
    {
      "description": "",
      "request": {
        "method": "PUT",
        "path": "/fraudcheck",
        "headers": {
          "Content-Type": "application/vnd.fraud.v1+json"
        },
        "body": {
          "clientId": "1234567890",
          "loanAmount": 99999
        },
        "matchingRules": {
          "$.body.clientId": {
            "match": "regex",
            "regex": "[0-9]{10}"
          }
        }
      },
      "response": {
        "status": 200,
        "headers": {
          "Content-Type": "application/vnd.fraud.v1+json;charset=UTF-8"
        },
        "body": {
          "fraudCheckStatus": "FRAUD",
          "rejectionReason": "Amount too high"
        },
        "matchingRules": {
          "$.body.fraudCheckStatus": {
            "match": "regex",
            "regex": "FRAUD"
          }
        }
      }
    }
  ],
  "metadata": {
    "pact-specification": {
      "version": "2.0.0"
    },
    "pact-jvm": {
      "version": "2.4.18"
    }
  }
}</programlisting>
<simpara>The remainder of this section about using Pact refers to the preceding file.</simpara>
</section>
<section xml:id="_pact_for_producers">
<title>Pact for Producers</title>
<simpara>On the producer side, you mustadd two additional dependencies to your plugin
configuration. One is the Spring Cloud Contract Pact support, and the other represents
the current Pact version that you use.</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-contract-spec-pact&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;au.com.dius&lt;/groupId&gt;
			&lt;artifactId&gt;pact-jvm-model&lt;/artifactId&gt;
			&lt;version&gt;2.4.18&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/plugin&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">classpath "org.springframework.cloud:spring-cloud-contract-spec-pact:${findProperty('verifierVersion') ?: verifierVersion}"
classpath 'au.com.dius:pact-jvm-model:2.4.18'</programlisting>
</para>
</formalpara>
<simpara>When you execute the build of your application, a test will be generated. The generated
test might be as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Test
public void validate_shouldMarkClientAsFraud() throws Exception {
	// given:
		MockMvcRequestSpecification request = given()
				.header("Content-Type", "application/vnd.fraud.v1+json")
				.body("{\"clientId\":\"1234567890\",\"loanAmount\":99999}");

	// when:
		ResponseOptions response = given().spec(request)
				.put("/fraudcheck");

	// then:
		assertThat(response.statusCode()).isEqualTo(200);
		assertThat(response.header("Content-Type")).isEqualTo("application/vnd.fraud.v1+json;charset=UTF-8");
	// and:
		DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
		assertThatJson(parsedJson).field("rejectionReason").isEqualTo("Amount too high");
	// and:
		assertThat(parsedJson.read("$.fraudCheckStatus", String.class)).matches("FRAUD");
}</programlisting>
<simpara>The corresponding generated stub might be as follows:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">{
  "uuid" : "996ae5ae-6834-4db6-8fac-358ca187ab62",
  "request" : {
    "url" : "/fraudcheck",
    "method" : "PUT",
    "headers" : {
      "Content-Type" : {
        "equalTo" : "application/vnd.fraud.v1+json"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.loanAmount == 99999)]"
    }, {
      "matchesJsonPath" : "$[?(@.clientId =~ /([0-9]{10})/)]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\"fraudCheckStatus\":\"FRAUD\",\"rejectionReason\":\"Amount too high\"}",
    "headers" : {
      "Content-Type" : "application/vnd.fraud.v1+json;charset=UTF-8"
    }
  }
}</programlisting>
</section>
<section xml:id="_pact_for_consumers">
<title>Pact for Consumers</title>
<simpara>On the producer side, you must add two additional dependencies to your project
dependencies. One is the Spring Cloud Contract Pact support, and the other represents the
current Pact version that you use.</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-spec-pact&lt;/artifactId&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;au.com.dius&lt;/groupId&gt;
	&lt;artifactId&gt;pact-jvm-model&lt;/artifactId&gt;
	&lt;version&gt;2.4.18&lt;/version&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">testCompile "org.springframework.cloud:spring-cloud-contract-spec-pact"
testCompile 'au.com.dius:pact-jvm-model:2.4.18'</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_using_the_custom_test_generator">
<title>Using the Custom Test Generator</title>
<simpara>If you want to generate tests for languages other than Java or you are not happy with the
way the verifier builds Java tests, you can register your own implementation.</simpara>
<simpara>The <literal>SingleTestGenerator</literal> interface lets you register your own implementation.  The
following code listing shows the <literal>SingleTestGenerator</literal> interface:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">package org.springframework.cloud.contract.verifier.builder

import org.springframework.cloud.contract.verifier.config.ContractVerifierConfigProperties
import org.springframework.cloud.contract.verifier.file.ContractMetadata
/**
 * Builds a single test.
 *
 * @since 1.1.0
 */
interface SingleTestGenerator {

	/**
	 * Creates contents of a single test class in which all test scenarios from
	 * the contract metadata should be placed.
	 *
	 * @param properties - properties passed to the plugin
	 * @param listOfFiles - list of parsed contracts with additional metadata
	 * @param className - the name of the generated test class
	 * @param classPackage - the name of the package in which the test class should be stored
	 * @param includedDirectoryRelativePath - relative path to the included directory
	 * @return contents of a single test class
	 */
	String buildClass(ContractVerifierConfigProperties properties, Collection&lt;ContractMetadata&gt; listOfFiles,
					  String className, String classPackage, String includedDirectoryRelativePath)

	/**
	 * Extension that should be appended to the generated test class. E.g. {@code .java} or {@code .php}
	 *
	 * @param properties - properties passed to the plugin
	 */
	String fileExtension(ContractVerifierConfigProperties properties)
}</programlisting>
<simpara>Again, you must provide a <literal>spring.factories</literal> file, such as the one shown in the following
example:</simpara>
<screen>org.springframework.cloud.contract.verifier.builder.SingleTestGenerator=/
com.example.MyGenerator</screen>
</section>
<section xml:id="_using_the_custom_stub_generator">
<title>Using the Custom Stub Generator</title>
<simpara>If you want to generate stubs for stub servers other than WireMock, you can plug in your
own implementation of the <literal>StubGenerator</literal> interface. The following code listing shows the
<literal>StubGenerator</literal> interface:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">package org.springframework.cloud.contract.verifier.converter

import groovy.transform.CompileStatic
import org.springframework.cloud.contract.spec.Contract
import org.springframework.cloud.contract.verifier.file.ContractMetadata

/**
 * Converts contracts into their stub representation.
 *
 * @since 1.1.0
 */
@CompileStatic
interface StubGenerator {

	/**
	 * Returns {@code true} if the converter can handle the file to convert it into a stub.
	 */
	boolean canHandleFileName(String fileName)

	/**
	 * Returns the collection of converted contracts into stubs. One contract can
	 * result in multiple stubs.
	 */
	Map&lt;Contract, String&gt; convertContents(String rootName, ContractMetadata content)

	/**
	 * Returns the name of the converted stub file. If you have multiple contracts
	 * in a single file then a prefix will be added to the generated file. If you
	 * provide the {@link Contract#name} field then that field will override the
	 * generated file name.
	 *
	 * Example: name of file with 2 contracts is {@code foo.groovy}, it will be
	 * converted by the implementation to {@code foo.json}. The recursive file
	 * converter will create two files {@code 0_foo.json} and {@code 1_foo.json}
	 */
	String generateOutputFileNameForInput(String inputFileName)
}</programlisting>
<simpara>Again, you must provide a <literal>spring.factories</literal> file, such as the one shown in the following
example:</simpara>
<screen># Stub converters
org.springframework.cloud.contract.verifier.converter.StubGenerator=\
org.springframework.cloud.contract.verifier.wiremock.DslToWireMockClientConverter</screen>
<simpara>The default implementation is the WireMock stub generation.</simpara>
<tip>
<simpara>You can provide multiple stub generator implementations. For example, from a single
DSL, you can produce both WireMock stubs and Pact files.</simpara>
</tip>
</section>
<section xml:id="_using_the_custom_stub_runner">
<title>Using the Custom Stub Runner</title>
<simpara>If you decide to use a custom stub generation, you also need a custom way of running
stubs with your different stub provider.</simpara>
<simpara>Assume that you use <link xl:href="https://github.com/dreamhead/moco">Moco</link> to build your stubs and that
you have written a stub generator and placed your stubs in a JAR file.</simpara>
<simpara>In order for Stub Runner to know how to run your stubs, you have to define a custom
HTTP Stub server implementation, which might resemble the following example:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">package org.springframework.cloud.contract.stubrunner.provider.moco

import com.github.dreamhead.moco.bootstrap.arg.HttpArgs
import com.github.dreamhead.moco.runner.JsonRunner
import com.github.dreamhead.moco.runner.RunnerSetting
import groovy.util.logging.Slf4j
import org.springframework.cloud.contract.stubrunner.HttpServerStub
import org.springframework.util.SocketUtils

@Slf4j
class MocoHttpServerStub implements HttpServerStub {

	private boolean started
	private JsonRunner runner
	private int port

	@Override
	int port() {
		if (!isRunning()) {
			return -1
		}
		return port
	}

	@Override
	boolean isRunning() {
		return started
	}

	@Override
	HttpServerStub start() {
		return start(SocketUtils.findAvailableTcpPort())
	}

	@Override
	HttpServerStub start(int port) {
		this.port = port
		return this
	}

	@Override
	HttpServerStub stop() {
		if (!isRunning()) {
			return this
		}
		this.runner.stop()
		return this
	}

	@Override
	HttpServerStub registerMappings(Collection&lt;File&gt; stubFiles) {
		List&lt;RunnerSetting&gt; settings = stubFiles.findAll { it.name.endsWith("json") }
				.collect {
			log.info("Trying to parse [{}]", it.name)
			try {
				return RunnerSetting.aRunnerSetting().withStream(it.newInputStream()).build()
			} catch (Exception e) {
				log.warn("Exception occurred while trying to parse file [{}]", it.name, e)
				return null
			}
		}.findAll { it }
		this.runner = JsonRunner.newJsonRunnerWithSetting(settings,
				HttpArgs.httpArgs().withPort(this.port).build())
		this.runner.run()
		this.started = true
		return this
	}

	@Override
	String registeredMappings() {
		return ""
	}

	@Override
	boolean isAccepted(File file) {
		return file.name.endsWith(".json")
	}
}</programlisting>
<simpara>Then, you can register it in your <literal>spring.factories</literal> file, as shown in the following
example:</simpara>
<screen>org.springframework.cloud.contract.stubrunner.HttpServerStub=\
org.springframework.cloud.contract.stubrunner.provider.moco.MocoHttpServerStub</screen>
<simpara>Now you can run stubs with Moco.</simpara>
<important>
<simpara>If you do not provide any implementation, then the default (WireMock)
implementation is used. If you provide more than one, the first one on the list is used.</simpara>
</important>
</section>
<section xml:id="_using_the_custom_stub_downloader">
<title>Using the Custom Stub Downloader</title>
<simpara>You can customize the way your stubs are downloaded by creating an implementation of the
<literal>StubDownloaderBuilder</literal> interface, as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.example;

class CustomStubDownloaderBuilder implements StubDownloaderBuilder {

	@Override
	public StubDownloader build(final StubRunnerOptions stubRunnerOptions) {
		return new StubDownloader() {
			@Override
			public Map.Entry&lt;StubConfiguration, File&gt; downloadAndUnpackStubJar(
					StubConfiguration config) {
				File unpackedStubs = retrieveStubs();
				return new AbstractMap.SimpleEntry&lt;&gt;(
						new StubConfiguration(config.getGroupId(), config.getArtifactId(), version,
								config.getClassifier()), unpackedStubs);
			}

			File retrieveStubs() {
			    // here goes your custom logic to provide a folder where all the stubs reside
			}
}</programlisting>
<simpara>Then you can register it in your <literal>spring.factories</literal> file, as shown in the following
example:</simpara>
<screen># Example of a custom Stub Downloader Provider
org.springframework.cloud.contract.stubrunner.StubDownloaderBuilder=\
com.example.CustomStubDownloaderBuilder</screen>
<simpara>Now you can pick a folder with the source of your stubs.</simpara>
<important>
<simpara>If you do not provide any implementation, then the default is used.
If you use the <literal>repositoryRoot</literal> property or the <literal>workOffline</literal> flag, then an Aether-based
implementation that downloads stubs from a remote repository is used. If you do not
provide these values, the <literal>ClasspathStubProvider</literal> (which will scan the classpath) is
used. If you provide more than one, then the first one on the list is used.</simpara>
</important>
</section>
</chapter>
<chapter xml:id="_spring_cloud_contract_wiremock">
<title>Spring Cloud Contract WireMock</title>
<simpara>The Spring Cloud Contract WireMock modules let you use <link xl:href="http://wiremock.org">WireMock</link> in a
Spring Boot application. Check out the
<link xl:href="https://github.com/spring-cloud/spring-cloud-contract/tree/master/samples">samples</link>
for more details.</simpara>
<simpara>If you have a Spring Boot application that uses Tomcat as an embedded server (which is
the default with <literal>spring-boot-starter-web</literal>),  you can add
<literal>spring-cloud-contract-wiremock</literal> to your classpath and add <literal>@AutoConfigureWireMock</literal> in
order to be able to use Wiremock in your tests. Wiremock runs as a stub server and you
can register stub behavior using a Java API or via static JSON declarations as part of
your test. The following code shows an example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureWireMock(port = 0)
public class WiremockForDocsTests {
	// A service that calls out over HTTP
	@Autowired private Service service;

	// Using the WireMock APIs in the normal way:
	@Test
	public void contextLoads() throws Exception {
		// Stubbing WireMock
		stubFor(get(urlEqualTo("/resource"))
				.willReturn(aResponse().withHeader("Content-Type", "text/plain").withBody("Hello World!")));
		// We're asserting if WireMock responded properly
		assertThat(this.service.go()).isEqualTo("Hello World!");
	}

}</programlisting>
<simpara>To start the stub server on a different port use (for example),
<literal>@AutoConfigureWireMock(port=9999)</literal>. For a random port, use a value of <literal>0</literal>. The stub
server port can be bound in the test application context with the "wiremock.server.port"
property. Using <literal>@AutoConfigureWireMock</literal> adds a bean of type <literal>WiremockConfiguration</literal> to
your test application context, where it will be cached in between methods and classes
having the same context, the same as for Spring integration tests.</simpara>
<section xml:id="_registering_stubs_automatically">
<title>Registering Stubs Automatically</title>
<simpara>If you use <literal>@AutoConfigureWireMock</literal>, it registers WireMock JSON stubs from the file
system or classpath (by default, from <literal>file:src/test/resources/mappings</literal>). You can
customize the locations using the <literal>stubs</literal> attribute in the annotation, which can be an
Ant-style resource pattern or a directory. In the case of a directory, <literal><emphasis role="strong">*/</emphasis>.json</literal> is
appended. The following code shows an example:</simpara>
<screen>@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureWireMock(stubs="classpath:/stubs")
public class WiremockImportApplicationTests {

	@Autowired
	private Service service;

	@Test
	public void contextLoads() throws Exception {
		assertThat(this.service.go()).isEqualTo("Hello World!");
	}

}</screen>
<note>
<simpara>Actually, WireMock always loads mappings from <literal>src/test/resources/mappings</literal> <emphasis role="strong">as
well as</emphasis> the custom locations in the stubs attribute. To change this behavior, you can
also specify a files root as described in the next section of this document.</simpara>
</note>
</section>
<section xml:id="_using_files_to_specify_the_stub_bodies">
<title>Using Files to Specify the Stub Bodies</title>
<simpara>WireMock can read response bodies from files on the classpath or the file system. In that
case, you can see in the JSON DSL that the response has a <literal>bodyFileName</literal> instead of a
(literal) <literal>body</literal>. The files are resolved relative to a root directory (by default,
<literal>src/test/resources/__files</literal>). To customize this location you can set the <literal>files</literal>
attribute in the <literal>@AutoConfigureWireMock</literal> annotation to the location of the parent
directory (in other words, <literal>__files</literal> is a subdirectory). You can use Spring resource
notation to refer to <literal>file:&#8230;&#8203;</literal> or <literal>classpath:&#8230;&#8203;</literal> locations. Generic URLs are not
supported. A list of values can be given, in which case WireMock resolves the first file
that exists when it needs to find a response body.</simpara>
<note>
<simpara>When you configure the <literal>files</literal> root, it also affects the
automatic loading of stubs, because they come from the root location
in a subdirectory called "mappings". The value of <literal>files</literal> has no
effect on the stubs loaded explicitly from the <literal>stubs</literal> attribute.</simpara>
</note>
</section>
<section xml:id="_alternative_using_junit_rules">
<title>Alternative: Using JUnit Rules</title>
<simpara>For a more conventional WireMock experience, you can use JUnit <literal>@Rules</literal> to start and stop
the server. To do so, use the <literal>WireMockSpring</literal> convenience class to obtain an <literal>Options</literal>
instance, as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class WiremockForDocsClassRuleTests {

	// Start WireMock on some dynamic port
	// for some reason `dynamicPort()` is not working properly
	@ClassRule
	public static WireMockClassRule wiremock = new WireMockClassRule(
			WireMockSpring.options().dynamicPort());
	// A service that calls out over HTTP to localhost:${wiremock.port}
	@Autowired
	private Service service;

	// Using the WireMock APIs in the normal way:
	@Test
	public void contextLoads() throws Exception {
		// Stubbing WireMock
		wiremock.stubFor(get(urlEqualTo("/resource"))
				.willReturn(aResponse().withHeader("Content-Type", "text/plain").withBody("Hello World!")));
		// We're asserting if WireMock responded properly
		assertThat(this.service.go()).isEqualTo("Hello World!");
	}

}</programlisting>
<simpara>The <literal>@ClassRule</literal> means that the server shuts down after all the methods in this class
have been run.</simpara>
</section>
<section xml:id="_relaxed_ssl_validation_for_rest_template">
<title>Relaxed SSL Validation for Rest Template</title>
<simpara>WireMock lets you stub a "secure" server with an "https" URL protocol. If your
application wants to contact that stub server in an integration test, it will find that
the SSL certificates are not valid (the usual problem with self-installed certificates).
The best option is often to re-configure the client to use "http". If that&#8217;s not an
option, you can ask Spring to configure an HTTP client that ignores SSL validation errors
(do so only for tests, of course).</simpara>
<simpara>To make this work with minimum fuss, you need to be using the Spring Boot
<literal>RestTemplateBuilder</literal> in your app, as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Bean
public RestTemplate restTemplate(RestTemplateBuilder builder) {
	return builder.build();
}</programlisting>
<simpara>You need <literal>RestTemplateBuilder</literal> because the builder is passed through callbacks to
initialize it, so the SSL validation can be set up in the client at that point. This
happens automatically in your test if you are using the <literal>@AutoConfigureWireMock</literal>
annotation or the stub runner. If you use the JUnit <literal>@Rule</literal> approach, you need to add the
<literal>@AutoConfigureHttpClient</literal> annotation as well, as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RunWith(SpringRunner.class)
@SpringBootTest("app.baseUrl=https://localhost:6443")
@AutoConfigureHttpClient
public class WiremockHttpsServerApplicationTests {

	@ClassRule
	public static WireMockClassRule wiremock = new WireMockClassRule(
			WireMockSpring.options().httpsPort(6443));
...
}</programlisting>
<simpara>If you are using <literal>spring-boot-starter-test</literal>, you have the Apache HTTP client on the
classpath and it is selected by the <literal>RestTemplateBuilder</literal> and configured to ignore SSL
errors. If you use the default <literal>java.net</literal> client, you do not need the annotation (but it
won&#8217;t do any harm). There is no support currently for other clients, but it may be added
in future releases.</simpara>
</section>
<section xml:id="_wiremock_and_spring_mvc_mocks">
<title>WireMock and Spring MVC Mocks</title>
<simpara>Spring Cloud Contract provides a convenience class that can load JSON WireMock stubs into
a Spring <literal>MockRestServiceServer</literal>. The following code shows an example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
public class WiremockForDocsMockServerApplicationTests {

	@Autowired
	private RestTemplate restTemplate;

	@Autowired
	private Service service;

	@Test
	public void contextLoads() throws Exception {
		// will read stubs classpath
		MockRestServiceServer server = WireMockRestServiceServer.with(this.restTemplate)
				.baseUrl("https://example.org").stubs("classpath:/stubs/resource.json")
				.build();
		// We're asserting if WireMock responded properly
		assertThat(this.service.go()).isEqualTo("Hello World");
		server.verify();
	}
}</programlisting>
<simpara>The <literal>baseUrl</literal> value is prepended to all mock calls, and the <literal>stubs()</literal> method takes a stub
path resource pattern as an argument. In the preceding example, the stub defined at
<literal>/stubs/resource.json</literal> is loaded into the mock server. If the <literal>RestTemplate</literal> is asked to
visit <literal><link xl:href="https://example.org/">https://example.org/</link></literal>, it gets the responses as being declared at that URL. More
than one stub pattern can be specified, and each one can be a directory (for a recursive
list of all ".json"), a fixed filename (as in the example above), or an Ant-style
pattern. The JSON format is the normal WireMock format, which you can read about in the
<link xl:href="http://wiremock.org/docs/stubbing/">WireMock website</link>.</simpara>
<simpara>Currently, the Spring Cloud Contract Verifier supports Tomcat, Jetty, and Undertow as
Spring Boot embedded servers, and Wiremock itself has "native" support for a particular
version of Jetty (currently 9.2). To use the native Jetty, you need to add the native
Wiremock dependencies and exclude the Spring Boot container (if there is one).</simpara>
</section>
<section xml:id="_customization_of_wiremock_configuration">
<title>Customization of WireMock configuration</title>
<simpara>You can register a bean of <literal>org.springframework.cloud.contract.wiremock.WireMockConfigurationCustomizer</literal> type
in order to customize the WireMock configuration (e.g. add custom transformers).
Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">		@Bean WireMockConfigurationCustomizer optionsCustomizer() {
			return new WireMockConfigurationCustomizer() {
				@Override public void customize(WireMockConfiguration options) {
// perform your customization here
				}
			};
		}</programlisting>
</section>
<section xml:id="_generating_stubs_using_rest_docs">
<title>Generating Stubs using REST Docs</title>
<simpara><link xl:href="https://projects.spring.io/spring-restdocs">Spring REST Docs</link> can be used to generate
documentation (for example in Asciidoctor format) for an HTTP API with Spring MockMvc or
Rest Assured. At the same time that you generate documentation for your API, you can also
generate WireMock stubs by using Spring Cloud Contract WireMock. To do so, write your
normal REST Docs test cases and use <literal>@AutoConfigureRestDocs</literal> to have stubs be
automatically generated in the REST Docs output directory. The following code shows an
example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureRestDocs(outputDir = "target/snippets")
@AutoConfigureMockMvc
public class ApplicationTests {

	@Autowired
	private MockMvc mockMvc;

	@Test
	public void contextLoads() throws Exception {
		mockMvc.perform(get("/resource"))
				.andExpect(content().string("Hello World"))
				.andDo(document("resource"));
	}
}</programlisting>
<simpara>This test generates a WireMock stub at "target/snippets/stubs/resource.json". It matches
all GET requests to the "/resource" path.</simpara>
<simpara>Without any additional configuration, this tests creates a stub with a request matcher
for the HTTP method and all headers except "host" and "content-length". To match the
request more precisely (for example, to match the body of a POST or PUT), we need to
explicitly create a request matcher. Doing so has two effects:</simpara>
<itemizedlist>
<listitem>
<simpara>Creating a stub that matches only in the way you specify.</simpara>
</listitem>
<listitem>
<simpara>Asserting that the request in the test case also matches the same conditions.</simpara>
</listitem>
</itemizedlist>
<simpara>The main entry point for this feature is <literal>WireMockRestDocs.verify()</literal>, which can be used
as a substitute for the <literal>document()</literal> convenience method, as shown in the following
example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureRestDocs(outputDir = "target/snippets")
@AutoConfigureMockMvc
public class ApplicationTests {

	@Autowired
	private MockMvc mockMvc;

	@Test
	public void contextLoads() throws Exception {
		mockMvc.perform(post("/resource")
                .content("{\"id\":\"123456\",\"message\":\"Hello World\"}"))
				.andExpect(status().isOk())
				.andDo(verify().jsonPath("$.id")
                        .stub("resource"));
	}
}</programlisting>
<simpara>This contract specifies that any valid POST with an "id" field receives the response
defined in this test. You can chain together calls to <literal>.jsonPath()</literal> to add additional
matchers. If JSON Path is unfamiliar, The <link xl:href="https://github.com/jayway/JsonPath">JayWay
documentation</link> can help you get up to speed.</simpara>
<simpara>Instead of the <literal>jsonPath</literal> and <literal>contentType</literal> convenience methods, you can also use the
WireMock APIs to verify that the request matches the created stub, as shown in the
following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Test
public void contextLoads() throws Exception {
	mockMvc.perform(post("/resource")
               .content("{\"id\":\"123456\",\"message\":\"Hello World\"}"))
			.andExpect(status().isOk())
			.andDo(verify()
					.wiremock(WireMock.post(
						urlPathEquals("/resource"))
						.withRequestBody(matchingJsonPath("$.id"))
                       .stub("post-resource"));
}</programlisting>
<simpara>The WireMock API is rich. You can match headers, query parameters, and request body by
regex as well as by JSON path. These features can be used to create stubs with a wider
range of parameters. The above example generates a stub resembling the following example:</simpara>
<formalpara>
<title>post-resource.json</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "request" : {
    "url" : "/resource",
    "method" : "POST",
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$.id"
    }]
  },
  "response" : {
    "status" : 200,
    "body" : "Hello World",
    "headers" : {
      "X-Application-Context" : "application:-1",
      "Content-Type" : "text/plain"
    }
  }
}</programlisting>
</para>
</formalpara>
<note>
<simpara>You can use either the <literal>wiremock()</literal> method or the <literal>jsonPath()</literal> and <literal>contentType()</literal>
methods to create request matchers, but you can&#8217;t use both approaches.</simpara>
</note>
<simpara>On the consumer side, you can make the <literal>resource.json</literal> generated earlier in this section
available on the classpath (by
<link xl:href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_publishing_stubs_as_jars">publishing
stubs as JARs</link>, for example). After that, you can create a stub using WireMock in a
number of different ways, including by using
<literal>@AutoConfigureWireMock(stubs="classpath:resource.json")</literal>, as described earlier in this
document.</simpara>
</section>
<section xml:id="_generating_contracts_by_using_rest_docs">
<title>Generating Contracts by Using REST Docs</title>
<simpara>You can also generate Spring Cloud Contract DSL files and documentation with Spring REST
Docs. If you do so in combination with Spring Cloud WireMock, you get both the contracts
and the stubs.</simpara>
<simpara>Why would you want to use this feature? Some people in the community asked questions
about a situation in which they would like to move to DSL-based contract definition,
but they already have a lot of Spring MVC tests. Using this feature lets you generate
the contract files that you can later modify and move to folders (defined in your
configuration) so that the plugin finds them.</simpara>
<tip>
<simpara>You might wonder why this functionality is in the WireMock module. The functionality
is there because it makes sense to generate both the contracts and the stubs.</simpara>
</tip>
<simpara>Consider the following test:</simpara>
<programlisting language="java" linenumbering="unnumbered">		this.mockMvc.perform(post("/foo")
					.accept(MediaType.APPLICATION_PDF)
					.accept(MediaType.APPLICATION_JSON)
					.contentType(MediaType.APPLICATION_JSON)
					.content("{\"foo\": 23, \"bar\" : \"baz\" }"))
				.andExpect(status().isOk())
				.andExpect(content().string("bar"))
				// first WireMock
				.andDo(WireMockRestDocs.verify()
						.jsonPath("$[?(@.foo &gt;= 20)]")
						.jsonPath("$[?(@.bar in ['baz','bazz','bazzz'])]")
						.contentType(MediaType.valueOf("application/json"))
						.stub("shouldGrantABeerIfOldEnough"))
				// then Contract DSL documentation
				.andDo(document("index", SpringCloudContractRestDocs.dslContract()));</programlisting>
<simpara>The preceding test creates the stub presented in the previous section, generating both
the contract and a documentation file.</simpara>
<simpara>The contract is called <literal>index.groovy</literal> and might look like the following example:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">import org.springframework.cloud.contract.spec.Contract

Contract.make {
    request {
        method 'POST'
        url '/foo'
        body('''
            {"foo": 23 }
        ''')
        headers {
            header('''Accept''', '''application/json''')
            header('''Content-Type''', '''application/json''')
        }
    }
    response {
        status 200
        body('''
        bar
        ''')
        headers {
            header('''Content-Type''', '''application/json;charset=UTF-8''')
            header('''Content-Length''', '''3''')
        }
        testMatchers {
            jsonPath('$[?(@.foo &gt;= 20)]', byType())
        }
    }
}</programlisting>
<simpara>The generated document (formatted in Asciidoc in this case) contains a formatted
contract. The location of this file would be <literal>index/dsl-contract.adoc</literal>.</simpara>
</section>
</chapter>
<chapter xml:id="_migrations">
<title>Migrations</title>
<simpara>This section covers migrating from one version of Spring Cloud Contract Verifier to the
next version. It covers the following versions upgrade paths:</simpara>
<section xml:id="cloud-verifier-1.0-1.1">
<title>1.0.x &#8594; 1.1.x</title>
<simpara>This section covers upgrading from version 1.0 to version 1.1.</simpara>
<section xml:id="_new_structure_of_generated_stubs">
<title>New structure of generated stubs</title>
<simpara>In <literal>1.1.x</literal> we have introduced a change to the structure of generated stubs. If you have
been using the  <literal>@AutoConfigureWireMock</literal> notation to use the stubs from the classpath,
it no longer works. The following example shows how the <literal>@AutoConfigureWireMock</literal> notation
used to work:</simpara>
<programlisting language="java" linenumbering="unnumbered">@AutoConfigureWireMock(stubs = "classpath:/customer-stubs/mappings", port = 8084)</programlisting>
<simpara>You must either change the location of the stubs to:
<literal>classpath:&#8230;&#8203;/META-INF/groupId/artifactId/version/mappings</literal> or use the new
classpath-based <literal>@AutoConfigureStubRunner</literal>, as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@AutoConfigureWireMock(stubs = "classpath:customer-stubs/META-INF/travel.components/customer-contract/1.0.2-SNAPSHOT/mappings/", port = 8084)</programlisting>
<simpara>If you do not want to use <literal>@AutoConfigureStubRunner</literal> and you want to remain with the old
structure, set your plugin tasks accordingly. The following example would work for the
structure presented in the previous snippet.</simpara>
<formalpara role="primary">
<title>Maven</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- start of pom.xml --&gt;

&lt;properties&gt;
    &lt;!-- we don't want the verifier to do a jar for us --&gt;
    &lt;spring.cloud.contract.verifier.skip&gt;true&lt;/spring.cloud.contract.verifier.skip&gt;
&lt;/properties&gt;

&lt;!-- ... --&gt;

&lt;!-- You need to set up the assembly plugin --&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;stub&lt;/id&gt;
                    &lt;phase&gt;prepare-package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;single&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;inherited&gt;false&lt;/inherited&gt;
                    &lt;configuration&gt;
                        &lt;attach&gt;true&lt;/attach&gt;
                        &lt;descriptor&gt;$../../../../src/assembly/stub.xml&lt;/descriptor&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
&lt;!-- end of pom.xml --&gt;

&lt;!-- start of stub.xml--&gt;

&lt;assembly
	xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd"&gt;
	&lt;id&gt;stubs&lt;/id&gt;
	&lt;formats&gt;
		&lt;format&gt;jar&lt;/format&gt;
	&lt;/formats&gt;
	&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
	&lt;fileSets&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${project.build.directory}/snippets/stubs&lt;/directory&gt;
			&lt;outputDirectory&gt;customer-stubs/mappings&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**/*&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;$../../../../src/test/resources/contracts&lt;/directory&gt;
			&lt;outputDirectory&gt;customer-stubs/contracts&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**/*.groovy&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
	&lt;/fileSets&gt;
&lt;/assembly&gt;

&lt;!-- end of stub.xml--&gt;</programlisting>
</para>
</formalpara>
<formalpara role="secondary">
<title>Gradle</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">task copyStubs(type: Copy, dependsOn: 'generateWireMockClientStubs') {
//    Preserve directory structure from 1.0.X of spring-cloud-contract
    from "${project.buildDir}/resources/main/customer-stubs/META-INF/${project.group}/${project.name}/${project.version}"
    into "${project.buildDir}/resources/main/customer-stubs"
}</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="cloud-verifier-1.1-1.2">
<title>1.1.x &#8594; 1.2.x</title>
<simpara>This section covers upgrading from version 1.1 to version 1.2.</simpara>
<section xml:id="_custom_literal_httpserverstub_literal">
<title>Custom <literal>HttpServerStub</literal></title>
<simpara><literal>HttpServerStub</literal> includes a method that was not in version 1.1. The method is
<literal>String registeredMappings()</literal> If you have classes that implement <literal>HttpServerStub</literal>, you
now have to implement the <literal>registeredMappings()</literal> method. It should return a <literal>String</literal>
representing all mappings available in a single <literal>HttpServerStub</literal>.</simpara>
<simpara>See <link xl:href="https://github.com/spring-cloud/spring-cloud-contract/issues/355">issue 355</link> for more
detail.</simpara>
</section>
<section xml:id="_new_packages_for_generated_tests">
<title>New packages for generated tests</title>
<simpara>The flow for setting the generated tests package name will look like this:</simpara>
<itemizedlist>
<listitem>
<simpara>Set <literal>basePackageForTests</literal></simpara>
</listitem>
<listitem>
<simpara>If <literal>basePackageForTests</literal> was not set, pick the package from <literal>baseClassForTests</literal></simpara>
</listitem>
<listitem>
<simpara>If <literal>baseClassForTests</literal> was not set, pick <literal>packageWithBaseClasses</literal></simpara>
</listitem>
<listitem>
<simpara>If nothing got set, pick the default value:
<literal>org.springframework.cloud.contract.verifier.tests</literal></simpara>
</listitem>
</itemizedlist>
<simpara>See <link xl:href="https://github.com/spring-cloud/spring-cloud-contract/issues/260">issue 260</link> for more
detail.</simpara>
</section>
<section xml:id="_new_methods_in_templateprocessor">
<title>New Methods in TemplateProcessor</title>
<simpara>In order to add support for <literal>fromRequest.path</literal>, the following methods had to be added to the
<literal>TemplateProcessor</literal> interface:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>path()</literal></simpara>
</listitem>
<listitem>
<simpara><literal>path(int index)</literal></simpara>
</listitem>
</itemizedlist>
<simpara>See <link xl:href="https://github.com/spring-cloud/spring-cloud-contract/issues/388">issue 388</link> for more
detail.</simpara>
</section>
<section xml:id="_restassured_3_0">
<title>RestAssured 3.0</title>
<simpara>Rest Assured, used in the generated test classes, got bumped to <literal>3.0</literal>. If
you manually set versions of Spring Cloud Contract and the release train
you might see the following exception:</simpara>
<programlisting language="bash" linenumbering="unnumbered">Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile (default-testCompile) on project some-project: Compilation failure: Compilation failure:
[ERROR] /some/path/SomeClass.java:[4,39] package com.jayway.restassured.response does not exist</programlisting>
<simpara>This exception will occur due to the fact that the tests got generated with
an old version of plugin and at test execution time you have an incompatible
version of the release train (and vice versa).</simpara>
<simpara>Done via <link xl:href="https://github.com/spring-cloud/spring-cloud-contract/issues/267">issue 267</link></simpara>
</section>
</section>
</chapter>
<chapter xml:id="_links">
<title>Links</title>
<simpara>The following links may be helpful when working with Spring Cloud Contract Verifier:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/spring-cloud/spring-cloud-contract/">Spring Cloud Contract Github
Repository</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/">Spring Cloud
Contract Samples</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html">Spring Cloud
Contract Documentation</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html/deprecated">Accurest
Legacy Documentation</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html/#spring-cloud-contract-stub-runner">Spring
Cloud Contract Stub Runner Documentation</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html/#stub-runner-for-messaging">Spring
Cloud Contract Stub Runner Messaging Documentation</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://gitter.im/spring-cloud/spring-cloud-contract">Spring Cloud Contract Gitter</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/">Spring
Cloud Contract Maven Plugin</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.youtube.com/watch?v=sAAklvxmPmk">Spring Cloud Contract WJUG Presentation by
Marcin Grzejszczak</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</part>
<part xml:id="_spring_cloud_vault">
<title>Spring Cloud Vault</title>
<partintro>
<simpara>&#169; 2016-2017 The original authors.</simpara>
<note>
<simpara><emphasis>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</emphasis></simpara>
</note>
<simpara>Spring Cloud Vault Config provides client-side support for externalized configuration in a distributed system. With <link xl:href="https://www.vaultproject.io">HashiCorp&#8217;s Vault</link> you have a central place to manage external secret properties for applications across all environments. Vault can manage static and dynamic secrets such as username/password for remote applications/resources and provide credentials for external services such as MySQL, PostgreSQL, Apache Cassandra, MongoDB, Consul, AWS and more.</simpara>
</partintro>
<chapter xml:id="_quick_start_3">
<title>Quick Start</title>
<simpara><emphasis role="strong">Prerequisites</emphasis></simpara>
<simpara>To get started with Vault and this guide you need a
*NIX-like operating systems that provides:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>wget</literal>, <literal>openssl</literal> and <literal>unzip</literal></simpara>
</listitem>
<listitem>
<simpara>at least Java 7 and a properly configured <literal>JAVA_HOME</literal> environment variable</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Install Vault</emphasis></simpara>
<programlisting language="bash" linenumbering="unnumbered">$ src/test/bash/install_vault.sh</programlisting>
<simpara><emphasis role="strong">Create SSL certificates for Vault</emphasis></simpara>
<programlisting language="bash" linenumbering="unnumbered">$ src/test/bash/create_certificates.sh</programlisting>
<note>
<simpara><literal>create_certificates.sh</literal> creates certificates in <literal>work/ca</literal> and a JKS truststore <literal>work/keystore.jks</literal>. If you want to run Spring Cloud Vault using this quickstart guide you need to configure the truststore the <literal>spring.cloud.vault.ssl.trust-store</literal> property to <literal>file:work/keystore.jks</literal>.</simpara>
</note>
<simpara xml:id="quickstart.vault.start"><emphasis role="strong">Start Vault server</emphasis></simpara>
<programlisting language="bash" linenumbering="unnumbered">$ src/test/bash/local_run_vault.sh</programlisting>
<simpara>Vault is started listening on <literal>0.0.0.0:8200</literal> using the <literal>inmem</literal> storage and
<literal>https</literal>.
Vault is sealed and not initialized when starting up.</simpara>
<note>
<simpara>If you want to run tests, leave Vault uninitialized. The tests will
initialize Vault and create a root token <literal>00000000-0000-0000-0000-000000000000</literal>.</simpara>
</note>
<simpara>If you want to use Vault for your application or give it a try then you need to initialize it first.</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ export VAULT_ADDR="https://localhost:8200"
$ export VAULT_SKIP_VERIFY=true # Don't do this for production
$ vault init</programlisting>
<simpara>You should see something like:</simpara>
<programlisting language="bash" linenumbering="unnumbered">Key 1: 7149c6a2e16b8833f6eb1e76df03e47f6113a3288b3093faf5033d44f0e70fe701
Key 2: 901c534c7988c18c20435a85213c683bdcf0efcd82e38e2893779f152978c18c02
Key 3: 03ff3948575b1165a20c20ee7c3e6edf04f4cdbe0e82dbff5be49c63f98bc03a03
Key 4: 216ae5cc3ddaf93ceb8e1d15bb9fc3176653f5b738f5f3d1ee00cd7dccbe926e04
Key 5: b2898fc8130929d569c1677ee69dc5f3be57d7c4b494a6062693ce0b1c4d93d805
Initial Root Token: 19aefa97-cccc-bbbb-aaaa-225940e63d76

Vault initialized with 5 keys and a key threshold of 3. Please
securely distribute the above keys. When the Vault is re-sealed,
restarted, or stopped, you must provide at least 3 of these keys
to unseal it again.

Vault does not store the master key. Without at least 3 keys,
your Vault will remain permanently sealed.</programlisting>
<simpara>Vault will initialize and return a set of unsealing keys and the root token.
Pick 3 keys and unseal Vault. Store the Vault token in the <literal>VAULT_TOKEN</literal>
 environment variable.</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ vault unseal (Key 1)
$ vault unseal (Key 2)
$ vault unseal (Key 3)
$ export VAULT_TOKEN=(Root token)
# Required to run Spring Cloud Vault tests after manual initialization
$ vault token-create -id="00000000-0000-0000-0000-000000000000" -policy="root"</programlisting>
<simpara>Spring Cloud Vault accesses different resources. By default, the secret
backend is enabled which accesses secret config settings via JSON endpoints.</simpara>
<simpara>The HTTP service has resources in the form:</simpara>
<screen>/secret/{application}/{profile}
/secret/{application}
/secret/{defaultContext}/{profile}
/secret/{defaultContext}</screen>
<simpara>where the "application" is injected as the <literal>spring.application.name</literal> in the
<literal>SpringApplication</literal> (i.e. what is normally "application" in a regular
Spring Boot app), "profile" is an active profile (or comma-separated
list of properties). Properties retrieved from Vault will be used "as-is"
without further prefixing of the property names.</simpara>
</chapter>
<chapter xml:id="_client_side_usage_2">
<title>Client Side Usage</title>
<simpara>To use these features in an application, just build it as a Spring
Boot application that depends on <literal>spring-cloud-vault-config</literal> (e.g. see
the test cases). Example Maven configuration:</simpara>
<example>
<title>pom.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;
    &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-vault-config&lt;/artifactId&gt;
        &lt;version&gt;Edgware.SR2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;

&lt;!-- repositories also needed for snapshots and milestones --&gt;</programlisting>
</example>
<simpara>Then you can create a standard Spring Boot application, like this simple HTTP server:</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}</programlisting>
</informalexample>
<simpara>When it runs it will pick up the external configuration from the
default local Vault server on port <literal>8200</literal> if it is running. To modify
the startup behavior you can change the location of the Vault server
using <literal>bootstrap.properties</literal> (like <literal>application.properties</literal> but for
the bootstrap phase of an application context), e.g.</simpara>
<example>
<title>bootstrap.yml</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    host: localhost
    port: 8200
    scheme: https
    uri: https://localhost:8200
    connection-timeout: 5000
    read-timeout: 15000
    config:
        order: -10</programlisting>
</example>
<itemizedlist>
<listitem>
<simpara><literal>host</literal> sets the hostname of the Vault host. The host name will be used
for SSL certificate validation</simpara>
</listitem>
<listitem>
<simpara><literal>port</literal> sets the Vault port</simpara>
</listitem>
<listitem>
<simpara><literal>scheme</literal> setting the scheme to <literal>http</literal> will use plain HTTP.
Supported schemes are <literal>http</literal> and <literal>https</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>uri</literal> configure the Vault endpoint with an URI. Takes precedence over host/port/scheme configuration</simpara>
</listitem>
<listitem>
<simpara><literal>connection-timeout</literal> sets the connection timeout in milliseconds</simpara>
</listitem>
<listitem>
<simpara><literal>read-timeout</literal> sets the read timeout in milliseconds</simpara>
</listitem>
<listitem>
<simpara><literal>config.order</literal> sets the order for the property source</simpara>
</listitem>
</itemizedlist>
<simpara>Enabling further integrations requires additional dependencies and
configuration. Depending on how you have set up Vault you might need
additional configuration like
<link xl:href="https://cloud.spring.io/spring-cloud-vault/spring-cloud-vault.html#vault.config.ssl">SSL</link> and
<link xl:href="https://cloud.spring.io/spring-cloud-vault/spring-cloud-vault.html#vault.config.authentication">authentication</link>.</simpara>
<simpara>If the application imports the <literal>spring-boot-starter-actuator</literal> project, the
status of the vault server will be available via the <literal>/health</literal> endpoint.</simpara>
<simpara>The vault health indicator can be enabled or disabled through the
property <literal>health.vault.enabled</literal> (default <literal>true</literal>).</simpara>
<section xml:id="_authentication_2">
<title>Authentication</title>
<simpara>Vault requires an <link xl:href="https://www.vaultproject.io/docs/concepts/auth.html">authentication mechanism</link> to <link xl:href="https://www.vaultproject.io/docs/concepts/tokens.html">authorize client requests</link>.</simpara>
<simpara>Spring Cloud Vault supports multiple <link xl:href="https://cloud.spring.io/spring-cloud-vault/spring-cloud-vault.html#vault.config.authentication">authentication mechanisms</link> to authenticate applications with Vault.</simpara>
<simpara>For a quickstart, use the root token printed by the <link linkend="quickstart.vault.start">Vault initialization</link>.</simpara>
<example>
<title>bootstrap.yml</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    token: 19aefa97-cccc-bbbb-aaaa-225940e63d76</programlisting>
</example>
<warning>
<simpara>Consider carefully your security requirements. Static token authentication is fine if you want quickly get started with Vault, but a static token is not protected any further. Any disclosure to unintended parties allows Vault use with the associated token roles.</simpara>
</warning>
</section>
</chapter>
<chapter xml:id="vault.config.authentication">
<title>Authentication methods</title>
<simpara>Different organizations have different requirements for security
and authentication. Vault reflects that need by shipping multiple authentication
methods. Spring Cloud Vault supports token and AppId authentication.</simpara>
<section xml:id="vault.config.authentication.token">
<title>Token authentication</title>
<simpara>Tokens are the core method for authentication within Vault.
Token authentication requires a static token to be provided using the
<link xl:href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/docs/src/main/asciidoc/spring-cloud-commons.adoc#the-bootstrap-application-context">Bootstrap Application Context</link>.</simpara>
<note>
<simpara>Token authentication is the default authentication method.
If a token is disclosed an unintended party gains access to Vault and
can access secrets for the intended client.</simpara>
</note>
<example>
<title>bootstrap.yml</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: TOKEN
    token: 00000000-0000-0000-0000-000000000000</programlisting>
</example>
<itemizedlist>
<listitem>
<simpara><literal>authentication</literal> setting this value to <literal>TOKEN</literal> selects the Token
authentication method</simpara>
</listitem>
<listitem>
<simpara><literal>token</literal> sets the static token to use</simpara>
</listitem>
</itemizedlist>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/concepts/tokens.html">Vault Documentation: Tokens</link></simpara>
</section>
<section xml:id="vault.config.authentication.appid">
<title>AppId authentication</title>
<simpara>Vault supports <link xl:href="https://www.vaultproject.io/docs/auth/app-id.html">AppId</link>
authentication that consists of two hard to guess tokens. The AppId
defaults to <literal>spring.application.name</literal> that is statically configured.
The second token is the UserId which is a part determined by the application,
usually related to the runtime environment. IP address, Mac address or a
Docker container name are good examples. Spring Cloud Vault Config supports
IP address, Mac address and static UserId&#8217;s (e.g. supplied via System properties).
The IP and Mac address are represented as Hex-encoded SHA256 hash.</simpara>
<simpara>IP address-based UserId&#8217;s use the local host&#8217;s IP address.</simpara>
<example>
<title>bootstrap.yml using SHA256 IP-Address UserId&#8217;s</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: APPID
    app-id:
        user-id: IP_ADDRESS</programlisting>
</example>
<itemizedlist>
<listitem>
<simpara><literal>authentication</literal> setting this value to <literal>APPID</literal> selects the AppId
authentication method</simpara>
</listitem>
<listitem>
<simpara><literal>app-id-path</literal> sets the path of the AppId mount to use</simpara>
</listitem>
<listitem>
<simpara><literal>user-id</literal> sets the UserId method. Possible values are <literal>IP_ADDRESS</literal>,
<literal>MAC_ADDRESS</literal> or a class name implementing a custom <literal>AppIdUserIdMechanism</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The corresponding command to generate the IP address UserId from a command line is:</simpara>
<screen>$ echo -n 192.168.99.1 | sha256sum</screen>
<note>
<simpara>Including the line break of <literal>echo</literal> leads to a different hash value
so make sure to include the <literal>-n</literal> flag.</simpara>
</note>
<simpara>Mac address-based UserId&#8217;s obtain their network device from the
localhost-bound device. The configuration also allows specifying
a <literal>network-interface</literal> hint to pick the right device. The value of
<literal>network-interface</literal> is optional and can be either an interface
name or interface index (0-based).</simpara>
<example>
<title>bootstrap.yml using SHA256 Mac-Address UserId&#8217;s</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: APPID
    app-id:
        user-id: MAC_ADDRESS
        network-interface: eth0</programlisting>
</example>
<itemizedlist>
<listitem>
<simpara><literal>network-interface</literal> sets network interface to obtain the physical address</simpara>
</listitem>
</itemizedlist>
<simpara>The corresponding command to generate the IP address UserId from a command line is:</simpara>
<screen>$ echo -n 0AFEDE1234AC | sha256sum</screen>
<note>
<simpara>The Mac address is specified uppercase and without colons.
Including the line break of <literal>echo</literal> leads to a different hash value
so make sure to include the <literal>-n</literal> flag.</simpara>
</note>
<section xml:id="_custom_userid">
<title>Custom UserId</title>
<simpara>The UserId generation is an open mechanism. You can set
<literal>spring.cloud.vault.app-id.user-id</literal> to any string and the configured
value will be used as static UserId.</simpara>
<simpara>A more advanced approach lets you set <literal>spring.cloud.vault.app-id.user-id</literal> to a
classname. This class must be on your classpath and must implement
the <literal>org.springframework.cloud.vault.AppIdUserIdMechanism</literal> interface
and the <literal>createUserId</literal> method. Spring Cloud Vault will obtain the UserId
by calling <literal>createUserId</literal> each time it authenticates using AppId to
obtain a token.</simpara>
<example>
<title>bootstrap.yml</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: APPID
    app-id:
        user-id: com.examlple.MyUserIdMechanism</programlisting>
</example>
<example>
<title>MyUserIdMechanism.java</title>
<programlisting language="yaml" linenumbering="unnumbered">public class MyUserIdMechanism implements AppIdUserIdMechanism {

  @Override
  public String createUserId() {
    String userId = ...
    return userId;
  }
}</programlisting>
</example>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/auth/app-id.html">Vault Documentation: Using the App ID auth backend</link></simpara>
</section>
</section>
<section xml:id="_approle_authentication">
<title>AppRole authentication</title>
<simpara><link xl:href="https://www.vaultproject.io/docs/auth/app-id.html">AppRole</link> is intended for machine
authentication, like the deprecated (since Vault 0.6.1) <xref linkend="vault.config.authentication.appid"/>.
AppRole authentication consists of two hard to guess (secret) tokens: RoleId and SecretId.</simpara>
<simpara>Spring Vault supports AppRole authentication by providing either RoleId only
or together with a provided SecretId (push or pull mode).</simpara>
<simpara>RoleId and optionally SecretId must be provided by configuration,
Spring Vault will not look up these or create a custom SecretId.</simpara>
<example>
<title>bootstrap.yml with AppRole authentication properties</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: APPROLE
    app-role:
        role-id: bde2076b-cccb-3cf0-d57e-bca7b1e83a52</programlisting>
</example>
<itemizedlist>
<listitem>
<simpara><literal>role-id</literal> sets the RoleId.</simpara>
</listitem>
</itemizedlist>
<example>
<title>bootstrap.yml with all AppRole authentication properties</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: APPROLE
    app-role:
        role-id: bde2076b-cccb-3cf0-d57e-bca7b1e83a52
        secret-id: 1696536f-1976-73b1-b241-0b4213908d39
        app-auth-path: approle</programlisting>
</example>
<itemizedlist>
<listitem>
<simpara><literal>role-id</literal> sets the RoleId.</simpara>
</listitem>
<listitem>
<simpara><literal>secret-id</literal> sets the SecretId. SecretId can be omitted if AppRole is configured without requiring SecretId (See <literal>bind_secret_id</literal>)</simpara>
</listitem>
<listitem>
<simpara><literal>approle-path</literal> sets the path of the approle authentication mount to use</simpara>
</listitem>
</itemizedlist>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/auth/approle.html">Vault Documentation: Using the AppRole auth backend</link></simpara>
</section>
<section xml:id="vault.config.authentication.awsec2">
<title>AWS-EC2 authentication</title>
<simpara>The <link xl:href="https://www.vaultproject.io/docs/auth/aws-ec2.html">aws-ec2</link>
auth backend provides a secure introduction mechanism
for AWS EC2 instances, allowing automated retrieval of a Vault
token. Unlike most Vault authentication backends, this backend
does not require first-deploying, or provisioning security-sensitive
credentials (tokens, username/password, client certificates, etc.).
Instead, it treats AWS as a Trusted Third Party and uses the
cryptographically signed dynamic metadata information that uniquely
represents each EC2 instance.</simpara>
<example>
<title>bootstrap.yml using AWS-EC2 Authentication</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: AWS_EC2</programlisting>
</example>
<simpara>AWS-EC2 authentication enables nonce by default to follow
the Trust On First Use (TOFU) principle. Any unintended party that
gains access to the PKCS#7 identity metadata can authenticate
against Vault.</simpara>
<simpara>During the first login, Spring Cloud Vault generates a nonce
that is stored in the auth backend aside the instance Id.
Re-authentication requires the same nonce to be sent. Any other
party does not have the nonce and can raise an alert in Vault for
further investigation.</simpara>
<simpara>The nonce is kept in memory and is lost during application restart.
You can configure a static nonce with <literal>spring.cloud.vault.aws-ec2.nonce</literal>.</simpara>
<simpara>AWS-EC2 authentication roles are optional and default to the AMI.
You can configure the authentication role by setting the
<literal>spring.cloud.vault.aws-ec2.role</literal> property.</simpara>
<example>
<title>bootstrap.yml with configured role</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: AWS_EC2
    aws-ec2:
        role: application-server</programlisting>
</example>
<example>
<title>bootstrap.yml with all AWS EC2 authentication properties</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: AWS_EC2
    aws-ec2:
        role: application-server
        aws-ec2-path: aws-ec2
        identity-document: http://...
        nonce: my-static-nonce</programlisting>
</example>
<itemizedlist>
<listitem>
<simpara><literal>authentication</literal> setting this value to <literal>AWS_EC2</literal> selects the AWS EC2
authentication method</simpara>
</listitem>
<listitem>
<simpara><literal>role</literal> sets the name of the role against which the login is being attempted.</simpara>
</listitem>
<listitem>
<simpara><literal>aws-ec2-path</literal> sets the path of the AWS EC2 mount to use</simpara>
</listitem>
<listitem>
<simpara><literal>identity-document</literal> sets URL of the PKCS#7 AWS EC2 identity document</simpara>
</listitem>
<listitem>
<simpara><literal>nonce</literal> used for AWS-EC2 authentication. An empty nonce defaults to nonce generation</simpara>
</listitem>
</itemizedlist>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/auth/aws.html">Vault Documentation: Using the aws auth backend</link></simpara>
</section>
<section xml:id="vault.config.authentication.awsiam">
<title>AWS-IAM authentication</title>
<simpara>The <link xl:href="https://www.vaultproject.io/docs/auth/aws-ec2.html">aws</link> backend provides a secure
authentication mechanism for AWS IAM roles, allowing the automatic authentication with
vault based on the current IAM role of the running application.
 Unlike most Vault authentication backends, this backend
does not require first-deploying, or provisioning security-sensitive
credentials (tokens, username/password, client certificates, etc.).
Instead, it treats AWS as a Trusted Third Party and uses the
4 pieces of information signed by the caller with their IAM credentials
 to verify that the caller is indeed using that IAM role.</simpara>
<simpara>The current IAM role the application is running in is automatically calculated.
If you are running your application on AWS ECS then the application
will use the IAM role assigned to the ECS task of the running container.
If you are running your application naked on top of an EC2 instance then
the IAM role used will be the one assigned to the EC2 instance.</simpara>
<simpara>When using the AWS-IAM authentication you must create a role in Vault
and assign it to your IAM role. An empty <literal>role</literal> defaults to
the friendly name the current IAM role.</simpara>
<example>
<title>bootstrap.yml with required AWS-IAM Authentication properties</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: AWS_IAM</programlisting>
</example>
<example>
<title>bootstrap.yml with all AWS-IAM Authentication properties</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: AWS_IAM
    aws-iam:
        role: my-dev-role
        aws-path: aws
        server-id: some.server.name</programlisting>
</example>
<itemizedlist>
<listitem>
<simpara><literal>role</literal> sets the name of the role against which the login is being attempted. This should be bound to your IAM role. If one is not supplied then the friendly name of the current IAM user will be used as the vault role.</simpara>
</listitem>
<listitem>
<simpara><literal>aws-path</literal> sets the path of the AWS mount to use</simpara>
</listitem>
<listitem>
<simpara><literal>server-id</literal> sets the value to use for the <literal>X-Vault-AWS-IAM-Server-ID</literal> header preventing certain types of replay attacks.</simpara>
</listitem>
</itemizedlist>
<simpara>AWS-IAM requires the AWS Java SDK dependency (<literal>com.amazonaws:aws-java-sdk-core</literal>)
as the authentication implementation uses AWS SDK types for credentials and request signing.</simpara>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/auth/aws.html">Vault Documentation: Using the aws auth backend</link></simpara>
</section>
<section xml:id="vault.config.authentication.clientcert">
<title>TLS certificate authentication</title>
<simpara>The <literal>cert</literal> auth backend allows authentication using SSL/TLS client
certificates that are either signed by a CA or self-signed.</simpara>
<simpara>To enable <literal>cert</literal> authentication you need to:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Use SSL, see <xref linkend="vault.config.ssl"/></simpara>
</listitem>
<listitem>
<simpara>Configure a Java <literal>Keystore</literal> that contains the client
certificate and the private key</simpara>
</listitem>
<listitem>
<simpara>Set the <literal>spring.cloud.vault.authentication</literal> to <literal>CERT</literal></simpara>
</listitem>
</orderedlist>
<example>
<title>bootstrap.yml</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: CERT
    ssl:
        key-store: classpath:keystore.jks
        key-store-password: changeit
        cert-auth-path: cert</programlisting>
</example>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/auth/cert.html">Vault Documentation: Using the Cert auth backend</link></simpara>
</section>
<section xml:id="vault.config.authentication.cubbyhole">
<title>Cubbyhole authentication</title>
<simpara>Cubbyhole authentication uses Vault primitives to provide a secured authentication
workflow. Cubbyhole authentication uses tokens as primary login method.
An ephemeral token is used to obtain a second, login VaultToken from Vault&#8217;s
Cubbyhole secret backend. The login token is usually longer-lived and used to
interact with Vault. The login token will be retrieved from a wrapped
response stored at <literal>/cubbyhole/response</literal>.</simpara>
<simpara><emphasis role="strong">Creating a wrapped token</emphasis></simpara>
<note>
<simpara>Response Wrapping for token creation requires Vault 0.6.0 or higher.</simpara>
</note>
<example>
<title>Creating and storing tokens</title>
<programlisting language="shell" linenumbering="unnumbered">$ vault token-create -wrap-ttl="10m"
Key                            Value
---                            -----
wrapping_token:                397ccb93-ff6c-b17b-9389-380b01ca2645
wrapping_token_ttl:            0h10m0s
wrapping_token_creation_time:  2016-09-18 20:29:48.652957077 +0200 CEST
wrapped_accessor:              46b6aebb-187f-932a-26d7-4f3d86a68319</programlisting>
</example>
<example>
<title>bootstrap.yml</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: CUBBYHOLE
    token: 397ccb93-ff6c-b17b-9389-380b01ca2645</programlisting>
</example>
<simpara>See also:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://www.vaultproject.io/docs/concepts/tokens.html">Vault Documentation: Tokens</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.vaultproject.io/docs/secrets/cubbyhole/index.html">Vault Documentation: Cubbyhole Secret Backend</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.vaultproject.io/docs/concepts/response-wrapping.html">Vault Documentation: Response Wrapping</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="vault.config.authentication.kubernetes">
<title>Kubernetes authentication</title>
<simpara>Kubernetes authentication mechanism (since Vault 0.8.3) allows to authenticate with Vault using a Kubernetes Service Account Token.
The authentication is role based and the role is bound to a service account name and a namespace.</simpara>
<simpara>A file containing a JWT token for a pod’s service account is automatically mounted at <literal>/var/run/secrets/kubernetes.io/serviceaccount/token</literal>.</simpara>
<example>
<title>bootstrap.yml with all Kubernetes authentication properties</title>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    authentication: KUBERNETES
    kubernetes:
        role: my-dev-role
        service-account-token-file: /var/run/secrets/kubernetes.io/serviceaccount/token</programlisting>
</example>
<itemizedlist>
<listitem>
<simpara><literal>role</literal> sets the Role.</simpara>
</listitem>
<listitem>
<simpara><literal>service-account-token-file</literal> sets the location of the file containing the Kubernetes Service Account Token. Defaults to <literal>/var/run/secrets/kubernetes.io/serviceaccount/token</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>See also:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://www.vaultproject.io/docs/auth/kubernetes.html">Vault Documentation: Kubernetes</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">Kubernetes Documentation: Configure Service Accounts for Pods</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="vault.config.backends">
<title>Secret Backends</title>
<section xml:id="vault.config.backends.generic">
<title>Generic Backend</title>
<simpara>Spring Cloud Vault supports at the basic level the generic secret
backend. The generic secret backend allows storage of arbitrary
values as key-value store. A single context can store one or many
key-value tuples. Contexts can be organized hierarchically.
Spring Cloud Vault allows using the Application name
and a default context name (<literal>application</literal>) in combination with active
profiles.</simpara>
<screen>/secret/{application}/{profile}
/secret/{application}
/secret/{default-context}/{profile}
/secret/{default-context}</screen>
<simpara>The application name is determined by the properties:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>spring.cloud.vault.generic.application-name</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spring.cloud.vault.application-name</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spring.application.name</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Secrets can be obtained from other folders within the generic backend by adding their
paths to the application name, separated by commas. For example, given the application
name <literal>usefulapp,mysql1,projectx/aws</literal>, each of these folders will be used:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>/secret/usefulapp</literal></simpara>
</listitem>
<listitem>
<simpara><literal>/secret/mysql1</literal></simpara>
</listitem>
<listitem>
<simpara><literal>/secret/projectx/aws</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Spring Cloud Vault adds all active profiles to the list of possible context paths.
No active profiles will skip accessing contexts with a profile name.</simpara>
<simpara>Properties are exposed like they are stored (i.e. without additional prefixes).</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    generic:
        enabled: true
        backend: secret
        profile-separator: '/'
        default-context: application
        application-name: my-app</programlisting>
</informalexample>
<itemizedlist>
<listitem>
<simpara><literal>enabled</literal> setting this value to <literal>false</literal> disables the secret backend
config usage</simpara>
</listitem>
<listitem>
<simpara><literal>backend</literal> sets the path of the secret mount to use</simpara>
</listitem>
<listitem>
<simpara><literal>default-context</literal> sets the context name used by all applications</simpara>
</listitem>
<listitem>
<simpara><literal>application-name</literal> overrides the application name for use in the generic backend</simpara>
</listitem>
<listitem>
<simpara><literal>profile-separator</literal> separates the profile name from the context in
property sources with profiles</simpara>
</listitem>
</itemizedlist>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/secrets/generic/index.html">Vault Documentation: Using the generic secret backend</link></simpara>
</section>
<section xml:id="vault.config.backends.consul">
<title>Consul</title>
<simpara>Spring Cloud Vault can obtain credentials for HashiCorp Consul.
The Consul integration requires the <literal>spring-cloud-vault-config-consul</literal>
dependency.</simpara>
<example>
<title>pom.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-vault-config-consul&lt;/artifactId&gt;
        &lt;version&gt;Edgware.SR2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
</example>
<simpara>The integration can be enabled by setting
<literal>spring.cloud.vault.consul.enabled=true</literal> (default <literal>false</literal>) and
providing the role name with <literal>spring.cloud.vault.consul.role=…</literal>.</simpara>
<simpara>The obtained token is stored in <literal>spring.cloud.consul.token</literal>
so using Spring Cloud Consul can pick up the generated
credentials without further configuration. You can configure
the property name by setting <literal>spring.cloud.vault.consul.token-property</literal>.</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    consul:
        enabled: true
        role: readonly
        backend: consul
        token-property: spring.cloud.consul.token</programlisting>
</informalexample>
<itemizedlist>
<listitem>
<simpara><literal>enabled</literal> setting this value to <literal>true</literal> enables the Consul backend config usage</simpara>
</listitem>
<listitem>
<simpara><literal>role</literal> sets the role name of the Consul role definition</simpara>
</listitem>
<listitem>
<simpara><literal>backend</literal> sets the path of the Consul mount to use</simpara>
</listitem>
<listitem>
<simpara><literal>token-property</literal> sets the property name in which the Consul ACL token is stored</simpara>
</listitem>
</itemizedlist>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/secrets/consul/index.html">Vault Documentation: Setting up Consul with Vault</link></simpara>
</section>
<section xml:id="vault.config.backends.rabbitmq">
<title>RabbitMQ</title>
<simpara>Spring Cloud Vault can obtain credentials for RabbitMQ.</simpara>
<simpara>The RabbitMQ integration requires the <literal>spring-cloud-vault-config-rabbitmq</literal>
dependency.</simpara>
<example>
<title>pom.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-vault-config-rabbitmq&lt;/artifactId&gt;
        &lt;version&gt;Edgware.SR2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
</example>
<simpara>The integration can be enabled by setting
<literal>spring.cloud.vault.rabbitmq.enabled=true</literal> (default <literal>false</literal>)
and providing the role name with <literal>spring.cloud.vault.rabbitmq.role=…</literal>.</simpara>
<simpara>Username and password are stored in <literal>spring.rabbitmq.username</literal>
and <literal>spring.rabbitmq.password</literal> so using Spring Boot will pick up the generated
credentials without further configuration. You can configure the property names
by setting <literal>spring.cloud.vault.rabbitmq.username-property</literal> and
<literal>spring.cloud.vault.rabbitmq.password-property</literal>.</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    rabbitmq:
        enabled: true
        role: readonly
        backend: rabbitmq
        username-property: spring.rabbitmq.username
        password-property: spring.rabbitmq.password</programlisting>
</informalexample>
<itemizedlist>
<listitem>
<simpara><literal>enabled</literal> setting this value to <literal>true</literal> enables the RabbitMQ backend config usage</simpara>
</listitem>
<listitem>
<simpara><literal>role</literal> sets the role name of the RabbitMQ role definition</simpara>
</listitem>
<listitem>
<simpara><literal>backend</literal> sets the path of the RabbitMQ mount to use</simpara>
</listitem>
<listitem>
<simpara><literal>username-property</literal> sets the property name in which the RabbitMQ username is stored</simpara>
</listitem>
<listitem>
<simpara><literal>password-property</literal> sets the property name in which the RabbitMQ password is stored</simpara>
</listitem>
</itemizedlist>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/secrets/rabbitmq/index.html">Vault Documentation: Setting up RabbitMQ with Vault</link></simpara>
</section>
<section xml:id="vault.config.backends.aws">
<title>AWS</title>
<simpara>Spring Cloud Vault can obtain credentials for AWS.</simpara>
<simpara>The AWS integration requires the <literal>spring-cloud-vault-config-aws</literal>
dependency.</simpara>
<example>
<title>pom.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-vault-config-aws&lt;/artifactId&gt;
        &lt;version&gt;Edgware.SR2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
</example>
<simpara>The integration can be enabled by setting
<literal>spring.cloud.vault.aws=true</literal> (default <literal>false</literal>)
and providing the role name with <literal>spring.cloud.vault.aws.role=…</literal>.</simpara>
<simpara>The access key and secret key are stored in <literal>cloud.aws.credentials.accessKey</literal>
and <literal>cloud.aws.credentials.secretKey</literal> so using Spring Cloud AWS will pick up the generated
credentials without further configuration. You can configure the property names
by setting <literal>spring.cloud.vault.aws.access-key-property</literal> and
<literal>spring.cloud.vault.aws.secret-key-property</literal>.</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    aws:
        enabled: true
        role: readonly
        backend: aws
        access-key-property: cloud.aws.credentials.accessKey
        secret-key-property: cloud.aws.credentials.secretKey</programlisting>
</informalexample>
<itemizedlist>
<listitem>
<simpara><literal>enabled</literal> setting this value to <literal>true</literal> enables the AWS backend config usage</simpara>
</listitem>
<listitem>
<simpara><literal>role</literal> sets the role name of the AWS role definition</simpara>
</listitem>
<listitem>
<simpara><literal>backend</literal> sets the path of the AWS mount to use</simpara>
</listitem>
<listitem>
<simpara><literal>access-key-property</literal> sets the property name in which the AWS access key is stored</simpara>
</listitem>
<listitem>
<simpara><literal>secret-key-property</literal> sets the property name in which the AWS secret key is stored</simpara>
</listitem>
</itemizedlist>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/secrets/aws/index.html">Vault Documentation: Setting up AWS with Vault</link></simpara>
</section>
</chapter>
<chapter xml:id="vault.config.backends.database-backends">
<title>Database backends</title>
<simpara>Vault supports several database secret backends to generate database
credentials dynamically based on configured roles. This means
services that need to access a database no longer need to configure
credentials: they can request them from Vault, and use Vault&#8217;s leasing
mechanism to more easily roll keys.</simpara>
<simpara>Spring Cloud Vault integrates with these backends:</simpara>
<itemizedlist>
<listitem>
<simpara><xref linkend="vault.config.backends.cassandra"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="vault.config.backends.mongodb"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="vault.config.backends.mysql"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="vault.config.backends.postgresql"/></simpara>
</listitem>
</itemizedlist>
<simpara>Using a database secret backend requires to enable the
backend in the configuration and the <literal>spring-cloud-vault-config-databases</literal>
dependency.</simpara>
<simpara>Vault ships since 0.7.1 with a dedicated <literal>database</literal> secret backend that allows
database integration via plugins. You can use that specific backend by adapting
one of the JDBC database properties above. Make sure to specify the appropriate
backend path, e.g. <literal>spring.cloud.vault.mysql.role.backend=database</literal>.</simpara>
<example>
<title>pom.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-vault-config-databases&lt;/artifactId&gt;
        &lt;version&gt;Edgware.SR2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
</example>
<note>
<simpara>Enabling multiple JDBC-compliant databases will generate credentials
and store them by default in the same property keys hence property names for
JDBC secrets need to be configured separately.</simpara>
</note>
<section xml:id="vault.config.backends.cassandra">
<title>Apache Cassandra</title>
<simpara>Spring Cloud Vault can obtain credentials for Apache Cassandra.
The integration can be enabled by setting
<literal>spring.cloud.vault.cassandra.enabled=true</literal> (default <literal>false</literal>) and
providing the role name with <literal>spring.cloud.vault.cassandra.role=…</literal>.</simpara>
<simpara>Username and password are stored in <literal>spring.data.cassandra.username</literal>
and <literal>spring.data.cassandra.password</literal> so using Spring Boot will pick
up the generated credentials without further configuration.
You can configure the property names by setting
<literal>spring.cloud.vault.cassandra.username-property</literal> and
<literal>spring.cloud.vault.cassandra.password-property</literal>.</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    cassandra:
        enabled: true
        role: readonly
        backend: cassandra
        username-property: spring.data.cassandra.username
        password-property: spring.data.cassandra.username</programlisting>
</informalexample>
<itemizedlist>
<listitem>
<simpara><literal>enabled</literal> setting this value to <literal>true</literal> enables the Cassandra backend config usage</simpara>
</listitem>
<listitem>
<simpara><literal>role</literal> sets the role name of the Cassandra role definition</simpara>
</listitem>
<listitem>
<simpara><literal>backend</literal> sets the path of the Cassandra mount to use</simpara>
</listitem>
<listitem>
<simpara><literal>username-property</literal> sets the property name in which the Cassandra username is stored</simpara>
</listitem>
<listitem>
<simpara><literal>password-property</literal> sets the property name in which the Cassandra password is stored</simpara>
</listitem>
</itemizedlist>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/secrets/cassandra/index.html">Vault Documentation: Setting up Apache Cassandra with Vault</link></simpara>
</section>
<section xml:id="vault.config.backends.mongodb">
<title>MongoDB</title>
<simpara>Spring Cloud Vault can obtain credentials for MongoDB.
The integration can be enabled by setting
<literal>spring.cloud.vault.mongodb.enabled=true</literal> (default <literal>false</literal>) and
providing the role name with <literal>spring.cloud.vault.mongodb.role=…</literal>.</simpara>
<simpara>Username and password are stored in <literal>spring.data.mongodb.username</literal>
and <literal>spring.data.mongodb.password</literal> so using Spring Boot will
pick up the generated credentials without further configuration.
You can configure the property names by setting
<literal>spring.cloud.vault.mongodb.username-property</literal> and
<literal>spring.cloud.vault.mongodb.password-property</literal>.</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    mongodb:
        enabled: true
        role: readonly
        backend: mongodb
        username-property: spring.data.mongodb.username
        password-property: spring.data.mongodb.password</programlisting>
</informalexample>
<itemizedlist>
<listitem>
<simpara><literal>enabled</literal> setting this value to <literal>true</literal> enables the MongodB backend config usage</simpara>
</listitem>
<listitem>
<simpara><literal>role</literal> sets the role name of the MongoDB role definition</simpara>
</listitem>
<listitem>
<simpara><literal>backend</literal> sets the path of the MongoDB mount to use</simpara>
</listitem>
<listitem>
<simpara><literal>username-property</literal> sets the property name in which the MongoDB username is stored</simpara>
</listitem>
<listitem>
<simpara><literal>password-property</literal> sets the property name in which the MongoDB password is stored</simpara>
</listitem>
</itemizedlist>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/secrets/mongodb/index.html">Vault Documentation: Setting up MongoDB with Vault</link></simpara>
</section>
<section xml:id="vault.config.backends.mysql">
<title>MySQL</title>
<simpara>Spring Cloud Vault can obtain credentials for MySQL.
The integration can be enabled by setting
<literal>spring.cloud.vault.mysql.enabled=true</literal> (default <literal>false</literal>) and
providing the role name with <literal>spring.cloud.vault.mysql.role=…</literal>.</simpara>
<simpara>Username and password are stored in <literal>spring.datasource.username</literal>
and <literal>spring.datasource.password</literal> so using Spring Boot will
pick up the generated credentials without further configuration.
You can configure the property names by setting
<literal>spring.cloud.vault.mysql.username-property</literal> and
<literal>spring.cloud.vault.mysql.password-property</literal>.</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    mysql:
        enabled: true
        role: readonly
        backend: mysql
        username-property: spring.datasource.username
        password-property: spring.datasource.username</programlisting>
</informalexample>
<itemizedlist>
<listitem>
<simpara><literal>enabled</literal> setting this value to <literal>true</literal> enables the MySQL backend config usage</simpara>
</listitem>
<listitem>
<simpara><literal>role</literal> sets the role name of the MySQL role definition</simpara>
</listitem>
<listitem>
<simpara><literal>backend</literal> sets the path of the MySQL mount to use</simpara>
</listitem>
<listitem>
<simpara><literal>username-property</literal> sets the property name in which the MySQL username is stored</simpara>
</listitem>
<listitem>
<simpara><literal>password-property</literal> sets the property name in which the MySQL password is stored</simpara>
</listitem>
</itemizedlist>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/secrets/mysql/index.html">Vault Documentation: Setting up MySQL with Vault</link></simpara>
</section>
<section xml:id="vault.config.backends.postgresql">
<title>PostgreSQL</title>
<simpara>Spring Cloud Vault can obtain credentials for PostgreSQL.
The integration can be enabled by setting
<literal>spring.cloud.vault.postgresql.enabled=true</literal> (default <literal>false</literal>) and
providing the role name with <literal>spring.cloud.vault.postgresql.role=…</literal>.</simpara>
<simpara>Username and password are stored in <literal>spring.datasource.username</literal>
and <literal>spring.datasource.password</literal> so using Spring Boot will
pick up the generated credentials without further configuration.
You can configure the property names by setting
<literal>spring.cloud.vault.postgresql.username-property</literal> and
<literal>spring.cloud.vault.postgresql.password-property</literal>.</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    postgresql:
        enabled: true
        role: readonly
        backend: postgresql
        username-property: spring.datasource.username
        password-property: spring.datasource.username</programlisting>
</informalexample>
<itemizedlist>
<listitem>
<simpara><literal>enabled</literal> setting this value to <literal>true</literal> enables the PostgreSQL backend config usage</simpara>
</listitem>
<listitem>
<simpara><literal>role</literal> sets the role name of the PostgreSQL role definition</simpara>
</listitem>
<listitem>
<simpara><literal>backend</literal> sets the path of the PostgreSQL mount to use</simpara>
</listitem>
<listitem>
<simpara><literal>username-property</literal> sets the property name in which the PostgreSQL username is stored</simpara>
</listitem>
<listitem>
<simpara><literal>password-property</literal> sets the property name in which the PostgreSQL password is stored</simpara>
</listitem>
</itemizedlist>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/secrets/postgresql/index.html">Vault Documentation: Setting up PostgreSQL with Vault</link></simpara>
</section>
</chapter>
<chapter xml:id="vault.config.backends.configurer">
<title>Configure <literal>PropertySourceLocator</literal> behavior</title>
<simpara>Spring Cloud Vault uses property-based configuration to create <literal>PropertySource</literal>s
for generic and discovered secret backends.</simpara>
<simpara>Discovered backends provide <literal>VaultSecretBackendDescriptor</literal> beans to describe the configuration
state to use secret backend as <literal>PropertySource</literal>. A <literal>SecretBackendMetadataFactory</literal> is required
to create a <literal>SecretBackendMetadata</literal> object which contains path, name and property transformation
configuration.</simpara>
<simpara><literal>SecretBackendMetadata</literal> is used to back a particular <literal>PropertySource</literal>.</simpara>
<simpara>You can register an arbitrary number of beans implementing <literal>VaultConfigurer</literal> for customization.
Default generic and discovered backend registration is disabled if Spring Cloud Vault discovers
at least one <literal>VaultConfigurer</literal> bean. You can however enable default registration with
<literal>SecretBackendConfigurer.registerDefaultGenericSecretBackends()</literal> and <literal>SecretBackendConfigurer.registerDefaultDiscoveredSecretBackends()</literal>.</simpara>
<informalexample>
<programlisting language="java" linenumbering="unnumbered">public class CustomizationBean implements VaultConfigurer {

    @Override
    public void addSecretBackends(SecretBackendConfigurer configurer) {

        configurer.add("secret/my-application");

        configurer.registerDefaultGenericSecretBackends(false);
        configurer.registerDefaultDiscoveredSecretBackends(true);
    }
}</programlisting>
</informalexample>
<note>
<simpara>All customization is required to happen in the bootstrap context. Add your configuration
classes to <literal>META-INF/spring.factories</literal> at <literal>org.springframework.cloud.bootstrap.BootstrapConfiguration</literal>
in your application.</simpara>
</note>
</chapter>
<chapter xml:id="_service_registry_configuration">
<title>Service Registry Configuration</title>
<simpara>You can use a <literal>DiscoveryClient</literal> (such as from Spring Cloud Consul) to locate
a Vault server by setting spring.cloud.vault.discovery.enabled=true (default <literal>false</literal>).
The net result of that is that your apps need a bootstrap.yml (or an environment variable)
with the appropriate discovery configuration.
The benefit is that the Vault can change its co-ordinates, as long as the discovery service
is a fixed point. The default service id is <literal>vault</literal> but you can change that on the client with
<literal>spring.cloud.vault.discovery.serviceId</literal>.</simpara>
<simpara>The discovery client implementations all support some kind of metadata map
(e.g. for Eureka we have eureka.instance.metadataMap). Some additional properties of the service
may need to be configured in its service registration metadata so that clients can connect
correctly. Service registries that do not provide details about transport layer security
need to provide a <literal>scheme</literal> metadata entry to be set either to <literal>https</literal> or <literal>http</literal>.
If no scheme is configured and the service is not exposed as secure service, then
configuration defaults to <literal>spring.cloud.vault.scheme</literal> which is <literal>https</literal> when it&#8217;s not set.</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault.discovery:
    enabled: true
    service-id: my-vault-service</programlisting>
</informalexample>
</chapter>
<chapter xml:id="vault.config.fail-fast">
<title>Vault Client Fail Fast</title>
<simpara>In some cases, it may be desirable to fail startup of a service if
it cannot connect to the Vault Server.  If this is the desired
behavior, set the bootstrap configuration property
<literal>spring.cloud.vault.fail-fast=true</literal> and the client will halt with
an Exception.</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    fail-fast: true</programlisting>
</informalexample>
</chapter>
<chapter xml:id="vault.config.ssl">
<title>Vault Client SSL configuration</title>
<simpara>SSL can be configured declaratively by setting various properties.
You can set either <literal>javax.net.ssl.trustStore</literal> to configure
JVM-wide SSL settings or <literal>spring.cloud.vault.ssl.trust-store</literal>
to set SSL settings only for Spring Cloud Vault Config.</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    ssl:
        trust-store: classpath:keystore.jks
        trust-store-password: changeit</programlisting>
</informalexample>
<itemizedlist>
<listitem>
<simpara><literal>trust-store</literal> sets the resource for the trust-store. SSL-secured Vault
communication will validate the Vault SSL certificate with the specified
trust-store.</simpara>
</listitem>
<listitem>
<simpara><literal>trust-store-password</literal> sets the trust-store password</simpara>
</listitem>
</itemizedlist>
<simpara>Please note that configuring <literal>spring.cloud.vault.ssl.*</literal> can be only
applied when either Apache Http Components or the OkHttp client
is on your class-path.</simpara>
</chapter>
<chapter xml:id="vault-lease-renewal">
<title>Lease lifecycle management (renewal and revocation)</title>
<simpara>With every secret, Vault creates a lease:
metadata containing information such as a time duration,
renewability, and more.</simpara>
<simpara>Vault promises that the data will be valid for the given duration,
or Time To Live (TTL). Once the lease is expired, Vault can
revoke the data, and the consumer of the secret can no longer
be certain that it is valid.</simpara>
<simpara>Spring Cloud Vault maintains a lease lifecycle beyond
the creation of login tokens and secrets. That said,
login tokens and secrets associated with a lease
are scheduled for renewal just before the lease expires
until terminal expiry.
Application shutdown revokes obtained login tokens and renewable
leases.</simpara>
<simpara>Secret service and database backends (such as MongoDB or MySQL)
usually generate a renewable lease so generated credentials will
be disabled on application shutdown.</simpara>
<note>
<simpara>Static tokens are not renewed or revoked.</simpara>
</note>
<simpara>Lease renewal and revocation is enabled by default and can
be disabled by setting <literal>spring.cloud.vault.config.lifecycle.enabled</literal>
to <literal>false</literal>. This is not recommended as leases can expire and
Spring Cloud Vault cannot longer access Vault or services
using generated credentials and valid credentials remain active
after application shutdown.</simpara>
<informalexample>
<programlisting language="yaml" linenumbering="unnumbered">spring.cloud.vault:
    config.lifecycle.enabled: true</programlisting>
</informalexample>
<simpara>See also: <link xl:href="https://www.vaultproject.io/docs/concepts/lease.html">Vault Documentation: Lease, Renew, and Revoke</link></simpara>
</chapter>
</part>
<part xml:id="_appendix_compendium_of_configuration_properties">
<title>Appendix: Compendium of Configuration Properties</title>
<partintro>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>encrypt.fail-on-error</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to say that a process should fail if there is an encryption or decryption
 error.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>encrypt.key</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>A symmetric key. As a stronger alternative consider using a keystore.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>encrypt.key-store.alias</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Alias for a key in the store.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>encrypt.key-store.location</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Location of the key store file, e.g. classpath:/keystore.jks.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>encrypt.key-store.password</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Password that locks the keystore.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>encrypt.key-store.secret</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Secret protecting the key (defaults to the same as the password).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>encrypt.rsa.algorithm</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>The RSA algorithm to use (DEFAULT or OEAP). Once it is set do not change it (or
 existing ciphers will not a decryptable).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>encrypt.rsa.salt</simpara></entry>
<entry align="left" valign="top"><simpara>deadbeef</simpara></entry>
<entry align="left" valign="top"><simpara>Salt for the random secret used to encrypt cipher text. Once it is set do not
 change it (or existing ciphers will not a decryptable).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>encrypt.rsa.strong</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that "strong" AES encryption should be used internally. If
 true then the GCM algorithm is applied to the AES encrypted bytes. Default is
 false (in which case "standard" CBC is used instead). Once it is set do not
 change it (or existing ciphers will not a decryptable).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.bus.enabled</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.bus.id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.bus.sensitive</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.consul.enabled</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.consul.id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.consul.sensitive</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.env.post.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Enable changing the Environment through a POST to /env.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.features.enabled</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.features.id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.features.sensitive</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.pause.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Enable the /pause endpoint (to send Lifecycle.stop()).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.pause.id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.pause.sensitive</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.refresh.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Enable the /refresh endpoint to refresh configuration and re-initialize refresh scoped beans.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.refresh.id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.refresh.sensitive</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.restart.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Enable the /restart endpoint to restart the application context.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.restart.id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.restart.pause-endpoint.enabled</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.restart.pause-endpoint.id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.restart.pause-endpoint.sensitive</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.restart.resume-endpoint.enabled</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.restart.resume-endpoint.id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.restart.resume-endpoint.sensitive</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.restart.sensitive</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.restart.timeout</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.resume.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Enable the /resume endpoint (to send Lifecycle.start()).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.resume.id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.resume.sensitive</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>endpoints.zookeeper.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Enable the /zookeeper endpoint to inspect the state of zookeeper.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.allow-redirects</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether server can redirect a client request to a backup server/cluster.
 If set to false, the server will handle the request directly, If set to true, it
 may send HTTP redirect to the client, with a new server location.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.availability-zones</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the list of availability zones (used in AWS data centers) for the region in
 which this instance resides.
</simpara><simpara> The changes are effective at runtime at the next registry fetch cycle as specified
 by registryFetchIntervalSeconds.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.backup-registry-impl</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the name of the implementation which implements BackupRegistry to fetch the
 registry information as a fall back option for only the first time when the eureka
 client starts.
</simpara><simpara> This may be needed for applications which needs additional resiliency for registry
 information without which it cannot operate.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.cache-refresh-executor-exponential-back-off-bound</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>Cache refresh executor exponential back off related property. It is a maximum
 multiplier value for retry delay, in case where a sequence of timeouts occurred.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.cache-refresh-executor-thread-pool-size</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>The thread pool size for the cacheRefreshExecutor to initialise with</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.client-data-accept</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>EurekaAccept name for client data accept</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.decoder-name</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>This is a transient config and once the latest codecs are stable, can be removed
 (as there will only be one)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.disable-delta</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the eureka client should disable fetching of delta and should
 rather resort to getting the full registry information.
</simpara><simpara> Note that the delta fetches can reduce the traffic tremendously, because the rate
 of change with the eureka server is normally much lower than the rate of fetches.
</simpara><simpara> The changes are effective at runtime at the next registry fetch cycle as specified
 by registryFetchIntervalSeconds</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.dollar-replacement</simpara></entry>
<entry align="left" valign="top"><simpara>_-</simpara></entry>
<entry align="left" valign="top"><simpara>Get a replacement string for Dollar sign &lt;code&gt;$&lt;/code&gt; during
 serializing/deserializing information in eureka server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that the Eureka client is enabled.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.encoder-name</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>This is a transient config and once the latest codecs are stable, can be removed
 (as there will only be one)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.escape-char-replacement</simpara></entry>
<entry align="left" valign="top"><simpara>__</simpara></entry>
<entry align="left" valign="top"><simpara>Get a replacement string for underscore sign &lt;code&gt;_&lt;/code&gt; during
 serializing/deserializing information in eureka server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.eureka-connection-idle-timeout-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates how much time (in seconds) that the HTTP connections to eureka server can
 stay idle before it can be closed.
</simpara><simpara> In the AWS environment, it is recommended that the values is 30 seconds or less,
 since the firewall cleans up the connection information after a few mins leaving
 the connection hanging in limbo</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.eureka-server-connect-timeout-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates how long to wait (in seconds) before a connection to eureka server needs
 to timeout. Note that the connections in the client are pooled by
 org.apache.http.client.HttpClient and this setting affects the actual connection
 creation and also the wait time to get the connection from the pool.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.eureka-server-d-n-s-name</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the DNS name to be queried to get the list of eureka servers.This information
 is not required if the contract returns the service urls by implementing
 serviceUrls.
</simpara><simpara> The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the
 eureka client expects the DNS to configured a certain way so that it can fetch
 changing eureka servers dynamically.
</simpara><simpara> The changes are effective at runtime.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.eureka-server-port</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the port to be used to construct the service url to contact eureka server when
 the list of eureka servers come from the DNS.This information is not required if
 the contract returns the service urls eurekaServerServiceUrls(String).
</simpara><simpara> The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the
 eureka client expects the DNS to configured a certain way so that it can fetch
 changing eureka servers dynamically.
</simpara><simpara> The changes are effective at runtime.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.eureka-server-read-timeout-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates how long to wait (in seconds) before a read from eureka server needs to
 timeout.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.eureka-server-total-connections</simpara></entry>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>Gets the total number of connections that is allowed from eureka client to all
 eureka servers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.eureka-server-total-connections-per-host</simpara></entry>
<entry align="left" valign="top"><simpara>50</simpara></entry>
<entry align="left" valign="top"><simpara>Gets the total number of connections that is allowed from eureka client to a eureka
 server host.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.eureka-server-u-r-l-context</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the URL context to be used to construct the service url to contact eureka
 server when the list of eureka servers come from the DNS. This information is not
 required if the contract returns the service urls from eurekaServerServiceUrls.
</simpara><simpara> The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the
 eureka client expects the DNS to configured a certain way so that it can fetch
 changing eureka servers dynamically. The changes are effective at runtime.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.eureka-service-url-poll-interval-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates how often(in seconds) to poll for changes to eureka server information.
 Eureka servers could be added or removed and this setting controls how soon the
 eureka clients should know about it.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.fetch-registry</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether this client should fetch eureka registry information from eureka
 server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.fetch-remote-regions-registry</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Comma separated list of regions for which the eureka registry information will be
 fetched. It is mandatory to define the availability zones for each of these regions
 as returned by availabilityZones. Failing to do so, will result in failure of
 discovery client startup.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.filter-only-up-instances</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether to get the applications after filtering the applications for
 instances with only InstanceStatus UP states.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.g-zip-content</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the content fetched from eureka server has to be compressed
 whenever it is supported by the server. The registry information from the eureka
 server is compressed for optimum network traffic.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.heartbeat-executor-exponential-back-off-bound</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>Heartbeat executor exponential back off related property. It is a maximum
 multiplier value for retry delay, in case where a sequence of timeouts occurred.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.heartbeat-executor-thread-pool-size</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>The thread pool size for the heartbeatExecutor to initialise with</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.initial-instance-info-replication-interval-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>40</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates how long initially (in seconds) to replicate instance info to the eureka
 server</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.instance-info-replication-interval-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates how often(in seconds) to replicate instance changes to be replicated to
 the eureka server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.log-delta-diff</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether to log differences between the eureka server and the eureka
 client in terms of registry information.
</simpara><simpara> Eureka client tries to retrieve only delta changes from eureka server to minimize
 network traffic. After receiving the deltas, eureka client reconciles the
 information from the server to verify it has not missed out some information.
 Reconciliation failures could happen when the client has had network issues
 communicating to server.If the reconciliation fails, eureka client gets the full
 registry information.
</simpara><simpara> While getting the full registry information, the eureka client can log the
 differences between the client and the server and this setting controls that.
</simpara><simpara> The changes are effective at runtime at the next registry fetch cycle as specified
 by registryFetchIntervalSecondsr</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.on-demand-update-status-change</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>If set to true, local status updates via ApplicationInfoManager will trigger
 on-demand (but rate limited) register/updates to remote eureka servers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.prefer-same-zone-eureka</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether or not this instance should try to use the eureka server in the
 same zone for latency and/or other reason.
</simpara><simpara> Ideally eureka clients are configured to talk to servers in the same zone
</simpara><simpara> The changes are effective at runtime at the next registry fetch cycle as specified
 by registryFetchIntervalSeconds</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.property-resolver</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.proxy-host</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the proxy host to eureka server if any.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.proxy-password</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the proxy password if any.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.proxy-port</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the proxy port to eureka server if any.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.proxy-user-name</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the proxy user name if any.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.region</simpara></entry>
<entry align="left" valign="top"><simpara>us-east-1</simpara></entry>
<entry align="left" valign="top"><simpara>Gets the region (used in AWS datacenters) where this instance resides.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.register-with-eureka</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether or not this instance should register its information with eureka
 server for discovery by others.
</simpara><simpara> In some cases, you do not want your instances to be discovered whereas you just
 want do discover other instances.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.registry-fetch-interval-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates how often(in seconds) to fetch the registry information from the eureka
 server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.registry-refresh-single-vip-address</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Indicates whether the client is only interested in the registry information for a
 single VIP.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.service-url</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Map of availability zone to list of fully qualified URLs to communicate with eureka
 server. Each value can be a single URL or a comma separated list of alternative
 locations.
</simpara><simpara> Typically the eureka server URLs carry protocol,host,port,context and version
 information if any. Example:
 <link xl:href="https://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/">https://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/</link>
</simpara><simpara> The changes are effective at runtime at the next service url refresh cycle as
 specified by eurekaServiceUrlPollIntervalSeconds.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.transport</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.client.use-dns-for-fetching-service-urls</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the eureka client should use the DNS mechanism to fetch a list of
 eureka servers to talk to. When the DNS name is updated to have additional servers,
 that information is used immediately after the eureka client polls for that
 information as specified in eurekaServiceUrlPollIntervalSeconds.
</simpara><simpara> Alternatively, the service urls can be returned serviceUrls, but the users should
 implement their own mechanism to return the updated list in case of changes.
</simpara><simpara> The changes are effective at runtime.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.dashboard.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to enable the Eureka dashboard. Default true.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.dashboard.path</simpara></entry>
<entry align="left" valign="top"><simpara>/</simpara></entry>
<entry align="left" valign="top"><simpara>The path to the Eureka dashboard (relative to the servlet path). Defaults to "/".</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.a-s-g-name</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the AWS autoscaling group name associated with this instance. This information
 is specifically used in an AWS environment to automatically put an instance out of
 service after the instance is launched and it has been disabled for traffic..</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.app-group-name</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Get the name of the application group to be registered with eureka.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.appname</simpara></entry>
<entry align="left" valign="top"><simpara>unknown</simpara></entry>
<entry align="left" valign="top"><simpara>Get the name of the application to be registered with eureka.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.data-center-info</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Returns the data center this instance is deployed. This information is used to get
 some AWS specific instance information if the instance is deployed in AWS.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.default-address-resolution-order</simpara></entry>
<entry align="left" valign="top"><simpara>[]</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.environment</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.health-check-url</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the absolute health check page URL for this instance. The users can provide
 the healthCheckUrlPath if the health check page resides in the same instance
 talking to eureka, else in the cases where the instance is a proxy for some other
 server, users can provide the full URL. If the full URL is provided it takes
 precedence.
</simpara><simpara> &lt;p&gt;
 It is normally used for making educated decisions based on the health of the
 instance - for example, it can be used to determine whether to proceed deployments
 to an entire farm or stop the deployments without causing further damage. The full
 URL should follow the format <link xl:href="http://${eureka.hostname}:7001/">http://${eureka.hostname}:7001/</link> where the value
 ${eureka.hostname} is replaced at runtime.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.health-check-url-path</simpara></entry>
<entry align="left" valign="top"><simpara>/health</simpara></entry>
<entry align="left" valign="top"><simpara>Gets the relative health check URL path for this instance. The health check page
 URL is then constructed out of the hostname and the type of communication - secure
 or unsecure as specified in securePort and nonSecurePort.
</simpara><simpara> It is normally used for making educated decisions based on the health of the
 instance - for example, it can be used to determine whether to proceed deployments
 to an entire farm or stop the deployments without causing further damage.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.home-page-url</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the absolute home page URL for this instance. The users can provide the
 homePageUrlPath if the home page resides in the same instance talking to eureka,
 else in the cases where the instance is a proxy for some other server, users can
 provide the full URL. If the full URL is provided it takes precedence.
</simpara><simpara> It is normally used for informational purposes for other services to use it as a
 landing page. The full URL should follow the format <link xl:href="http://${eureka.hostname}:7001/">http://${eureka.hostname}:7001/</link>
 where the value ${eureka.hostname} is replaced at runtime.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.home-page-url-path</simpara></entry>
<entry align="left" valign="top"><simpara>/</simpara></entry>
<entry align="left" valign="top"><simpara>Gets the relative home page URL Path for this instance. The home page URL is then
 constructed out of the hostName and the type of communication - secure or unsecure.
</simpara><simpara> It is normally used for informational purposes for other services to use it as a
 landing page.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.host-info</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.hostname</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>The hostname if it can be determined at configuration time (otherwise it will be
 guessed from OS primitives).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.inet-utils</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.initial-status</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Initial status to register with rmeote Eureka server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.instance-enabled-onit</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the instance should be enabled for taking traffic as soon as it
 is registered with eureka. Sometimes the application might need to do some
 pre-processing before it is ready to take traffic.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.instance-id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Get the unique Id (within the scope of the appName) of this instance to be
 registered with eureka.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.ip-address</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Get the IPAdress of the instance. This information is for academic purposes only as
 the communication from other instances primarily happen using the information
 supplied in {@link #getHostName(boolean)}.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.lease-expiration-duration-in-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>90</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates the time in seconds that the eureka server waits since it received the
 last heartbeat before it can remove this instance from its view and there by
 disallowing traffic to this instance.
</simpara><simpara> Setting this value too long could mean that the traffic could be routed to the
 instance even though the instance is not alive. Setting this value too small could
 mean, the instance may be taken out of traffic because of temporary network
 glitches.This value to be set to atleast higher than the value specified in
 leaseRenewalIntervalInSeconds.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.lease-renewal-interval-in-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates how often (in seconds) the eureka client needs to send heartbeats to
 eureka server to indicate that it is still alive. If the heartbeats are not
 received for the period specified in leaseExpirationDurationInSeconds, eureka
 server will remove the instance from its view, there by disallowing traffic to this
 instance.
</simpara><simpara> Note that the instance could still not take traffic if it implements
 HealthCheckCallback and then decides to make itself unavailable.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.metadata-map</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the metadata name/value pairs associated with this instance. This information
 is sent to eureka server and can be used by other instances.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.namespace</simpara></entry>
<entry align="left" valign="top"><simpara>eureka</simpara></entry>
<entry align="left" valign="top"><simpara>Get the namespace used to find properties. Ignored in Spring Cloud.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.non-secure-port</simpara></entry>
<entry align="left" valign="top"><simpara>80</simpara></entry>
<entry align="left" valign="top"><simpara>Get the non-secure port on which the instance should receive traffic.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.non-secure-port-enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the non-secure port should be enabled for traffic or not.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.prefer-ip-address</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to say that, when guessing a hostname, the IP address of the server should be
 used in prference to the hostname reported by the OS.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.registry.default-open-for-traffic-count</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Value used in determining when leases are cancelled, default to 1 for standalone.
 Should be set to 0 for peer replicated eurekas</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.registry.expected-number-of-renews-per-min</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.secure-health-check-url</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the absolute secure health check page URL for this instance. The users can
 provide the secureHealthCheckUrl if the health check page resides in the same
 instance talking to eureka, else in the cases where the instance is a proxy for
 some other server, users can provide the full URL. If the full URL is provided it
 takes precedence.
</simpara><simpara> &lt;p&gt;
 It is normally used for making educated decisions based on the health of the
 instance - for example, it can be used to determine whether to proceed deployments
 to an entire farm or stop the deployments without causing further damage. The full
 URL should follow the format <link xl:href="http://${eureka.hostname}:7001/">http://${eureka.hostname}:7001/</link> where the value
 ${eureka.hostname} is replaced at runtime.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.secure-port</simpara></entry>
<entry align="left" valign="top"><simpara>443</simpara></entry>
<entry align="left" valign="top"><simpara>Get the Secure port on which the instance should receive traffic.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.secure-port-enabled</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the secure port should be enabled for traffic or not.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.secure-virtual-host-name</simpara></entry>
<entry align="left" valign="top"><simpara>unknown</simpara></entry>
<entry align="left" valign="top"><simpara>Gets the secure virtual host name defined for this instance.
</simpara><simpara> This is typically the way other instance would find this instance by using the
 secure virtual host name.Think of this as similar to the fully qualified domain
 name, that the users of your services will need to find this instance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.status-page-url</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the absolute status page URL path for this instance. The users can provide the
 statusPageUrlPath if the status page resides in the same instance talking to
 eureka, else in the cases where the instance is a proxy for some other server,
 users can provide the full URL. If the full URL is provided it takes precedence.
</simpara><simpara> It is normally used for informational purposes for other services to find about the
 status of this instance. Users can provide a simple HTML indicating what is the
 current status of the instance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.status-page-url-path</simpara></entry>
<entry align="left" valign="top"><simpara>/info</simpara></entry>
<entry align="left" valign="top"><simpara>Gets the relative status page URL path for this instance. The status page URL is
 then constructed out of the hostName and the type of communication - secure or
 unsecure as specified in securePort and nonSecurePort.
</simpara><simpara> It is normally used for informational purposes for other services to find about the
 status of this instance. Users can provide a simple HTML indicating what is the
 current status of the instance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.instance.virtual-host-name</simpara></entry>
<entry align="left" valign="top"><simpara>unknown</simpara></entry>
<entry align="left" valign="top"><simpara>Gets the virtual host name defined for this instance.
</simpara><simpara> This is typically the way other instance would find this instance by using the
 virtual host name.Think of this as similar to the fully qualified domain name, that
 the users of your services will need to find this instance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.a-s-g-cache-expiry-timeout-ms</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.a-s-g-query-timeout-ms</simpara></entry>
<entry align="left" valign="top"><simpara>300</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.a-s-g-update-interval-ms</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.a-w-s-access-id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.a-w-s-secret-key</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.batch-replication</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.binding-strategy</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.delta-retention-timer-interval-in-ms</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.disable-delta</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.disable-delta-for-remote-regions</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.disable-transparent-fallback-to-other-region</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.e-i-p-bind-rebind-retries</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.e-i-p-binding-retry-interval-ms</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.e-i-p-binding-retry-interval-ms-when-unbound</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.enable-replicated-request-compression</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.enable-self-preservation</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.eviction-interval-timer-in-ms</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.g-zip-content-from-remote-region</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.json-codec-name</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.list-auto-scaling-groups-role-name</simpara></entry>
<entry align="left" valign="top"><simpara>ListAutoScalingGroups</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.log-identity-headers</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.max-elements-in-peer-replication-pool</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.max-elements-in-status-replication-pool</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.max-idle-thread-age-in-minutes-for-peer-replication</simpara></entry>
<entry align="left" valign="top"><simpara>15</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.max-idle-thread-in-minutes-age-for-status-replication</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.max-threads-for-peer-replication</simpara></entry>
<entry align="left" valign="top"><simpara>20</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.max-threads-for-status-replication</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.max-time-for-replication</simpara></entry>
<entry align="left" valign="top"><simpara>30000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.min-threads-for-peer-replication</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.min-threads-for-status-replication</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.number-of-replication-retries</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.peer-eureka-nodes-update-interval-ms</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.peer-eureka-status-refresh-time-interval-ms</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.peer-node-connect-timeout-ms</simpara></entry>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.peer-node-connection-idle-timeout-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.peer-node-read-timeout-ms</simpara></entry>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.peer-node-total-connections</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.peer-node-total-connections-per-host</simpara></entry>
<entry align="left" valign="top"><simpara>500</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.prime-aws-replica-connections</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.property-resolver</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.rate-limiter-burst-size</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.rate-limiter-enabled</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.rate-limiter-full-fetch-average-rate</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.rate-limiter-privileged-clients</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.rate-limiter-registry-fetch-average-rate</simpara></entry>
<entry align="left" valign="top"><simpara>500</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.rate-limiter-throttle-standard-clients</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.registry-sync-retries</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.registry-sync-retry-wait-ms</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-app-whitelist</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-connect-timeout-ms</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-connection-idle-timeout-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-fetch-thread-pool-size</simpara></entry>
<entry align="left" valign="top"><simpara>20</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-read-timeout-ms</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-registry-fetch-interval</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-total-connections</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-total-connections-per-host</simpara></entry>
<entry align="left" valign="top"><simpara>500</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-trust-store</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-trust-store-password</simpara></entry>
<entry align="left" valign="top"><simpara>changeit</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-urls</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.remote-region-urls-with-name</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.renewal-percent-threshold</simpara></entry>
<entry align="left" valign="top"><simpara>0.85</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.renewal-threshold-update-interval-ms</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.response-cache-auto-expiration-in-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>180</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.response-cache-update-interval-ms</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.retention-time-in-m-s-in-delta-queue</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.route53-bind-rebind-retries</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.route53-binding-retry-interval-ms</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.route53-domain-t-t-l</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.sync-when-timestamp-differs</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.use-read-only-response-cache</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.wait-time-in-ms-when-sync-empty</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>eureka.server.xml-codec-name</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>feign.compression.request.mime-types</simpara></entry>
<entry align="left" valign="top"><simpara>[text/xml, application/xml, application/json]</simpara></entry>
<entry align="left" valign="top"><simpara>The list of supported mime types.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>feign.compression.request.min-request-size</simpara></entry>
<entry align="left" valign="top"><simpara>2048</simpara></entry>
<entry align="left" valign="top"><simpara>The minimum threshold content size.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>health.config.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that the config server health indicator should be installed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>health.config.time-to-live</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>Time to live for cached result, in milliseconds. Default 300000 (5 min).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>hystrix.metrics.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Enable Hystrix metrics polling. Defaults to true.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>hystrix.metrics.polling-interval-ms</simpara></entry>
<entry align="left" valign="top"><simpara>2000</simpara></entry>
<entry align="left" valign="top"><simpara>Interval between subsequent polling of metrics. Defaults to 2000 ms.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>management.health.refresh.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Enable the health endpoint for the refresh scope.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>management.health.zookeeper.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Enable the health endpoint for zookeeper.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>netflix.atlas.batch-size</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>netflix.atlas.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>netflix.atlas.uri</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>netflix.metrics.servo.cache-warning-threshold</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>When the <literal>ServoMonitorCache</literal> reaches this size, a warning is logged.
 This will be useful if you are using string concatenation in RestTemplate urls.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>netflix.metrics.servo.registry-class</simpara></entry>
<entry align="left" valign="top"><simpara>com.netflix.servo.BasicMonitorRegistry</simpara></entry>
<entry align="left" valign="top"><simpara>Fully qualified class name for monitor registry used by Servo.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>proxy.auth.load-balanced</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>proxy.auth.routes</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Authentication strategy per route.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.bus.ack.destination-service</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Service that wants to listen to acks. By default null (meaning all services).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.bus.ack.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to switch off acks (default on).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.bus.destination</simpara></entry>
<entry align="left" valign="top"><simpara>springCloudBus</simpara></entry>
<entry align="left" valign="top"><simpara>Name of Spring Cloud Stream destination for messages.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.bus.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that the bus is enabled.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.bus.env.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to switch off environment change events (default on).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.bus.refresh.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to switch off refresh events (default on).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.bus.trace.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to switch on tracing of acks (default off).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.cloudfoundry.discovery.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that discovery is enabled.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.cloudfoundry.discovery.heartbeat-frequency</simpara></entry>
<entry align="left" valign="top"><simpara>5000</simpara></entry>
<entry align="left" valign="top"><simpara>Frequency in milliseconds of poll for heart beat. The client will poll on this
 frequency and broadcast a list of service ids.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.cloudfoundry.discovery.org</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Organization name to authenticate with (default to user&#8217;s default).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.cloudfoundry.discovery.password</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Password for user to authenticate and obtain token.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.cloudfoundry.discovery.space</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Space name to authenticate with (default to user&#8217;s default).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.cloudfoundry.discovery.url</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://api.run.pivotal.io">https://api.run.pivotal.io</link></simpara></entry>
<entry align="left" valign="top"><simpara>URL of Cloud Foundry API (Cloud Controller).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.cloudfoundry.discovery.username</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Username to authenticate (usually an email address).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.allow-override</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that {@link #isSystemPropertiesOverride()
 systemPropertiesOverride} can be used. Set to false to prevent users from changing
 the default accidentally. Default true.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.authorization</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Authorization token used by the client to connect to the server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.discovery.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that config server discovery is enabled (config server URL will be
 looked up via discovery).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.discovery.service-id</simpara></entry>
<entry align="left" valign="top"><simpara>configserver</simpara></entry>
<entry align="left" valign="top"><simpara>Service id to locate config server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to say that remote configuration is enabled. Default true;</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.fail-fast</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that failure to connect to the server is fatal (default false).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.label</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>The label name to use to pull remote configuration properties. The default is set
 on the server (generally "master" for a git based server).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.name</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Name of application used to fetch remote properties.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.override-none</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that when {@link #setAllowOverride(boolean) allowOverride} is
 true, external properties should take lowest priority, and not override any
 existing property sources (including local config files). Default false.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.override-system-properties</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that the external properties should override system properties.
 Default true.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.password</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>The password to use (HTTP Basic) when contacting the remote server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.profile</simpara></entry>
<entry align="left" valign="top"><simpara>default</simpara></entry>
<entry align="left" valign="top"><simpara>The default profile to use when fetching remote configuration (comma-separated).
 Default is "default".</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.retry.initial-interval</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>Initial retry interval in milliseconds.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.retry.max-attempts</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum number of attempts.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.retry.max-interval</simpara></entry>
<entry align="left" valign="top"><simpara>2000</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum interval for backoff.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.retry.multiplier</simpara></entry>
<entry align="left" valign="top"><simpara>1.1</simpara></entry>
<entry align="left" valign="top"><simpara>Multiplier for next interval.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.bootstrap</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Flag indicating that the config server should initialize its own Environment with
 properties from the remote repository. Off by default because it delays startup but
 can be useful when embedding the server in another application.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.default-application-name</simpara></entry>
<entry align="left" valign="top"><simpara>application</simpara></entry>
<entry align="left" valign="top"><simpara>Default application name when incoming requests do not have a specific one.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.default-label</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Default repository label when incoming requests do not have a specific label.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.default-profile</simpara></entry>
<entry align="left" valign="top"><simpara>default</simpara></entry>
<entry align="left" valign="top"><simpara>Default application profile when incoming requests do not have a specific one.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.encrypt.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Enable decryption of environment properties before sending to client.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.basedir</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Base directory for local working copy of repository.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.clone-on-start</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that the repository should be cloned on startup (not on demand).
 Generally leads to slower startup but faster first query.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.default-label</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.environment</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.force-pull</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that the repository should force pull. If true discard any local
 changes and take from remote repository.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.git-factory</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.password</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Password for authentication with remote repository.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.repos</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Map of repository identifier to location and other properties.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.search-paths</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Search paths to use within local working copy. By default searches only the root.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.timeout</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Timeout (in seconds) for obtaining HTTP or SSH connection (if applicable). Default
 5 seconds.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.uri</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>URI of remote repository.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.git.username</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Username for authentication with remote repository.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.health.repositories</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.native.fail-on-error</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to determine how to handle exceptions during decryption (default false).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.native.search-locations</simpara></entry>
<entry align="left" valign="top"><simpara>[]</simpara></entry>
<entry align="left" valign="top"><simpara>Locations to search for configuration files. Defaults to the same as a Spring Boot
 app so [classpath:/,classpath:/config/,file:./,file:./config/].</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.native.version</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Version string to be reported for native repository</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.overrides</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Extra map for a property source to be sent to all clients unconditionally.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.prefix</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Prefix for configuration resource paths (default is empty). Useful when embedding
 in another application when you don&#8217;t want to change the context path or servlet
 path.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.strip-document-from-yaml</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to indicate that YAML documents that are text or collections (not a map)
 should be returned in "native" form.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.svn.basedir</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Base directory for local working copy of repository.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.svn.default-label</simpara></entry>
<entry align="left" valign="top"><simpara>trunk</simpara></entry>
<entry align="left" valign="top"><simpara>The default label for environment properties requests.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.svn.environment</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.svn.password</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Password for authentication with remote repository.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.svn.search-paths</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Search paths to use within local working copy. By default searches only the root.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.svn.uri</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>URI of remote repository.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.server.svn.username</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Username for authentication with remote repository.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.token</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Security Token passed thru to underlying environment repository.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.uri</simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="http://localhost:8888">http://localhost:8888</link></simpara></entry>
<entry align="left" valign="top"><simpara>The URI of the remote server (default <link xl:href="http://localhost:8888">http://localhost:8888</link>).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.config.username</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>The username to use (HTTP Basic) when contacting the remote server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.config.acl-token</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.config.data-key</simpara></entry>
<entry align="left" valign="top"><simpara>data</simpara></entry>
<entry align="left" valign="top"><simpara>If format is Format.PROPERTIES or Format.YAML
 then the following field is used as key to look up consul for configuration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.config.default-context</simpara></entry>
<entry align="left" valign="top"><simpara>application</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.config.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.config.fail-fast</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Throw exceptions during config lookup if true, otherwise, log warnings.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.config.format</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.config.prefix</simpara></entry>
<entry align="left" valign="top"><simpara>config</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.config.profile-separator</simpara></entry>
<entry align="left" valign="top"><simpara>,</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.config.watch.delay</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>The value of the fixed delay for the watch in millis. Defaults to 1000.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.config.watch.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>If the watch is enabled. Defaults to true.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.config.watch.wait-time</simpara></entry>
<entry align="left" valign="top"><simpara>55</simpara></entry>
<entry align="left" valign="top"><simpara>The number of seconds to wait (or block) for watch query, defaults to 55.
 Needs to be less than default ConsulClient (defaults to 60). To increase ConsulClient
 timeout create a ConsulClient bean with a custom ConsulRawClient with a custom
 HttpClient.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.acl-token</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.catalog-services-watch-delay</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.catalog-services-watch-timeout</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.default-query-tag</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Tag to query for in service list if one is not listed in serverListQueryTags.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.default-zone-metadata-name</simpara></entry>
<entry align="left" valign="top"><simpara>zone</simpara></entry>
<entry align="left" valign="top"><simpara>Service instance zone comes from metadata.
 This allows changing the metadata tag name.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Is service discovery enabled?</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.fail-fast</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Throw exceptions during service registration if true, otherwise, log
 warnings (defaults to true).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.health-check-interval</simpara></entry>
<entry align="left" valign="top"><simpara>10s</simpara></entry>
<entry align="left" valign="top"><simpara>How often to perform the health check (e.g. 10s)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.health-check-path</simpara></entry>
<entry align="left" valign="top"><simpara>/health</simpara></entry>
<entry align="left" valign="top"><simpara>Alternate server path to invoke for health checking</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.health-check-timeout</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Timeout for health check (e.g. 10s)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.health-check-url</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Custom health check url to override default</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.heartbeat.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.heartbeat.heartbeat-interval</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.heartbeat.interval-ratio</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.heartbeat.ttl-unit</simpara></entry>
<entry align="left" valign="top"><simpara>s</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.heartbeat.ttl-value</simpara></entry>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.host-info</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.hostname</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Hostname to use when accessing server</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.instance-id</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Unique service instance id</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.instance-zone</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Service instance zone</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.ip-address</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>IP address to use when accessing service (must also set preferIpAddress
			to use)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.lifecycle.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.management-port</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Port to register the management service under (defaults to management port)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.management-suffix</simpara></entry>
<entry align="left" valign="top"><simpara>management</simpara></entry>
<entry align="left" valign="top"><simpara>Suffix to use when registering management service</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.management-tags</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Tags to use when registering management service</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.port</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Port to register the service under (defaults to listening port)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.prefer-agent-address</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Source of how we will determine the address to use</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.prefer-ip-address</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Use ip address rather than hostname during registration</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.query-passing</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Add the 'passing` parameter to /v1/health/service/serviceName.
 This pushes health check passing to the server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.register</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Register as a service in consul.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.register-health-check</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Register health check in consul. Useful during development of a service.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.scheme</simpara></entry>
<entry align="left" valign="top"><simpara>http</simpara></entry>
<entry align="left" valign="top"><simpara>Whether to register an http or https service</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.server-list-query-tags</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Map of serviceId&#8217;s &#8594; tag to query for in server list.
 This allows filtering services by a single tag.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.service-name</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Service name</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.discovery.tags</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Tags to use when registering service</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Is spring cloud consul enabled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.host</simpara></entry>
<entry align="left" valign="top"><simpara>localhost</simpara></entry>
<entry align="left" valign="top"><simpara>Consul agent hostname. Defaults to 'localhost'.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.port</simpara></entry>
<entry align="left" valign="top"><simpara>8500</simpara></entry>
<entry align="left" valign="top"><simpara>Consul agent port. Defaults to '8500'.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.retry.initial-interval</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>Initial retry interval in milliseconds.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.retry.max-attempts</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum number of attempts.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.retry.max-interval</simpara></entry>
<entry align="left" valign="top"><simpara>2000</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum interval for backoff.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.consul.retry.multiplier</simpara></entry>
<entry align="left" valign="top"><simpara>1.1</simpara></entry>
<entry align="left" valign="top"><simpara>Multiplier for next interval.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.hypermedia.refresh.fixed-delay</simpara></entry>
<entry align="left" valign="top"><simpara>5000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.hypermedia.refresh.initial-delay</simpara></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.inetutils.default-hostname</simpara></entry>
<entry align="left" valign="top"><simpara>localhost</simpara></entry>
<entry align="left" valign="top"><simpara>The default hostname. Used in case of errors.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.inetutils.default-ip-address</simpara></entry>
<entry align="left" valign="top"><simpara>127.0.0.1</simpara></entry>
<entry align="left" valign="top"><simpara>The default ipaddress. Used in case of errors.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.inetutils.ignored-interfaces</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>List of Java regex expressions for network interfaces that will be ignored.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.inetutils.preferred-networks</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>List of Java regex expressions for network addresses that will be ignored.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.inetutils.timeout-seconds</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Timeout in seconds for calculating hostname.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.inetutils.use-only-site-local-interfaces</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Use only interfaces with site local addresses. See {@link InetAddress#isSiteLocalAddress()} for more details.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.loadbalancer.retry.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.binders</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.bindings</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.consul.binder.event-timeout</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.consumer-defaults</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.default-binder</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.dynamic-destinations</simpara></entry>
<entry align="left" valign="top"><simpara>[]</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.ignore-unknown-properties</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.instance-count</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.instance-index</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.producer-defaults</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.rabbit.binder.admin-adresses</simpara></entry>
<entry align="left" valign="top"><simpara>[]</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.rabbit.binder.compression-level</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.rabbit.binder.nodes</simpara></entry>
<entry align="left" valign="top"><simpara>[]</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.stream.rabbit.bindings</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.base-sleep-time-ms</simpara></entry>
<entry align="left" valign="top"><simpara>50</simpara></entry>
<entry align="left" valign="top"><simpara>Initial amount of time to wait between retries</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.block-until-connected-unit</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>The unit of time related to blocking on connection to Zookeeper</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.block-until-connected-wait</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>Wait time to block on connection to Zookeeper</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.connect-string</simpara></entry>
<entry align="left" valign="top"><simpara>localhost:2181</simpara></entry>
<entry align="left" valign="top"><simpara>Connection string to the Zookeeper cluster</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.default-health-endpoint</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Default health endpoint that will be checked to verify that a dependency is alive</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.dependencies</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Mapping of alias to ZookeeperDependency. From Ribbon perspective the alias
 is actually serviceID since Ribbon can&#8217;t accept nested structures in serviceID</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.dependency-configurations</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.dependency-names</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.discovery.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.discovery.instance-host</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Predefined host with which a service can register itself in Zookeeper. Corresponds
 to the {code address} from the URI spec.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.discovery.instance-port</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Port to register the service under (defaults to listening port)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.discovery.metadata</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Gets the metadata name/value pairs associated with this instance. This information
 is sent to zookeeper and can be used by other instances.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.discovery.register</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Register as a service in zookeeper.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.discovery.root</simpara></entry>
<entry align="left" valign="top"><simpara>/services</simpara></entry>
<entry align="left" valign="top"><simpara>Root Zookeeper folder in which all instances are registered</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.discovery.uri-spec</simpara></entry>
<entry align="left" valign="top"><simpara>{scheme}://{address}:{port}</simpara></entry>
<entry align="left" valign="top"><simpara>The URI specification to resolve during service registration in Zookeeper</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Is Zookeeper enabled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.max-retries</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>Max number of times to retry</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.max-sleep-ms</simpara></entry>
<entry align="left" valign="top"><simpara>500</simpara></entry>
<entry align="left" valign="top"><simpara>Max time in ms to sleep on each retry</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.cloud.zookeeper.prefix</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Common prefix that will be applied to all Zookeeper dependencies' paths</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.integration.poller.fixed-delay</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>Fixed delay for default poller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.integration.poller.max-messages-per-poll</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum messages per poll for the default poller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.integration.enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Enable Spring Integration sleuth instrumentation.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.integration.patterns</simpara></entry>
<entry align="left" valign="top"><simpara>*</simpara></entry>
<entry align="left" valign="top"><simpara>An array of simple patterns against which channel names will be matched. Default is * (all channels). See org.springframework.util.PatternMatchUtils.simpleMatch(String, String).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.async.class-name-key</simpara></entry>
<entry align="left" valign="top"><simpara>class</simpara></entry>
<entry align="left" valign="top"><simpara>Simple name of the class with a method annotated with {@code @Async}
 from which the asynchronous process started
</simpara><simpara> @see org.springframework.scheduling.annotation.Async</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.async.method-name-key</simpara></entry>
<entry align="left" valign="top"><simpara>method</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the method annotated with {@code @Async}
</simpara><simpara> @see org.springframework.scheduling.annotation.Async</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.async.prefix</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Prefix for header names if they are added as tags.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.async.thread-name-key</simpara></entry>
<entry align="left" valign="top"><simpara>thread</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the thread that executed the async method
</simpara><simpara> @see org.springframework.scheduling.annotation.Async</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.http.headers</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Additional headers that should be added as tags if they exist. If the header
 value is multi-valued, the tag value will be a comma-separated, single-quoted
 list.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.http.host</simpara></entry>
<entry align="left" valign="top"><simpara>http.host</simpara></entry>
<entry align="left" valign="top"><simpara>The domain portion of the URL or host header. Example:
 "mybucket.s3.amazonaws.com". Used to filter by host as opposed to ip address.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.http.method</simpara></entry>
<entry align="left" valign="top"><simpara>http.method</simpara></entry>
<entry align="left" valign="top"><simpara>The HTTP method, or verb, such as "GET" or "POST". Used to filter against an
 http route.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.http.path</simpara></entry>
<entry align="left" valign="top"><simpara>http.path</simpara></entry>
<entry align="left" valign="top"><simpara>The absolute http path, without any query parameters. Example:
 "/objects/abcd-ff". Used to filter against an http route, portably with zipkin
 v1. In zipkin v1, only equals filters are supported. Dropping query parameters
 makes the number of distinct URIs less. For example, one can query for the same
 resource, regardless of signing parameters encoded in the query line. This does
 not reduce cardinality to a HTTP single route. For example, it is common to
 express a route as an http URI template like "/resource/{resource_id}". In
 systems where only equals queries are available, searching for
 {@code http.uri=/resource} won&#8217;t match if the actual request was
 "/resource/abcd-ff". Historical note: This was commonly expressed as "http.uri"
 in zipkin, eventhough it was most often just a path.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.http.prefix</simpara></entry>
<entry align="left" valign="top"><simpara>http.</simpara></entry>
<entry align="left" valign="top"><simpara>Prefix for header names if they are added as tags.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.http.request-size</simpara></entry>
<entry align="left" valign="top"><simpara>http.request.size</simpara></entry>
<entry align="left" valign="top"><simpara>The size of the non-empty HTTP request body, in bytes. Ex. "16384"
</simpara><simpara> &lt;p&gt;Large uploads can exceed limits or contribute directly to latency.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.http.response-size</simpara></entry>
<entry align="left" valign="top"><simpara>http.response.size</simpara></entry>
<entry align="left" valign="top"><simpara>The size of the non-empty HTTP response body, in bytes. Ex. "16384"
</simpara><simpara> &lt;p&gt;Large downloads can exceed limits or contribute directly to latency.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.http.status-code</simpara></entry>
<entry align="left" valign="top"><simpara>http.status_code</simpara></entry>
<entry align="left" valign="top"><simpara>The HTTP response code, when not in 2xx range. Ex. "503" Used to filter for
 error status. 2xx range are not logged as success codes are less interesting
 for latency troubleshooting. Omitting saves at least 20 bytes per span.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.http.url</simpara></entry>
<entry align="left" valign="top"><simpara>http.url</simpara></entry>
<entry align="left" valign="top"><simpara>The entire URL, including the scheme, host and query parameters if available.
 Ex.
 "https://mybucket.s3.amazonaws.com/objects/abcd-ff?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&#8230;&#8203;"
 Combined with {@link #method}, you can understand the fully-qualified
 request line. This is optional as it may include private data or be of
 considerable length.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.hystrix.command-group</simpara></entry>
<entry align="left" valign="top"><simpara>commandGroup</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the command group. Hystrix uses the command group key to group
 together commands such as for reporting, alerting, dashboards,
 or team/library ownership.
</simpara><simpara> @see com.netflix.hystrix.HystrixCommandGroupKey</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.hystrix.command-key</simpara></entry>
<entry align="left" valign="top"><simpara>commandKey</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the command key. Describes the name for the given command.
 A key to represent a {@link com.netflix.hystrix.HystrixCommand} for
 monitoring, circuit-breakers, metrics publishing, caching and other such uses.
</simpara><simpara> @see com.netflix.hystrix.HystrixCommandKey</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.hystrix.prefix</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Prefix for header names if they are added as tags.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.hystrix.thread-pool-key</simpara></entry>
<entry align="left" valign="top"><simpara>threadPoolKey</simpara></entry>
<entry align="left" valign="top"><simpara>Name of the thread pool key. The thread-pool key represents a {@link com.netflix.hystrix.HystrixThreadPool}
 for monitoring, metrics publishing, caching, and other such uses. A {@link com.netflix.hystrix.HystrixCommand}
 is associated with a single {@link com.netflix.hystrix.HystrixThreadPool} as
 retrieved by the {@link com.netflix.hystrix.HystrixThreadPoolKey} injected into it,
 or it defaults to one created using the {@link com.netflix.hystrix.HystrixCommandGroupKey}
 it is created with.
</simpara><simpara> @see com.netflix.hystrix.HystrixThreadPoolKey</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.message.headers</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Additional headers that should be added as tags if they exist. If the header
 value is not a String it will be converted to a String using its toString()
 method.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.message.payload.size</simpara></entry>
<entry align="left" valign="top"><simpara>message/payload-size</simpara></entry>
<entry align="left" valign="top"><simpara>An estimate of the size of the payload if available.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.message.payload.type</simpara></entry>
<entry align="left" valign="top"><simpara>message/payload-type</simpara></entry>
<entry align="left" valign="top"><simpara>The type of the payload.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.message.prefix</simpara></entry>
<entry align="left" valign="top"><simpara>message/</simpara></entry>
<entry align="left" valign="top"><simpara>Prefix for header names if they are added as tags.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.mvc.controller-class</simpara></entry>
<entry align="left" valign="top"><simpara>mvc.controller.class</simpara></entry>
<entry align="left" valign="top"><simpara>The lower case, hyphen delimited name of the class that processes the request.
 Ex. class named "BookController" will result in "book-controller" tag value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.keys.mvc.controller-method</simpara></entry>
<entry align="left" valign="top"><simpara>mvc.controller.method</simpara></entry>
<entry align="left" valign="top"><simpara>The lower case, hyphen delimited name of the class that processes the request.
 Ex. method named "listOfBooks" will result in "list-of-books" tag value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.metric.span.accepted-name</simpara></entry>
<entry align="left" valign="top"><simpara>counter.span.accepted</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.metric.span.dropped-name</simpara></entry>
<entry align="left" valign="top"><simpara>counter.span.dropped</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.sampler.percentage</simpara></entry>
<entry align="left" valign="top"><simpara>0.1</simpara></entry>
<entry align="left" valign="top"><simpara>Percentage of requests that should be sampled. E.g. 1.0 - 100% requests should be
 sampled. The precision is whole-numbers only (i.e. there&#8217;s no support for 0.1% of
 the traces).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spring.sleuth.trace-id128</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>When true, generate 128-bit trace IDs instead of 64-bit ones.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.add-host-header</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to determine whether the proxy forwards the Host header.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.add-proxy-headers</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to determine whether the proxy adds X-Forwarded-* headers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.host.max-per-route-connections</simpara></entry>
<entry align="left" valign="top"><simpara>20</simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of connections that can be used by a single route.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.host.max-total-connections</simpara></entry>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of total connections the proxy can hold open to backends.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.ignore-local-service</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.ignore-security-headers</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to say that SECURITY_HEADERS are added to ignored headers if spring security is on the classpath.
 By setting ignoreSecurityHeaders to false we can switch off this default behaviour. This should be used together with
 disabling the default spring security headers
 see <link xl:href="https://docs.spring.io/spring-security/site/docs/current/reference/html/headers.html#default-security-headers">https://docs.spring.io/spring-security/site/docs/current/reference/html/headers.html#default-security-headers</link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.ignored-headers</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Names of HTTP headers to ignore completely (i.e. leave them out of downstream
 requests and drop them from downstream responses).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.ignored-patterns</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.ignored-services</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Set of service names not to consider for proxying automatically. By default all
 services in the discovery client will be proxied.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.prefix</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>A common prefix for all routes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.remove-semicolon-content</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to say that path elements past the first semicolon can be dropped.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.retryable</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Flag for whether retry is supported by default (assuming the routes themselves
 support it).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.ribbon-isolation-strategy</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.routes</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Map of route names to properties.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.s-e-c-u-r-i-t-y-h-e-a-d-e-r-s</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Headers that are generally expected to be added by Spring Security, and hence often
 duplicated if the proxy and the backend are secured with Spring. By default they
 are added to the ignored headers if Spring Security is present and ignoreSecurityHeaders = true.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.semaphore.max-semaphores</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of total semaphores for Hystrix.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.sensitive-headers</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>List of sensitive headers that are not passed to downstream requests. Defaults to a
 "safe" set of headers that commonly contain user credentials. It&#8217;s OK to remove
 those from the list if the downstream service is part of the same system as the
 proxy, so they are sharing authentication data. If using a physical URL outside
 your own domain, then generally it would be a bad idea to leak user credentials.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.servlet-path</simpara></entry>
<entry align="left" valign="top"><simpara>/zuul</simpara></entry>
<entry align="left" valign="top"><simpara>Path to install Zuul as a servlet (not part of Spring MVC). The servlet is more
 memory efficient for requests with large bodies, e.g. file uploads.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.ssl-hostname-validation-enabled</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to say whether the hostname for ssl connections should be verified or not. Default is true.
 This should only be used in test setups!</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.strip-prefix</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag saying whether to strip the prefix from the path before forwarding.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zuul.trace-request-body</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>Flag to say that request bodies can be traced.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</partintro>
</part>
</book>