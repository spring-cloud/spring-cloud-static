<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Spring Cloud Function</title><link rel="stylesheet" type="text/css" href="css/manual-singlepage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book"><div class="titlepage"><div><div><h1 class="title"><a name="d0e3"></a>Spring Cloud Function</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="preface"><a href="#d0e9"></a></span></dt><dt><span class="chapter"><a href="#_introduction">1. Introduction</a></span></dt><dt><span class="chapter"><a href="#_getting_started">2. Getting Started</a></span></dt><dt><span class="chapter"><a href="#_building_and_running_a_function">3. Building and Running a Function</a></span></dt><dt><span class="chapter"><a href="#_function_catalog_and_flexible_function_signatures">4. Function Catalog and Flexible Function Signatures</a></span></dt><dd><dl><dt><span class="section"><a href="#_java_8_function_support">4.1. Java 8 function support</a></span></dt><dt><span class="section"><a href="#_kotlin_lambda_support">4.2. Kotlin Lambda support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_standalone_web_applications">5. Standalone Web Applications</a></span></dt><dt><span class="chapter"><a href="#_standalone_streaming_applications">6. Standalone Streaming Applications</a></span></dt><dt><span class="chapter"><a href="#_deploying_a_packaged_function">7. Deploying a Packaged Function</a></span></dt><dt><span class="chapter"><a href="#_functional_bean_definitions">8. Functional Bean Definitions</a></span></dt><dd><dl><dt><span class="section"><a href="#_comparing_functional_with_traditional_bean_definitions">8.1. Comparing Functional with Traditional Bean Definitions</a></span></dt><dt><span class="section"><a href="#_testing_functional_applications">8.2. Testing Functional Applications</a></span></dt><dt><span class="section"><a href="#_limitations_of_functional_bean_declaration">8.3. Limitations of Functional Bean Declaration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_dynamic_compilation">9. Dynamic Compilation</a></span></dt><dt><span class="chapter"><a href="#_serverless_platform_adapters">10. Serverless Platform Adapters</a></span></dt><dd><dl><dt><span class="section"><a href="#_aws_lambda">10.1. AWS Lambda</a></span></dt><dd><dl><dt><span class="section"><a href="#_introduction_2">10.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#_notes_on_jar_layout">10.1.2. Notes on JAR Layout</a></span></dt><dt><span class="section"><a href="#_upload">10.1.3. Upload</a></span></dt><dt><span class="section"><a href="#_platfom_specific_features">10.1.4. Platfom Specific Features</a></span></dt><dd><dl><dt><span class="section"><a href="#_http_and_api_gateway">HTTP and API Gateway</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#_azure_functions">10.2. Azure Functions</a></span></dt><dd><dl><dt><span class="section"><a href="#_notes_on_jar_layout_2">10.2.1. Notes on JAR Layout</a></span></dt><dt><span class="section"><a href="#_build">10.2.2. Build</a></span></dt><dt><span class="section"><a href="#_running_the_sample">10.2.3. Running the sample</a></span></dt></dl></dd><dt><span class="section"><a href="#_apache_openwhisk">10.3. Apache Openwhisk</a></span></dt><dd><dl><dt><span class="section"><a href="#_quick_start">10.3.1. Quick Start</a></span></dt></dl></dd></dl></dd></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="d0e9" href="#d0e9"></a></h1></div></div></div><p>Mark Fisher, Dave Syer, Oleg Zhurakousky</p><p></p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_introduction" href="#_introduction"></a>1.&nbsp;Introduction</h1></div></div></div><p>Spring Cloud Function is a project with the following high-level goals:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Promote the implementation of business logic via functions.</li><li class="listitem">Decouple the development lifecycle of business logic from any specific runtime target so that the same code can run as a web endpoint, a stream processor, or a task.</li><li class="listitem">Support a uniform programming model across serverless providers, as well as the ability to run standalone (locally or in a PaaS).</li><li class="listitem">Enable Spring Boot features (auto-configuration, dependency injection, metrics) on serverless providers.</li></ul></div><p>It abstracts away all of the transport details and
infrastructure, allowing the developer to keep all the familiar tools
and processes, and focus firmly on business logic.</p><p>Here&#8217;s a complete, executable, testable Spring Boot application
(implementing a simple string manipulation):</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; uppercase() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> flux -&gt; flux.map(value -&gt; value.toUpperCase());
  }

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
    SpringApplication.run(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
  }
}</pre><p>It&#8217;s just a Spring Boot application, so it can be built, run and
tested, locally and in a CI build, the same way as any other Spring
Boot application. The <code class="literal">Function</code> is from <code class="literal">java.util</code> and <code class="literal">Flux</code> is a
<a class="link" href="https://www.reactive-streams.org/" target="_top">Reactive Streams</a> <code class="literal">Publisher</code> from
<a class="link" href="https://projectreactor.io/" target="_top">Project Reactor</a>. The function can be
accessed over HTTP or messaging.</p><p>Spring Cloud Function has 4 main features:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Wrappers for <code class="literal">@Beans</code> of type <code class="literal">Function</code>, <code class="literal">Consumer</code> and
<code class="literal">Supplier</code>, exposing them to the outside world as either HTTP
endpoints and/or message stream listeners/publishers with RabbitMQ, Kafka etc.</li><li class="listitem">Compiling strings which are Java function bodies into bytecode, and
then turning them into <code class="literal">@Beans</code> that can be wrapped as above.</li><li class="listitem">Deploying a JAR file containing such an application context with an
isolated classloader, so that you can pack them together in a single
JVM.</li><li class="listitem">Adapters for <a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws" target="_top">AWS Lambda</a>, <a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure" target="_top">Azure</a>, <a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk" target="_top">Apache OpenWhisk</a> and possibly other "serverless" service providers.</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Spring Cloud is released under the non-restrictive Apache 2.0 license. If you would like to contribute to this section of the documentation or if you find an error, please find the source code and issue trackers in the project at <a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/docs/src/main/asciidoc" target="_top">github</a>.</p></td></tr></table></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_getting_started" href="#_getting_started"></a>2.&nbsp;Getting Started</h1></div></div></div><p>Build from the command line (and "install" the samples):</p><pre class="screen">$ ./mvnw clean install</pre><p>(If you like to YOLO add <code class="literal">-DskipTests</code>.)</p><p>Run one of the samples, e.g.</p><pre class="screen">$ java -jar spring-cloud-function-samples/function-sample/target/*.jar</pre><p>This runs the app and exposes its functions over HTTP, so you can
convert a string to uppercase, like this:</p><pre class="screen">$ curl -H "Content-Type: text/plain" localhost:8080/uppercase -d Hello
HELLO</pre><p>You can convert multiple strings (a <code class="literal">Flux&lt;String&gt;</code>) by separating them
with new lines</p><pre class="screen">$ curl -H "Content-Type: text/plain" localhost:8080/uppercase -d 'Hello
&gt; World'
HELLOWORLD</pre><p>(You can use <code class="literal"><sup>Q</sup>J</code> in a terminal to insert a new line in a literal
string like that.)</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_building_and_running_a_function" href="#_building_and_running_a_function"></a>3.&nbsp;Building and Running a Function</h1></div></div></div><p>The sample <code class="literal">@SpringBootApplication</code> above has a function that can be
decorated at runtime by Spring Cloud Function to be an HTTP endpoint,
or a Stream processor, for instance with RabbitMQ, Apache Kafka or
JMS.</p><p>The <code class="literal">@Beans</code> can be <code class="literal">Function</code>, <code class="literal">Consumer</code> or <code class="literal">Supplier</code> (all from
<code class="literal">java.util</code>), and their parametric types can be String or POJO.</p><p>Functions can also be of <code class="literal">Flux&lt;String&gt;</code> or <code class="literal">Flux&lt;Pojo&gt;</code> and Spring
Cloud Function takes care of converting the data to and from the
desired types, as long as it comes in as plain text or (in the case of
the POJO) JSON. There is also support for <code class="literal">Message&lt;Pojo&gt;</code> where the
message headers are copied from the incoming event, depending on the
adapter. The web adapter also supports conversion from form-encoded
data to a <code class="literal">Map</code>, and if you are using the function with Spring Cloud
Stream then all the conversion and coercion features for message
payloads will be applicable as well.</p><p>Functions can be grouped together in a single application, or deployed
one-per-jar. It&#8217;s up to the developer to choose. An app with multiple
functions can be deployed multiple times in different "personalities",
exposing different functions over different physical transports.</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_function_catalog_and_flexible_function_signatures" href="#_function_catalog_and_flexible_function_signatures"></a>4.&nbsp;Function Catalog and Flexible Function Signatures</h1></div></div></div><p>One of the main features of Spring Cloud Function is to adapt and support a range of type signatures for user-defined functions,
while providing a consistent execution model.
That&#8217;s why all user defined functions are transformed into a canonical representation by <code class="literal">FunctionCatalog</code>, using primitives
defined by the <a class="link" href="https://projectreactor.io/" target="_top">Project Reactor</a> (i.e., <code class="literal">Flux&lt;T&gt;</code> and <code class="literal">Mono&lt;T&gt;</code>).
Users can supply a bean of type <code class="literal">Function&lt;String,String&gt;</code>, for instance, and the <code class="literal">FunctionCatalog</code> will wrap it into a
<code class="literal">Function&lt;Flux&lt;String&gt;,Flux&lt;String&gt;&gt;</code>.</p><p>Using Reactor based primitives not only helps with the canonical representation of user defined functions, but it also
facilitates a more robust and flexible(reactive) execution model.</p><p>While users don&#8217;t normally have to care about the <code class="literal">FunctionCatalog</code> at all, it is useful to know what
kind of functions are supported in user code.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_java_8_function_support" href="#_java_8_function_support"></a>4.1&nbsp;Java 8 function support</h2></div></div></div><p>Generally speaking users can expect that if they write a function for
a plain old Java type (or primitive wrapper), then the function
catalog will wrap it to a <code class="literal">Flux</code> of the same type. If the user writes
a function using <code class="literal">Message</code> (from spring-messaging) it will receive and
transmit headers from any adapter that supports key-value metadata
(e.g. HTTP headers). Here are the details.</p><div class="informaltable"><table class="informaltable" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">User Function</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">Catalog Registration</th><th style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Function&lt;S,T&gt;</code></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Function&lt;Flux&lt;S&gt;, Flux&lt;T&gt;&gt;</code></p></td><td style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Function&lt;Message&lt;S&gt;,Message&lt;T&gt;&gt;</code></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Function&lt;Flux&lt;Message&lt;S&gt;&gt;, Flux&lt;Message&lt;T&gt;&gt;&gt;</code></p></td><td style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Function&lt;Flux&lt;S&gt;, Flux&lt;T&gt;&gt;</code></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Function&lt;Flux&lt;S&gt;, Flux&lt;T&gt;&gt;</code> (pass through)</p></td><td style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Supplier&lt;T&gt;</code></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Supplier&lt;Flux&lt;T&gt;&gt;</code></p></td><td style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Supplier&lt;Flux&lt;T&gt;&gt;</code></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Supplier&lt;Flux&lt;T&gt;&gt;</code></p></td><td style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Consumer&lt;T&gt;</code></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Function&lt;Flux&lt;T&gt;, Mono&lt;Void&gt;&gt;</code></p></td><td style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Consumer&lt;Message&lt;T&gt;&gt;</code></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">Function&lt;Flux&lt;Message&lt;T&gt;&gt;, Mono&lt;Void&gt;&gt;</code></p></td><td style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 1px solid ; " align="left" valign="top"><p><code class="literal">Consumer&lt;Flux&lt;T&gt;&gt;</code></p></td><td style="border-right: 1px solid ; " align="left" valign="top"><p><code class="literal">Consumer&lt;Flux&lt;T&gt;&gt;</code></p></td><td style="" align="left" valign="top">&nbsp;</td></tr></tbody></table></div><p>Consumer is a little bit special because it has a <code class="literal">void</code> return type,
which implies blocking, at least potentially. Most likely you will not
need to write <code class="literal">Consumer&lt;Flux&lt;?&gt;&gt;</code>, but if you do need to do that,
remember to subscribe to the input flux. If you declare a <code class="literal">Consumer</code>
of a non publisher type (which is normal), it will be converted to a
function that returns a publisher, so that it can be subscribed to in
a controlled way.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_kotlin_lambda_support" href="#_kotlin_lambda_support"></a>4.2&nbsp;Kotlin Lambda support</h2></div></div></div><p>We also provide support for Kotlin lambdas (since v2.0).
Consider the following:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
open fun kotlinSupplier(): () -&gt; String {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span>  { <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello from Kotlin"</span> }
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
open fun kotlinFunction(): (String) -&gt; String {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span>  { it.toUpperCase() }
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
open fun kotlinConsumer(): (String) -&gt; Unit {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span>  { println(it) }
}</pre><p>The above represents Kotlin lambdas configured as Spring beans. The signature of each maps to a Java equivalent of
<code class="literal">Supplier</code>, <code class="literal">Function</code> and <code class="literal">Consumer</code>, and thus supported/recognized signatures by the framework.
While mechanics of Kotlin-to-Java mapping are outside of the scope of this documentation, it is important to understand that the
same rules for signature transformation outlined in "Java 8 function support" section are applied here as well.</p><p>To enable Kotlin support all you need is to add <code class="literal">spring-cloud-function-kotlin</code> module to your classpath which contains the appropriate
autoconfiguration and supporting classes.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_standalone_web_applications" href="#_standalone_web_applications"></a>5.&nbsp;Standalone Web Applications</h1></div></div></div><p>The <code class="literal">spring-cloud-function-web</code> module has autoconfiguration that
activates when it is included in a Spring Boot web application (with
MVC support). There is also a <code class="literal">spring-cloud-starter-function-web</code> to
collect all the optional dependencies in case you just want a simple
getting started experience.</p><p>With the web configurations activated your app will have an MVC
endpoint (on "/" by default, but configurable with
<code class="literal">spring.cloud.function.web.path</code>) that can be used to access the
functions in the application context. The supported content types are
plain text and JSON.</p><div class="informaltable"><table class="informaltable" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">Method</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">Path</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">Request</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">Response</th><th style="border-bottom: 1px solid ; " align="left" valign="top">Status</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>GET</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>/{supplier}</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>-</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>Items from the named supplier</p></td><td style="border-bottom: 1px solid ; " align="left" valign="top"><p>200 OK</p></td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>POST</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>/{consumer}</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>JSON object or text</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>Mirrors input and pushes request body into consumer</p></td><td style="border-bottom: 1px solid ; " align="left" valign="top"><p>202 Accepted</p></td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>POST</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>/{consumer}</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>JSON array or text with new lines</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>Mirrors input and pushes body into consumer one by one</p></td><td style="border-bottom: 1px solid ; " align="left" valign="top"><p>202 Accepted</p></td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>POST</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>/{function}</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>JSON object or text</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>The result of applying the named function</p></td><td style="border-bottom: 1px solid ; " align="left" valign="top"><p>200 OK</p></td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>POST</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>/{function}</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>JSON array or text with new lines</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>The result of applying the named function</p></td><td style="border-bottom: 1px solid ; " align="left" valign="top"><p>200 OK</p></td></tr><tr><td style="border-right: 1px solid ; " align="left" valign="top"><p>GET</p></td><td style="border-right: 1px solid ; " align="left" valign="top"><p>/{function}/{item}</p></td><td style="border-right: 1px solid ; " align="left" valign="top"><p>-</p></td><td style="border-right: 1px solid ; " align="left" valign="top"><p>Convert the item into an object and return the result of applying the function</p></td><td style="" align="left" valign="top"><p>200 OK</p></td></tr></tbody></table></div><p>As the table above shows the behaviour of the endpoint depends on the method and also the type of incoming request data. When the incoming data is single valued, and the target function is declared as obviously single valued (i.e. not returning a collection or <code class="literal">Flux</code>), then the response will also contain a single value.
For multi-valued responses the client can ask for a server-sent event stream by sending `Accept: text/event-stream".</p><p>If there is only a single function (consumer etc.) in the catalog, the name in the path is optional.
Composite functions can be addressed using pipes or commas to separate function names (pipes are legal in URL paths, but a bit awkward to type on the command line).</p><p>For cases where there is more then a single function in catalog and you want to map a specific function to the root
path (e.g., "/"), or you want to compose several functions and then map to the root path you can do so by providing
<code class="literal">spring.cloud.function.definition</code> property which essentially used by spring-=cloud-function-web module to provide
default mapping for cases where there is some type of a conflict (e.g., more then one function available etc).</p><p>For example,</p><pre class="screen">--spring.cloud.function.definition=foo|bar</pre><p>The above property will compose 'foo' and 'bar' function and map the composed function to the "/" path.</p><p>Functions and consumers that are declared with input and output in <code class="literal">Message&lt;?&gt;</code> will see the request headers on the input messages, and the output message headers will be converted to HTTP headers.</p><p>When POSTing text the response format might be different with Spring Boot 2.0 and older versions, depending on the content negotiation (provide content type and accpt headers for the best results).</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_standalone_streaming_applications" href="#_standalone_streaming_applications"></a>6.&nbsp;Standalone Streaming Applications</h1></div></div></div><p>To send or receive messages from a broker (such as RabbitMQ or Kafka) you can leverage <code class="literal">spring-cloud-stream</code> project and it&#8217;s integration with Spring Cloud Function.
Please refer to <a class="link" href="https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/#_spring_cloud_function" target="_top">Spring Cloud Function</a> section of the Spring Cloud Stream reference manual for more details and examples.</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_deploying_a_packaged_function" href="#_deploying_a_packaged_function"></a>7.&nbsp;Deploying a Packaged Function</h1></div></div></div><p>Spring Cloud Function provides a "deployer" library that allows you to launch a jar file (or exploded archive, or set of jar files) with an isolated class loader and expose the functions defined in it. This is quite a powerful tool that would allow you to, for instance, adapt a function to a range of different input-output adapters without changing the target jar file. Serverless platforms often have this kind of feature built in, so you could see it as a building block for a function invoker in such a platform (indeed the <a class="link" href="https://projectriff.io" target="_top">Riff</a> Java function invoker uses this library).</p><p>The standard entry point of the API is the Spring configuration annotation <code class="literal">@EnableFunctionDeployer</code>. If that is used in a Spring Boot application the deployer kicks in and looks for some configuration to tell it where to find the function jar. At a minimum the user has to provide a <code class="literal">function.location</code> which is a URL or resource location for the archive containing the functions. It can optionally use a <code class="literal">maven:</code> prefix to locate the artifact via a dependency lookup (see <code class="literal">FunctionProperties</code> for complete details). A Spring Boot application is bootstrapped from the jar file, using the <code class="literal">MANIFEST.MF</code> to locate a start class, so that a standard Spring Boot fat jar works well, for example. If the target jar can be launched successfully then the result is a function registered in the main application&#8217;s <code class="literal">FunctionCatalog</code>. The registered function can be applied by code in the main application, even though it was created in an isolated class loader (by deault).</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_functional_bean_definitions" href="#_functional_bean_definitions"></a>8.&nbsp;Functional Bean Definitions</h1></div></div></div><p>Spring Cloud Function supports a "functional" style of bean declarations for small apps where you need fast startup. The functional style of bean declaration was a feature of Spring Framework 5.0 with significant enhancements in 5.1.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_comparing_functional_with_traditional_bean_definitions" href="#_comparing_functional_with_traditional_bean_definitions"></a>8.1&nbsp;Comparing Functional with Traditional Bean Definitions</h2></div></div></div><p>Here&#8217;s a vanilla Spring Cloud Function application from with the
familiar <code class="literal">@Configuration</code> and <code class="literal">@Bean</code> declaration style:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> DemoApplication {

  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Function&lt;String, String&gt; uppercase() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> value -&gt; value.toUpperCase();
  }

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
    SpringApplication.run(DemoApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
  }

}</pre><p>You can run the above in a serverless platform, like AWS Lambda or Azure Functions, or you can run it in its own HTTP server just by including <code class="literal">spring-cloud-function-starter-web</code> on the classpath. Running the main method would expose an endpoint that you can use to ping that <code class="literal">uppercase</code> function:</p><pre class="screen">$ curl localhost:8080 -d foo
FOO</pre><p>The web adapter in <code class="literal">spring-cloud-function-starter-web</code> uses Spring MVC, so you needed a Servlet container. You can also use Webflux where the default server is netty (even though you can still use Servlet containers if you want to) - just include the <code class="literal">spring-cloud-starter-function-webflux</code> dependency instead. The functionality is the same, and the user application code can be used in both.</p><p>Now for the functional beans: the user application code can be recast into "functional"
form, like this:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> DemoApplication <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> ApplicationContextInitializer&lt;GenericApplicationContext&gt; {

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
    FunctionalSpringApplication.run(DemoApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
  }

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Function&lt;String, String&gt; uppercase() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> value -&gt; value.toUpperCase();
  }

  <em><span class="hl-annotation" style="color: gray">@Override</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> initialize(GenericApplicationContext context) {
    context.registerBean(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"demo"</span>, FunctionRegistration.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>,
        () -&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FunctionRegistration&lt;&gt;(uppercase())
            .type(FunctionType.from(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).to(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)));
  }

}</pre><p>The main differences are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">The main class is an <code class="literal">ApplicationContextInitializer</code>.</li><li class="listitem">The <code class="literal">@Bean</code> methods have been converted to calls to <code class="literal">context.registerBean()</code></li><li class="listitem">The <code class="literal">@SpringBootApplication</code> has been replaced with
<code class="literal">@SpringBootConfiguration</code> to signify that we are not enabling Spring
Boot autoconfiguration, and yet still marking the class as an "entry
point".</li><li class="listitem">The <code class="literal">SpringApplication</code> from Spring Boot has been replaced with a
<code class="literal">FunctionalSpringApplication</code> from Spring Cloud Function (it&#8217;s a
subclass).</li></ul></div><p>The business logic beans that you register in a Spring Cloud Function app are of type <code class="literal">FunctionRegistration</code>. This is a wrapper that contains both the function and information about the input and output types. In the <code class="literal">@Bean</code> form of the application that information can be derived reflectively, but in a functional bean registration some of it is lost unless we use a <code class="literal">FunctionRegistration</code>.</p><p>An alternative to using an <code class="literal">ApplicationContextInitializer</code> and <code class="literal">FunctionRegistration</code> is to make the application itself implement <code class="literal">Function</code> (or <code class="literal">Consumer</code> or <code class="literal">Supplier</code>). Example (equivalent to the above):</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> DemoApplication <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> Function&lt;String, String&gt; {

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
    FunctionalSpringApplication.run(DemoApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
  }

  <em><span class="hl-annotation" style="color: gray">@Override</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String uppercase(String value) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> value.toUpperCase();
  }

}</pre><p>It would also work if you add a separate, standalone class of type <code class="literal">Function</code> and register it with the <code class="literal">SpringApplication</code> using an alternative form of the <code class="literal">run()</code> method. The main thing is that the generic type information is available at runtime through the class declaration.</p><p>The app runs in its own HTTP server if you add <code class="literal">spring-cloud-starter-function-webflux</code> (it won&#8217;t work with the MVC starter at the moment because the functional form of the embedded Servlet container hasn&#8217;t been implemented).  The app also runs just fine in AWS Lambda or Azure Functions, and the improvements in startup time are dramatic.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The "lite" web server has some limitations for the range of <code class="literal">Function</code> signatures - in particular it doesn&#8217;t (yet) support <code class="literal">Message</code> input and output, but POJOs and any kind of <code class="literal">Publisher</code> should be fine.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_testing_functional_applications" href="#_testing_functional_applications"></a>8.2&nbsp;Testing Functional Applications</h2></div></div></div><p>Spring Cloud Function also has some utilities for integration testing that will be very familiar to Spring Boot users. For example, here is an integration test for the HTTP server wrapping the app above:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@FunctionalSpringBootTest</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureWebTestClient</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FunctionalTests {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> WebTestClient client;

	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> words() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		client.post().uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/"</span>).body(Mono.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>), String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).exchange()
				.expectStatus().isOk().expectBody(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FOO"</span>);
	}

}</pre><p>This test is almost identical to the one you would write for the <code class="literal">@Bean</code> version of the same app - the only difference is the <code class="literal">@FunctionalSpringBootTest</code> annotation, instead of the regular <code class="literal">@SpringBootTest</code>. All the other pieces, like the <code class="literal">@Autowired</code> <code class="literal">WebTestClient</code>, are standard Spring Boot features.</p><p>Or you could write a test for a non-HTTP app using just the <code class="literal">FunctionCatalog</code>. For example:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@FunctionalSpringBootTest</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FunctionalTests {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> FunctionCatalog catalog;

	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> words() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; function = catalog.lookup(Function.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"function"</span>);
		assertThat(function.apply(Flux.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>)).blockFirst()).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FOO"</span>);
	}

}</pre><p>(The <code class="literal">FunctionCatalog</code> always returns functions from <code class="literal">Flux</code> to <code class="literal">Flux</code>, even if the user declares them with a simpler signature.)</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_limitations_of_functional_bean_declaration" href="#_limitations_of_functional_bean_declaration"></a>8.3&nbsp;Limitations of Functional Bean Declaration</h2></div></div></div><p>Most Spring Cloud Function apps have a relatively small scope compared to the whole of Spring Boot, so we are able to adapt it to these functional bean definitions easily. If you step outside that limited scope, you can extend your Spring Cloud Function app by switching back to <code class="literal">@Bean</code> style configuration, or by using a hybrid approach. If you want to take advantage of Spring Boot autoconfiguration for integrations with external datastores, for example, you will need to use <code class="literal">@EnableAutoConfiguration</code>. Your functions can still be defined using the functional declarations if you want (i.e. the "hybrid" style), but in that case you will need to explicitly switch off the "full functional mode" using <code class="literal">spring.functional.enabled=false</code> so that Spring Boot can take back control.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_dynamic_compilation" href="#_dynamic_compilation"></a>9.&nbsp;Dynamic Compilation</h1></div></div></div><p>There is a sample app that uses the function compiler to create a
function from a configuration property. The vanilla "function-sample"
also has that feature. And there are some scripts that you can run to
see the compilation happening at run time. To run these examples,
change into the <code class="literal">scripts</code> directory:</p><pre class="screen">cd scripts</pre><p>Also, start a RabbitMQ server locally (e.g. execute <code class="literal">rabbitmq-server</code>).</p><p>Start the Function Registry Service:</p><pre class="screen">./function-registry.sh</pre><p>Register a Function:</p><pre class="screen">./registerFunction.sh -n uppercase -f "f-&gt;f.map(s-&gt;s.toString().toUpperCase())"</pre><p>Run a REST Microservice using that Function:</p><pre class="screen">./web.sh -f uppercase -p 9000
curl -H "Content-Type: text/plain" -H "Accept: text/plain" localhost:9000/uppercase -d foo</pre><p>Register a Supplier:</p><pre class="screen">./registerSupplier.sh -n words -f "()-&gt;Flux.just(\"foo\",\"bar\")"</pre><p>Run a REST Microservice using that Supplier:</p><pre class="screen">./web.sh -s words -p 9001
curl -H "Accept: application/json" localhost:9001/words</pre><p>Register a Consumer:</p><pre class="screen">./registerConsumer.sh -n print -t String -f "System.out::println"</pre><p>Run a REST Microservice using that Consumer:</p><pre class="screen">./web.sh -c print -p 9002
curl -X POST -H "Content-Type: text/plain" -d foo localhost:9002/print</pre><p>Run Stream Processing Microservices:</p><p>First register a streaming words supplier:</p><pre class="screen">./registerSupplier.sh -n wordstream -f "()-&gt;Flux.interval(Duration.ofMillis(1000)).map(i-&gt;\"message-\"+i)"</pre><p>Then start the source (supplier), processor (function), and sink (consumer) apps
(in reverse order):</p><pre class="screen">./stream.sh -p 9103 -i uppercaseWords -c print
./stream.sh -p 9102 -i words -f uppercase -o uppercaseWords
./stream.sh -p 9101 -s wordstream -o words</pre><p>The output will appear in the console of the sink app (one message per second, converted to uppercase):</p><pre class="screen">MESSAGE-0
MESSAGE-1
MESSAGE-2
MESSAGE-3
MESSAGE-4
MESSAGE-5
MESSAGE-6
MESSAGE-7
MESSAGE-8
MESSAGE-9
...</pre></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_serverless_platform_adapters" href="#_serverless_platform_adapters"></a>10.&nbsp;Serverless Platform Adapters</h1></div></div></div><p>As well as being able to run as a standalone process, a Spring Cloud
Function application can be adapted to run one of the existing
serverless platforms. In the project there are adapters for
<a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws" target="_top">AWS
Lambda</a>,
<a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure" target="_top">Azure</a>,
and
<a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk" target="_top">Apache
OpenWhisk</a>. The <a class="link" href="https://github.com/fnproject/fn" target="_top">Oracle Fn platform</a>
has its own Spring Cloud Function adapter. And
<a class="link" href="https://projectriff.io" target="_top">Riff</a> supports Java functions and its
<a class="link" href="https://github.com/projectriff/java-function-invoker" target="_top">Java Function
Invoker</a> acts natively is an adapter for Spring Cloud Function jars.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_aws_lambda" href="#_aws_lambda"></a>10.1&nbsp;AWS Lambda</h2></div></div></div><p>The <a class="link" href="https://aws.amazon.com/" target="_top">AWS</a> adapter takes a Spring Cloud Function app and converts it to a form that can run in AWS Lambda.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_introduction_2" href="#_introduction_2"></a>10.1.1&nbsp;Introduction</h3></div></div></div><p>The adapter has a couple of generic request handlers that you can use. The most generic is <code class="literal">SpringBootStreamHandler</code>, which uses a Jackson <code class="literal">ObjectMapper</code> provided by Spring Boot to serialize and deserialize the objects in the function. There is also a <code class="literal">SpringBootRequestHandler</code> which you can extend, and provide the input and output types as type parameters (enabling AWS to inspect the class and do the JSON conversions itself).</p><p>If your app has more than one <code class="literal">@Bean</code> of type <code class="literal">Function</code> etc. then you can choose the one to use by configuring <code class="literal">function.name</code> (e.g. as <code class="literal">FUNCTION_NAME</code> environment variable in AWS). The functions are extracted from the Spring Cloud <code class="literal">FunctionCatalog</code> (searching first for <code class="literal">Function</code> then <code class="literal">Consumer</code> and finally <code class="literal">Supplier</code>).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_notes_on_jar_layout" href="#_notes_on_jar_layout"></a>10.1.2&nbsp;Notes on JAR Layout</h3></div></div></div><p>You don&#8217;t need the Spring Cloud Function Web or Stream adapter at runtime in Lambda, so you might need to exclude those before you create the JAR you send to AWS. A Lambda application has to be shaded, but a Spring Boot standalone application does not, so you can run the same app using 2 separate jars (as per the sample). The sample app creates 2 jar files, one with an <code class="literal">aws</code> classifier for deploying in Lambda, and one executable (thin) jar that includes <code class="literal">spring-cloud-function-web</code> at runtime. Spring Cloud Function will try and locate a "main class" for you from the JAR file manifest, using the <code class="literal">Start-Class</code> attribute (which will be added for you by the Spring Boot tooling if you use the starter parent). If there is no <code class="literal">Start-Class</code> in your manifest you can use an environment variable <code class="literal">MAIN_CLASS</code> when you deploy the function to AWS.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_upload" href="#_upload"></a>10.1.3&nbsp;Upload</h3></div></div></div><p>Build the sample under <code class="literal">spring-cloud-function-samples/function-sample-aws</code> and upload the <code class="literal">-aws</code> jar file to Lambda. The handler can be <code class="literal">example.Handler</code> or <code class="literal">org.springframework.cloud.function.adapter.aws.SpringBootStreamHandler</code> (FQN of the class, <span class="emphasis"><em>not</em></span> a method reference, although Lambda does accept method references).</p><pre class="screen">./mvnw -U clean package</pre><p>Using the AWS command line tools it looks like this:</p><pre class="screen">aws lambda create-function --function-name Uppercase --role arn:aws:iam::[USERID]:role/service-role/[ROLE] --zip-file fileb://function-sample-aws/target/function-sample-aws-2.0.0.BUILD-SNAPSHOT-aws.jar --handler org.springframework.cloud.function.adapter.aws.SpringBootStreamHandler --description "Spring Cloud Function Adapter Example" --runtime java8 --region us-east-1 --timeout 30 --memory-size 1024 --publish</pre><p>The input type for the function in the AWS sample is a Foo with a single property called "value". So you would need this to test it:</p><pre class="screen">{
  "value": "test"
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The AWS sample app is written in the "functional" style (as an <code class="literal">ApplicationContextInitializer</code>). This is much faster on startup in Lambda than the traditional <code class="literal">@Bean</code> style, so if you don&#8217;t need <code class="literal">@Beans</code> (or <code class="literal">@EnableAutoConfiguration</code>) it&#8217;s a good choice. Warm starts are not affected.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_platfom_specific_features" href="#_platfom_specific_features"></a>10.1.4&nbsp;Platfom Specific Features</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_http_and_api_gateway" href="#_http_and_api_gateway"></a>HTTP and API Gateway</h4></div></div></div><p>AWS has some platform-specific data types, including batching of messages, which is much more efficient than processing each one individually. To make use of these types you can write a function that depends on those types. Or you can rely on Spring to extract the data from the AWS types and convert it to a Spring <code class="literal">Message</code>. To do this you tell AWS that the function is of a specific generic handler type (depending on the AWS service) and provide a bean of type <code class="literal">Function&lt;Message&lt;S&gt;,Message&lt;T&gt;&gt;</code>, where <code class="literal">S</code> and <code class="literal">T</code> are your business data types. If there is more than one bean of type <code class="literal">Function</code> you may also need to configure the Spring Boot property <code class="literal">function.name</code> to be the name of the target bean (e.g. use <code class="literal">FUNCTION_NAME</code> as an environment variable).</p><p>The supported AWS services and generic handler types are listed below:</p><div class="informaltable"><table class="informaltable" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">Service</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">AWS Types</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">Generic Handler</th><th style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>API Gateway</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">APIGatewayProxyRequestEvent</code>, <code class="literal">APIGatewayProxyResponseEvent</code></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">org.springframework.cloud.function.adapter.aws.SpringBootApiGatewayRequestHandler</code></p></td><td style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 1px solid ; " align="left" valign="top"><p>Kinesis</p></td><td style="border-right: 1px solid ; " align="left" valign="top"><p>KinesisEvent</p></td><td style="border-right: 1px solid ; " align="left" valign="top"><p>org.springframework.cloud.function.adapter.aws.SpringBootKinesisEventHandler</p></td><td style="" align="left" valign="top">&nbsp;</td></tr></tbody></table></div><p>For example, to deploy behind an API Gateway, use <code class="literal">--handler org.springframework.cloud.function.adapter.aws.SpringBootApiGatewayRequestHandler</code> in your AWS command line (in via the UI) and define a <code class="literal">@Bean</code> of type <code class="literal">Function&lt;Message&lt;Foo&gt;,Message&lt;Bar&gt;&gt;</code> where <code class="literal">Foo</code> and <code class="literal">Bar</code> are POJO types (the data will be marshalled and unmarshalled by AWS using Jackson).</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_azure_functions" href="#_azure_functions"></a>10.2&nbsp;Azure Functions</h2></div></div></div><p>The <a class="link" href="https://azure.microsoft.com" target="_top">Azure</a> adapter bootstraps a Spring Cloud Function context and channels function calls from the Azure framework into the user functions, using Spring Boot configuration where necessary. Azure Functions has quite a unique, but invasive programming model, involving annotations in user code that are specific to the platform. The easiest way to use it with Spring Cloud is to extend a base class and write a method in it with the <code class="literal">@FunctionName</code> annotation which delegates to a base class method.</p><p>This project provides an adapter layer for a Spring Cloud Function application onto Azure.
You can write an app with a single <code class="literal">@Bean</code> of type <code class="literal">Function</code> and it will be deployable in Azure if you get the JAR file laid out right.</p><p>There is an <code class="literal">AzureSpringBootRequestHandler</code> which you must extend, and provide the input and output types as annotated method parameters (enabling Azure to inspect the class and create JSON bindings). The base class has two useful methods (<code class="literal">handleRequest</code> and <code class="literal">handleOutput</code>) to which you can delegate the actual function call, so mostly the function will only ever have one line.</p><p>Example:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooHandler <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> AzureSpringBootRequestHandler&lt;Foo, Bar&gt; {
	<em><span class="hl-annotation" style="color: gray">@FunctionName("uppercase")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Bar execute(
			<em><span class="hl-annotation" style="color: gray">@HttpTrigger(name = "req", methods = { HttpMethod.GET,
					HttpMethod.POST }, authLevel = AuthorizationLevel.ANONYMOUS)</span></em>
                    Foo foo,
			ExecutionContext context) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> handleRequest(foo, context);
	}
}</pre><p>This Azure handler will delegate to a <code class="literal">Function&lt;Foo,Bar&gt;</code> bean (or a <code class="literal">Function&lt;Publisher&lt;Foo&gt;,Publisher&lt;Bar&gt;&gt;</code>). Some Azure triggers (e.g. <code class="literal">@CosmosDBTrigger</code>) result in a input type of <code class="literal">List</code> and in that case you can bind to <code class="literal">List</code> in the Azure handler, or <code class="literal">String</code> (the raw JSON). The <code class="literal">List</code> input delegates to a <code class="literal">Function</code> with input type <code class="literal">Map&lt;String,Object&gt;</code>, or <code class="literal">Publisher</code> or <code class="literal">List</code> of the same type. The output of the <code class="literal">Function</code> can be a <code class="literal">List</code> (one-for-one) or a single value (aggregation), and the output binding in the Azure declaration should match.</p><p>If your app has more than one <code class="literal">@Bean</code> of type <code class="literal">Function</code> etc. then you can choose the one to use by configuring <code class="literal">function.name</code>. Or if you make the <code class="literal">@FunctionName</code> in the Azure handler method match the function name it should work that way (also for function apps with multiple functions). The functions are extracted from the Spring Cloud <code class="literal">FunctionCatalog</code> so the default function names are the same as the bean names.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_notes_on_jar_layout_2" href="#_notes_on_jar_layout_2"></a>10.2.1&nbsp;Notes on JAR Layout</h3></div></div></div><p>You don&#8217;t need the Spring Cloud Function Web at runtime in Azure, so you can exclude this before you create the JAR you deploy to Azure, but it won&#8217;t be used if you include it so it doesn&#8217;t hurt to leave it in. A function application on Azure is an archive generated by the Maven plugin. The function lives in the JAR file generated by this project. The sample creates it as an executable jar, using the thin layout, so that Azure can find the handler classes. If you prefer you can just use a regular flat JAR file. The dependencies should <span class="strong"><strong>not</strong></span> be included.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_build" href="#_build"></a>10.2.2&nbsp;Build</h3></div></div></div><pre class="screen">./mvnw -U clean package</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_running_the_sample" href="#_running_the_sample"></a>10.2.3&nbsp;Running the sample</h3></div></div></div><p>You can run the sample locally, just like the other Spring Cloud Function samples:</p><p></p><p></p><p>and <code class="literal">curl -H "Content-Type: text/plain" localhost:8080/function -d '{"value": "hello foobar"}'</code>.</p><p>You will need the <code class="literal">az</code> CLI app (see <a class="link" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-java-maven" target="_top">https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-java-maven</a> for more detail). To deploy the function on Azure runtime:</p><pre class="screen">$ az login
$ mvn azure-functions:deploy</pre><p>On another terminal try this: <code class="literal">curl <a class="link" href="https://<azure-function-url-from-the-log&gt;/api/uppercase" target="_top">https://&lt;azure-function-url-from-the-log&gt;/api/uppercase</a> -d '{"value": "hello foobar!"}'</code>. Please ensure that you use the right URL for the function above. Alternatively you can test the function in the Azure Dashboard UI (click on the function name, go to the right hand side and click "Test" and to the bottom right, "Run").</p><p>The input type for the function in the Azure sample is a Foo with a single property called "value". So you need this to test it with something like below:</p><pre class="screen">{
  "value": "foobar"
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The Azure sample app is written in the "non-functional" style (using <code class="literal">@Bean</code>). The functional style (with just <code class="literal">Function</code> or <code class="literal">ApplicationContextInitializer</code>) is much faster on startup in Azure than the traditional <code class="literal">@Bean</code> style, so if you don&#8217;t need <code class="literal">@Beans</code> (or <code class="literal">@EnableAutoConfiguration</code>) it&#8217;s a good choice. Warm starts are not affected.</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_apache_openwhisk" href="#_apache_openwhisk"></a>10.3&nbsp;Apache Openwhisk</h2></div></div></div><p>The <a class="link" href="https://openwhisk.apache.org/" target="_top">OpenWhisk</a> adapter is in the form of an executable jar that can be used in a a docker image to be deployed to Openwhisk. The platform works in request-response mode, listening on port 8080 on a specific endpoint, so the adapter is a simple Spring MVC application.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_quick_start" href="#_quick_start"></a>10.3.1&nbsp;Quick Start</h3></div></div></div><p>Implement a POF (be sure to use the <code class="literal">functions</code> package):</p><pre class="screen">package functions;

import java.util.function.Function;

public class Uppercase implements Function&lt;String, String&gt; {

	public String apply(String input) {
		return input.toUpperCase();
	}
}</pre><p>Install it into your local Maven repository:</p><pre class="screen">./mvnw clean install</pre><p>Create a <code class="literal">function.properties</code> file that provides its Maven coordinates. For example:</p><pre class="screen">dependencies.function: com.example:pof:0.0.1-SNAPSHOT</pre><p>Copy the openwhisk runner JAR to the working directory (same directory as the properties file):</p><pre class="screen">cp spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk/target/spring-cloud-function-adapter-openwhisk-2.0.0.BUILD-SNAPSHOT.jar runner.jar</pre><p>Generate a m2 repo from the <code class="literal">--thin.dryrun</code> of the runner JAR with the above properties file:</p><pre class="screen">java -jar -Dthin.root=m2 runner.jar --thin.name=function --thin.dryrun</pre><p>Use the following Dockerfile:</p><pre class="screen">FROM openjdk:8-jdk-alpine
VOLUME /tmp
COPY m2 /m2
ADD runner.jar .
ADD function.properties .
ENV JAVA_OPTS=""
ENTRYPOINT [ "java", "-Djava.security.egd=file:/dev/./urandom", "-jar", "runner.jar", "--thin.root=/m2", "--thin.name=function", "--function.name=uppercase"]
EXPOSE 8080</pre><div class="blockquote"><blockquote class="blockquote"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>you could use a Spring Cloud Function app, instead of just a jar with a POF in it, in which case you would have to change the way the app runs in the container so that it picks up the main class as a source file. For example, you could change the <code class="literal">ENTRYPOINT</code> above and add <code class="literal">--spring.main.sources=com.example.SampleApplication</code>.</p></td></tr></table></div></blockquote></div><p>Build the Docker image:</p><pre class="screen">docker build -t [username/appname] .</pre><p>Push the Docker image:</p><pre class="screen">docker push [username/appname]</pre><p>Use the OpenWhisk CLI (e.g. after <code class="literal">vagrant ssh</code>) to create the action:</p><pre class="screen">wsk action create example --docker [username/appname]</pre><p>Invoke the action:</p><pre class="screen">wsk action invoke example --result --param payload foo
{
    "result": "FOO"
}</pre></div></div></div></div></body></html>